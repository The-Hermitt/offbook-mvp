<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>OFFBOOK — Rehearsal MVP</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <style>
    :root {
      --bg:#05070d;
      --panel:rgba(18,21,30,0.78);
      --panel-2:rgba(12,14,22,0.85);
      --text:#f2f4ff;
      --muted:#9aa3bc;
      --border:rgba(118,130,164,0.2);
      --focus:#9ab2ff;
      --accent:#8da2ff;
      --danger:#ef4444;
      --ok:#16a34a;
      --warn:#f4c542;
      --maxw:760px;
    }
    *{ box-sizing:border-box }
    html,body{
      margin:0;
      padding:0;
      min-height:100%;
      background:
        radial-gradient(circle at 20% 18%, rgba(74,97,162,0.32), transparent 58%),
        radial-gradient(circle at 78% 4%, rgba(156,104,255,0.22), transparent 52%),
        radial-gradient(circle at 48% 120%, rgba(76,83,112,0.35), transparent 55%),
        #05060a;
      color:var(--text);
      font-family:"SF Pro Display","SF Pro Text",-apple-system,system-ui,"Segoe UI",Roboto,Arial,sans-serif;
      -webkit-font-smoothing:antialiased;
    }
    body{ position:relative }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background:linear-gradient(150deg, rgba(255,255,255,0.05), rgba(0,0,0,0.68) 65%);
      mix-blend-mode:screen;
      opacity:0.7;
      z-index:0;
    }
    header{
      padding:28px 20px 18px;
      position:relative;
      z-index:1;
    }
    header .brand{
      max-width:var(--maxw);
      margin:0 auto;
      display:flex;
      align-items:center;
      gap:16px;
    }
    .brand-copy{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .brand-title{
      font-size:22px;
      font-weight:700;
      letter-spacing:.4px;
    }
    .brand-subtitle{
      font-size:13px;
      color:var(--muted);
      letter-spacing:2.4px;
      text-transform:uppercase;
    }
    main{
      padding:8px 20px 120px;
      max-width:var(--maxw);
      margin:0 auto;
      position:relative;
      z-index:1;
    }
    main::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius:36px;
      background:linear-gradient(140deg, rgba(255,255,255,0.05), rgba(12,14,21,0.82));
      box-shadow:0 50px 120px rgba(3,5,12,0.6);
      z-index:-1;
      pointer-events:none;
    }
    main > *:first-child{ margin-top:20px }
    .card{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:24px;
      padding:20px;
      box-shadow:0 25px 60px rgba(3,6,15,0.45);
      backdrop-filter:blur(24px);
      -webkit-backdrop-filter:blur(24px);
    }
    h3,h4{
      margin:4px 0 14px;
      font-size:20px;
      font-weight:700;
      letter-spacing:.3px;
    }
    .hint{
      color:var(--muted);
      font-size:13px;
      line-height:1.5;
      letter-spacing:.2px;
    }
    label{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin:10px 0 6px;
      letter-spacing:.4px;
      text-transform:uppercase;
    }
    input[type="text"],textarea,select{
      width:100%;
      border:1px solid rgba(147,160,195,0.28);
      background:rgba(9,11,20,0.75);
      color:var(--text);
      border-radius:16px;
      padding:12px 14px;
      font-size:15px;
      transition:border-color .2s ease, box-shadow .2s ease, background .2s ease;
    }
    input[type="text"]:focus,textarea:focus,select:focus{
      outline:none;
      border-color:var(--focus);
      box-shadow:0 0 0 4px rgba(130,158,255,0.18);
      background:rgba(12,14,24,0.92);
    }
    textarea{ min-height:130px; line-height:1.4; resize:vertical }
    select{ appearance:none }
    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      background:linear-gradient(135deg, rgba(147,167,255,0.96), rgba(218,223,255,0.96));
      color:#05070d;
      border:none;
      padding:12px 18px;
      border-radius:16px;
      font-weight:700;
      font-size:15px;
      min-height:46px;
      cursor:pointer;
      letter-spacing:.3px;
      box-shadow:0 18px 36px rgba(85,115,255,0.35);
      transition:transform .2s ease, box-shadow .2s ease;
    }
    .btn:hover{ transform:translateY(-1px); box-shadow:0 20px 40px rgba(85,115,255,0.4) }
    .btn:active{ transform:translateY(0); box-shadow:0 12px 26px rgba(85,115,255,0.28) }
    .btn.secondary{
      background:rgba(15,19,30,0.6);
      color:var(--text);
      border:1px solid rgba(150,164,200,0.3);
      box-shadow:none;
    }
    .btn.secondary:hover{ border-color:rgba(154,178,255,0.5) }
    .btn.ghost{
      background:rgba(10,12,20,0.45);
      color:var(--muted);
      border:1px dashed rgba(150,164,200,0.3);
      box-shadow:none;
    }
    .btn.sm{ padding:8px 12px; font-size:12px; border-radius:12px; min-height:34px }
    .row{ display:flex; gap:10px } .row>*{ flex:1 }
    .spacer6{ height:6px } .spacer8{ height:8px } .spacer12{ height:12px } .spacer16{ height:16px }
    .tabbar{
      position:fixed;
      bottom:0;
      left:0;
      right:0;
      background:rgba(10,12,20,0.88);
      border-top:1px solid rgba(120,132,168,0.2);
      padding:8px 12px 16px;
      z-index:40;
      backdrop-filter:blur(22px);
      -webkit-backdrop-filter:blur(22px);
      box-shadow:0 -12px 24px rgba(0,0,0,0.4);
    }
    .tabbar-inner{
      max-width:var(--maxw);
      margin:0 auto;
      display:grid;
      grid-template-columns:repeat(6,1fr);
      gap:8px;
    }
    .tabbar button{
      appearance:none;
      border:none;
      background:transparent;
      color:var(--muted);
      padding:12px 4px;
      font-size:12px;
      font-weight:600;
      letter-spacing:.3px;
      border-radius:14px;
      transition:color .2s ease, background .2s ease;
    }
    .tabbar button.active{
      color:var(--text);
      background:linear-gradient(135deg, rgba(147,167,255,0.18), rgba(229,233,255,0.05));
    }
    .screen{ display:none; pointer-events:auto } .screen.active{ display:block }
    .inner-tabs{ display:flex; gap:10px }
    .inner-tabs button{
      flex:1;
      border:1px solid rgba(147,160,195,0.3);
      background:rgba(9,12,20,0.6);
      color:var(--text);
      padding:11px;
      border-radius:14px;
      font-weight:700;
      letter-spacing:.3px;
      transition:border-color .2s ease, background .2s ease;
    }
    .inner-tabs button.active{
      background:rgba(17,21,34,0.85);
      border-color:var(--focus);
      box-shadow:0 10px 24px rgba(85,115,255,0.25);
    }
    pre.status{
      white-space:pre-wrap;
      word-break:break-word;
      background:rgba(7,9,16,0.75);
      border:1px dashed rgba(147,160,195,0.35);
      border-radius:16px;
      padding:10px 12px;
      color:#b5c0d8;
      min-height:24px;
    }
    .pill{
      display:inline-block;
      padding:6px 12px;
      border-radius:999px;
      border:1px solid rgba(147,160,195,0.32);
      background:rgba(12,15,24,0.75);
      font-size:12px;
      margin-right:6px;
      letter-spacing:.3px;
    }
    .small{ font-size:12px; color:var(--muted); letter-spacing:.2px }

    /* Rehearse render status — keep visible and readable */
    #rehearseRenderStatus{
      display:block;
      margin-top:6px;
      padding:8px 10px;
      background:rgba(9,12,20,0.65);
      border:1px dashed rgba(147,160,195,0.35);
      border-radius:12px;
      line-height:1.35;
      min-height:22px;              /* keeps the bar from collapsing */
    }
    #rehearseRenderStatus .dots{ margin-left:6px }
    /* Rehearse */
    .line{
      padding:12px 14px;
      border-radius:18px;
      border:1px solid rgba(120,134,170,0.25);
      margin-bottom:10px;
      background:rgba(9,12,20,0.68);
      position:relative;
      box-shadow:0 16px 36px rgba(3,6,15,0.35);
    }
    .line.me{ border-color:rgba(144,167,255,0.55); background:rgba(17,20,32,0.9); box-shadow:0 22px 40px rgba(90,118,255,0.35) }
    .line .who{ font-weight:700; margin-bottom:6px; letter-spacing:.25px }
    .line .text{ line-height:1.5; color:var(--text) }
    .controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    .playing{ outline:2px solid var(--focus); outline-offset:2px }
    .badge{
      font-size:11px;
      padding:5px 10px;
      border-radius:999px;
      border:1px solid rgba(147,160,195,0.32);
      background:rgba(10,12,20,0.7);
      color:#b5c0d8;
      letter-spacing:.2px;
    }
    .badge.ok{ color:#4ade80 }
    .badge.warn{ color:#f4c542 }
    .badge.err{ color:#ff7b7b }
    .editbar{ position:absolute; top:10px; right:10px; display:flex; gap:8px }
    .chip{
      font-size:11px;
      padding:5px 10px;
      border-radius:999px;
      border:1px solid rgba(147,160,195,0.32);
      background:rgba(12,15,24,0.7);
      color:#b5c0d8;
      cursor:pointer;
      user-select:none;
      letter-spacing:.2px;
    }
    .chip.danger{ border-color:#e96; color:#ff7b7b }
    .text[contenteditable="true"]{ outline:1px dashed var(--focus); border-radius:10px; padding:6px; background:rgba(7,10,18,0.6) }
    .inline-slot{ display:none; align-items:center; justify-content:center; margin:12px 0 14px }
    .inline-slot .ghostline{ width:100%; border:1px dashed rgba(147,160,195,0.3); border-radius:16px; padding:12px }
    .inline-form{ width:100%; background:rgba(9,12,20,0.72); border:1px solid rgba(147,160,195,0.3); border-radius:18px; padding:14px; margin-top:10px }

    /* Sticky toolbar */
    .toolbar{
      position:sticky;
      top:0;               /* stays pinned, but no overlap */
      z-index:30;
      margin:0 -20px 16px; /* remove negative top margin that hid status */
      padding:16px env(safe-area-inset-right) 16px env(safe-area-inset-left);
      background:linear-gradient(180deg, rgba(10,12,20,0.92) 0%, rgba(9,11,18,0.88) 100%);
      border-bottom:1px solid rgba(118,130,164,0.2);
      border-top-left-radius:24px;
      border-top-right-radius:24px;
      backdrop-filter:blur(18px);
      -webkit-backdrop-filter:blur(18px);
      box-shadow:0 25px 60px rgba(3,6,15,0.45);
    }
    .toolbar .controls{ justify-content:space-between }
    .toolbar .left, .toolbar .right{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    .btn.icon{ min-width:auto; padding:12px }
    .btn.icon::before{ content:"⟲"; font-weight:900; font-size:20px; line-height:1; display:block; }

    /* Record */
    .rec-grid{ display:grid; grid-template-columns:1fr; gap:12px }
    .vid{
      width:100%;
      aspect-ratio:9/16;
      background:#000;
      border-radius:22px;
      border:1px solid rgba(118,130,164,0.25);
      object-fit:cover;
      box-shadow:0 25px 55px rgba(0,0,0,0.55);
    }
    .countdown{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(5,7,12,0.78);
      backdrop-filter:blur(10px);
      z-index:1000;
    }
    .countdown.show{ display:flex }
    .count-num{
      font-size:68px;
      font-weight:800;
      background:linear-gradient(135deg, rgba(20,22,32,0.95), rgba(7,8,14,0.95));
      color:#fff;
      padding:26px 42px;
      border-radius:22px;
      border:1px solid rgba(147,160,195,0.3);
      box-shadow:0 28px 70px rgba(0,0,0,0.55);
    }
    .gallery-item{
      border:1px solid rgba(147,160,195,0.28);
      border-radius:18px;
      padding:12px;
      margin-bottom:10px;
      background:rgba(9,12,20,0.7);
      box-shadow:0 18px 40px rgba(3,6,15,0.35);
    }

    /* === Record: 16x9 + right rail (uniform pills / responsive with grid areas) === */
    .record-grid{
      display:grid;
      grid-template-columns: minmax(0,1.2fr) 300px; /* more space to the preview */
      grid-template-rows: auto auto;
      grid-template-areas:
        "preview rail"
        "status  rail";
      gap:14px;
      align-items:start;
    }

    .preview-wrap{ grid-area: preview; width:100%;
      background:rgba(9,12,20,0.6);
      border:1px solid var(--border);
      border-radius:22px;
      padding:12px;
      box-shadow:0 25px 55px rgba(3,6,15,0.45);
      position:relative;
    }

    .vid16x9{
      width:100%;
      aspect-ratio:16/9;
      background:#000;
      border-radius:16px;
      border:1px solid rgba(118,130,164,0.25);
      object-fit:cover;
      display:block;
    }

    .control-rail{ grid-area: rail; display:grid; grid-template-columns: 1fr; gap:12px }
    .control-rail .btn{ width:100%; min-height:48px; border-radius:18px } /* uniform pills */

    /* REC visual states */
    .btn.rec{
      background:radial-gradient(120px 120px at 50% 30%, rgba(255,88,88,0.4), rgba(255,0,0,0.15)), linear-gradient(135deg, #ff6666, #ff2d2d);
      color:#fff; box-shadow:0 18px 36px rgba(255,80,80,0.35);
    }
    .btn.rec.recording{
      background:linear-gradient(135deg, #191b28, #121522);
      color:#ff6969; border:1px solid rgba(255,120,120,0.4);
    }

    #statusRec{
      grid-area: status;
      min-height:22px;
      padding:10px 12px;
      white-space:pre;                 /* no weird line breaks */
      overflow:auto;
    }

    /* Flip camera translucent overlay */
    .flipcam{
      position:absolute;
      right:16px; bottom:16px;
      width:44px; height:44px;
      border-radius:999px;
      border:1px solid rgba(147,160,195,0.35);
      background:rgba(12,15,24,0.55);
      color:#cfd7ff;
      font-weight:700;
      box-shadow:0 10px 24px rgba(3,6,15,0.35);
      backdrop-filter:blur(8px);
      cursor:pointer;
    }
    .flipcam:active{ transform:scale(0.98) }

    /* --- Portrait (stack): Render+REC full width, then 2x2 control rows --- */
    @media (max-width: 860px){
      .record-grid{
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
        grid-template-areas:
          "preview"
          "rail"
          "status";
        gap:12px;
      }
      .control-rail{
        display:grid;
        grid-template-columns: 1fr 1fr;
        gap:12px;
        align-items:start;
      }
      /* Row 1: Render + REC full width */
      #btnRender{ grid-column: 1 / -1; }
      #btnRec{ grid-column: 1 / -1; }

      /* Row 2: Camera | Count-in */
      #btnCamera{ grid-column: 1 / 2; }
      #btnCountIn{ grid-column: 2 / 3; }

      /* Row 3: Headphones full width; Status full width under it */
      #btnHeadphones{ grid-column: 1 / -1; }
      #statusRec{ grid-column: 1 / -1; }

      /* Prevent odd narrow wrapping on status in portrait */
      #statusRec{ white-space: normal; min-height: 44px; }
    }

    /* --- Landscape: single rail column with identical widths --- */
    @media (min-width: 861px){
      .control-rail{ grid-template-columns: 1fr; }
      /* ensure status stays under preview column */
      #statusRec{ grid-column: 1 / 2; }
    }

    /* L→R dots for loading */
    .dots { display:inline-flex; gap:6px; align-items:center; vertical-align:middle }
    .dot { width:6px; height:6px; border-radius:50%; background:#7aa0ff; opacity:.25; }
    .dot.on { opacity:1 }

    /* Error banner */
    .errbar{
      position:sticky;
      top:0;
      z-index:50;
      display:none;
      padding:10px 16px;
      background:rgba(43,15,18,0.85);
      color:#ffb3b3;
      border-bottom:1px solid rgba(122,42,42,0.5);
      font-size:12px;
      letter-spacing:.3px;
      backdrop-filter:blur(14px);
      -webkit-backdrop-filter:blur(14px);
    }
    .errbar.show{ display:block }
  </style>
</head>
<body>
  <div id="errbar" class="errbar" role="alert"></div>
  <header>
    <div class="brand">
      <div class="brand-copy">
        <span class="brand-title">OFFBOOK</span>
        <span class="brand-subtitle">Rehearse. Record. Book.</span>
      </div>
    </div>
  </header>

  <main>
    <!-- IMPORT -->
    <section id="screen-import" class="screen active">
      <div class="card">
        <h3>Import</h3>
        <p class="hint">Two ways to import. <b>Paste Script Text</b> is most reliable; <b>Upload PDF</b> extracts text with an OCR fallback for scanned PDFs.</p>
        <div class="inner-tabs" role="tablist">
          <button id="tab-text" class="active" role="tab" aria-controls="panel-text" aria-selected="true">Paste Script Text</button>
          <button id="tab-pdf" role="tab" aria-controls="panel-pdf" aria-selected="false">Upload PDF</button>
        </div>
        <div class="spacer12"></div>

        <!-- TEXT PANEL -->
        <div id="panel-text" role="tabpanel" aria-labelledby="tab-text">
          <label>Title</label>
          <input id="titleText" type="text" placeholder="My Sides" />
          <label>Paste script here</label>
          <textarea id="scriptText" placeholder="JANE: Hi.
GABE: Hey.
JANE: Ready?"></textarea>
          <div class="spacer8"></div>
          <div class="row">
            <button id="btnTextUpload" class="btn">Continue → Assign</button>
            <button id="btnTextClear" class="btn secondary">Clear</button>
          </div>
          <div class="spacer12"></div>
          <label>Status</label>
          <pre id="status" class="status"></pre>
        </div>

        <!-- PDF PANEL -->
        <div id="panel-pdf" role="tabpanel" aria-labelledby="tab-pdf" hidden>
          <label>Title</label>
          <input id="titlePdf" type="text" placeholder="My PDF Sides" />
          <label>PDF File</label>
          <input id="pdfFile" type="file" accept="application/pdf" />
          <div class="spacer8"></div>
          <div class="row">
            <button id="btnPdfUpload" class="btn">Upload & Continue</button>
            <button id="btnPdfOcr" class="btn ghost" title="Use OCR if your PDF is scanned images" disabled>Try OCR (slow)</button>
          </div>
          <div class="spacer12"></div>
          <label>Status</label>
          <pre id="statusPdf" class="status"></pre>
          <div class="small">Tip: OCR processes the first 3 pages for speed.</div>
        </div>
      </div>
    </section>

    <!-- ASSIGN -->
    <section id="screen-assign" class="screen">
      <div class="card">
        <h3>Assign</h3>
        <div><span class="pill" id="pillScript">script: —</span> <span class="pill" id="pillScenes">scenes: 0</span></div>
        <div class="spacer8"></div>
        <label>I am…</label>
        <select id="selectRole"></select>
        <div class="spacer8"></div>
        <div id="voicePickers"></div>
        <div class="spacer8"></div>
        <button id="btnSaveAssign" class="btn">Save Voices</button>
      </div>
    </section>

    <!-- REHEARSE -->
    <section id="screen-rehearse" class="screen">
      <div class="card">
        <h3>Rehearse</h3>

        <div class="hint" id="rehearseBanner"><b>Review and edit your script first</b> before rendering for rehearsal. When ready, press “Render for rehearsal (OpenAI)” to pre-load partner voices for perfect timing.</div>
        <div class="spacer8"></div>

        <div class="row">
          <button id="btnToggleEditMode" class="btn secondary" aria-pressed="false">Edit Script</button>
          <span class="badge">Edit mode: <span id="editModeState">Off</span></span>
        </div>
        <div class="spacer8"></div>

        <div class="row">
          <button id="btnRehearseRender" class="btn">Render for rehearsal (OpenAI)</button>
          <button id="btnRehearseClear" class="btn secondary" title="Discard pre-rendered clips">Clear Render</button>
        </div>
        <div class="spacer6"></div>
        <div class="row">
          <label>Render quality</label>
          <select id="selTtsModel">
            <option value="tts-1" selected>Fast</option>
            <option value="tts-1-hd">Natural (HD)</option>
          </select>
        </div>
        <div class="spacer6"></div>
        <div class="small" id="rehearseRenderStatus"></div>

        <div class="spacer12"></div>

        <div class="toolbar" aria-label="Playback controls">
          <div class="controls">
            <div class="left">
              <button id="btnPlay" class="btn">Play</button>
              <button id="btnPrev" class="btn secondary">Prev</button>
              <button id="btnNext" class="btn secondary">Next</button>
              <button id="btnTop" class="btn secondary icon" title="From the top"></button>
              <select id="selPace" title="Partner pacing">
                <option value="0" selected>No gap</option>
                <option value="80">+80 ms</option>
                <option value="160">+160 ms</option>
                <option value="300">+300 ms</option>
              </select>
            </div>
            <div class="right">
              <button id="btnMic" class="btn secondary" aria-pressed="false">Mic: Off</button>
              <span id="micBadge" class="badge warn">off</span>
            </div>
          </div>
        </div>

        <div id="lines"></div>
      </div>
    </section>

    <!-- RECORD -->
    <section id="screen-record" class="screen">
      <div class="card record-grid">
        <!-- Left: 16x9 preview window -->
        <div class="preview-wrap">
          <video id="preview" class="vid16x9" autoplay muted playsinline></video>
          <audio id="readerAudio" preload="auto" playsinline></audio>
        </div>

          <!-- overlay flip button -->
          <button id="btnFlipCam" class="flipcam" aria-label="Flip camera" title="Flip camera">⟳</button>
        </div>

        <!-- Right: compact control rail -->
        <div class="control-rail">
          <button id="btnRender" class="btn rail">Render</button>
          <button id="btnRec" class="btn rec">REC</button>
          <button id="btnCamera" class="btn secondary rail" aria-pressed="false">Camera: Off</button>
          <button id="btnCountIn" class="btn secondary rail" aria-pressed="true">Count-in: On</button>
          <button id="btnHeadphones" class="btn secondary rail" aria-pressed="true">Headphones: On</button>
        </div>

        <!-- Status under preview in landscape; spans full width in portrait -->
        <pre id="statusRec" class="status"></pre>
      </div>
    </section>

    <!-- GALLERY -->
    <section id="screen-gallery" class="screen">
      <div class="card">
        <h3>Gallery</h3>
        <div id="takes"></div>
        <div class="hint">Takes are saved locally in your browser. Download to keep.</div>
      </div>
    </section>

    <!-- SETTINGS -->
    <section id="screen-settings" class="screen"><div class="card"><h3>Settings</h3><p class="hint">Defaults & storage (future).</p></div></section>
  </main>

  <!-- Bottom bar -->
  <nav class="tabbar" role="tablist" aria-label="App sections">
    <div class="tabbar-inner">
      <button data-tab="import" class="active" role="tab" aria-selected="true">Import</button>
      <button data-tab="assign" role="tab" aria-selected="false">Assign</button>
      <button data-tab="rehearse" role="tab" aria-selected="false">Rehearse</button>
      <button data-tab="record" role="tab" aria-selected="false">Record</button>
      <button data-tab="gallery" role="tab" aria-selected="false">Gallery</button>
      <button data-tab="settings" role="tab" aria-selected="false">Settings</button>
    </div>
  </nav>

  <!-- Vendor -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.6.82/pdf.min.mjs" type="module"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <!-- App -->
  <script type="module">
    const boot = () => {
      const qs = new URLSearchParams(location.search);
      const secret = qs.get("secret") || "1976";
      const JSON_HDRS = { "Content-Type":"application/json", ...(secret?{"X-Shared-Secret":secret}:{}) };
      const $ = (s,r=document)=>r.querySelector(s);
      const $$ = (s,r=document)=>Array.from(r.querySelectorAll(s));
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform==='MacIntel' && navigator.maxTouchPoints>1);

      const errbar=$("#errbar");
      function showErr(msg){ errbar.textContent=msg; errbar.classList.add("show"); }

      function showScreen(name){
        $$(".countdown").forEach(x=>x.classList.remove("show"));
        stopAllAudioHard();
        if(name!=="record"){
          try{ if(R?.recording){ stopRecording(); } }catch{}
          try{ cleanupStream(); }catch{}
        }
        $$(".screen").forEach(s=>s.classList.remove("active"));
        $("#screen-"+name).classList.add("active");
        $$(".tabbar button").forEach(b=>b.classList.remove("active"));
        const btn=document.querySelector(`.tabbar button[data-tab="${name}"]`);
        if(btn) btn.classList.add("active");
        if(name==="rehearse"){
          try{ primeReaderFromCacheIfAvailable(); }catch{}
        }else if(name==="record"){
          try{ primeReaderFromCacheIfAvailable(); }catch{}
          try{ requestMicPermissionOnce(); }catch{}
          try{ startPreviewIfNeeded(); }catch{}
          try{ setRailStates(); }catch{}
        }
      }
      $$(".tabbar button").forEach(b=>b.addEventListener("click",()=>showScreen(b.dataset.tab)));

      // inner tabs
      const tabText=$("#tab-text"), tabPdf=$("#tab-pdf"), panelText=$("#panel-text"), panelPdf=$("#panel-pdf");
      tabText?.addEventListener("click",()=>{ tabText.classList.add("active"); tabPdf.classList.remove("active"); panelText.hidden=false; panelPdf.hidden=true; });
      tabPdf?.addEventListener("click",()=>{ tabPdf.classList.add("active"); tabText.classList.remove("active"); panelPdf.hidden=false; panelText.hidden=true; });

      // state
      const S={ script_id:"", scenes:[], role:"", voice_map:{}, editMode:false, supportedVoices:["alloy"] };

      // helpers
      const setStatus = msg => $("#status").textContent = msg || "";
      const setStatusPdf = msg => $("#statusPdf").textContent = msg || "";

      // --- Global audio stop (kills any lingering playback/SR) ---
      function resetReaderActiveSources(){
        try{
          if(R && R.readerActiveSources instanceof Set){
            R.readerActiveSources.forEach(src=>{ try{ if(src && typeof src.stop === "function") src.stop(0); }catch{} });
            R.readerActiveSources.clear();
          }
          if(R && !(R.readerActiveSources instanceof Set)) R.readerActiveSources = new Set();
        }catch{}
      }

      function stopAllAudioHard() {
        try { window.speechSynthesis?.cancel(); } catch {}
        try { E?.rehearseAudio?.pause(); E.rehearseAudio.currentTime = 0; } catch {}
        try { R?.audio?.pause(); R.audio.currentTime = 0; } catch {}
        resetReaderActiveSources();
        try { sr?.stop(); } catch {}
        try { clearMy?.(); } catch {}
        try { playing = false; } catch {}
      }

      // Persist cached reader clips across tabs (and reloads)
      const ReaderCache = {
        get() {
          try {
            const raw = sessionStorage.getItem("rr_map_v1");
            if (!raw) return new Map();
            const arr = JSON.parse(raw);
            return new Map(arr);
          } catch { return new Map(); }
        },
        set(map) {
          try {
            const arr = Array.from(map.entries());
            sessionStorage.setItem("rr_map_v1", JSON.stringify(arr));
          } catch {}
        }
      };

      async function safeJson(r){ const t=await r.text(); try{return JSON.parse(t)}catch{return {raw:t}} }

      async function loadSupportedVoices(){
        try{
          const r = await fetch("/debug/voices_probe", { headers: JSON_HDRS });
          const j = await safeJson(r);
          if(r.ok && Array.isArray(j.voices) && j.voices.length){ S.supportedVoices=j.voices; }
        }catch(e){ /* keep default */ }
      }

      async function loadScenes(){
        try{
          const r=await fetch("/debug/scenes?script_id="+encodeURIComponent(S.script_id),{headers:JSON_HDRS});
          const j=await safeJson(r); if(!r.ok) return;
          S.scenes=j.scenes||[];
          await loadSupportedVoices();
          hydrateAssign(); hydrateRehearse(); applyEditModeUI();
        }catch(e){ showErr("Init warning: couldn’t load scenes. You can still re-import."); }
      }

      function sanitizeScriptText(raw){
        const lines = String(raw||"").split(/\r?\n/);
        const drop=[/sides\s+by\s+breakdown\s+services/i,/actors\s+access/i,/do\s+not\s+share/i,/copyright/i,/^page\s+\d+(\s*of\s*\d+)?$/i,/^https?:\/\/\S+/i,/^\s*(INT\.|EXT\.|SCENE)\b/i,/^[A-Z0-9 .,'&/()-]{6,}\s*$/];
        const kept=[]; for(const ln of lines){ const t=ln.trim(); if(!t){ kept.push(""); continue; } if(drop.some(rx=>rx.test(t))) continue; if(/^\(.*\)$/.test(t)) continue; kept.push(ln); } return kept.join("\n");
      }

      // Import: text
      $("#btnTextUpload")?.addEventListener("click", async ()=>{
        const title=$("#titleText").value||"Sides";
        const text=sanitizeScriptText($("#scriptText").value||"");
        setStatus("Uploading text…");
        try{
          const r=await fetch("/debug/upload_script_text",{method:"POST",headers:JSON_HDRS,body:JSON.stringify({title,text})});
          const j=await safeJson(r);
          if(!r.ok){ setStatus("Error "+r.status+": "+JSON.stringify(j)); return; }
          setStatus(`OK scenes=${j.scene_count} speakers=${(j.speakers||[]).join(", ")}`);
          S.script_id=j.script_id; await loadScenes(); showScreen("assign");
        }catch(e){ setStatus("Network error: "+e); }
      });
      $("#btnTextClear")?.addEventListener("click",()=>{ $("#titleText").value=""; $("#scriptText").value=""; setStatus(""); });

      // Import: PDF
      $("#btnPdfUpload")?.addEventListener("click", async ()=>{
        const title=$("#titlePdf").value||"PDF Sides"; const file=$("#pdfFile").files[0];
        if(!file){ setStatusPdf("Choose a PDF first."); return; }
        const fd=new FormData(); fd.append("title",title); fd.append("pdf",file);
        const hdrs={}; if(secret) hdrs["X-Shared-Secret"]=secret;
        setStatusPdf("Uploading PDF…");
        try{
          const r=await fetch("/debug/upload_script_upload",{method:"POST",headers:hdrs,body:fd});
          const j=await safeJson(r);
          if(!r.ok){ setStatusPdf("Error "+r.status+": "+JSON.stringify(j)); return; }
          const sp=(j.speakers||[]).join(", "); const note=j.note?(" note="+j.note):"";
          setStatusPdf(`OK scenes=${j.scene_count} speakers=${sp||"(none)"} textLen=${j.textLen||0}${note}`);
          if(j.note==="image-only"||j.note==="parse-error"){ $("#btnPdfOcr").disabled=false; $("#btnPdfOcr").focus(); return; }
          S.script_id=j.script_id; await loadScenes(); showScreen("assign");
        }catch(e){ setStatusPdf("Network error: "+e); }
      });

      // Assign
      function uniqueRoles(){ const names=new Set(); for(const sc of (S.scenes||[])) for(const ln of (sc.lines||[])) names.add(ln.speaker); return Array.from(names).filter(n=>n&&n!=="SYSTEM"&&n!=="NARRATOR"); }
      function hydrateAssign(){
        $("#pillScript").textContent="script: "+(S.script_id||"—");
        $("#pillScenes").textContent="scenes: "+(S.scenes?.length||0);
        const roles=uniqueRoles(); const sel=$("#selectRole");
        sel.innerHTML=roles.map(r=>`<option value="${r}">${r}</option>`).join("");
        if(!S.role&&roles.length) S.role=roles[0];
        sel.value=S.role||"";
        sel.onchange=()=>{ S.role=sel.value; buildVoicePickers(); hydrateRehearse(); applyEditModeUI(); };
        buildVoicePickers();
      }
      function buildVoicePickers(){
        const box=$("#voicePickers"); box.innerHTML="";
        const partners=uniqueRoles().filter(n=>n!==S.role);
        partners.forEach(name=>{
          const wrap=document.createElement("div");
          wrap.className="card"; wrap.style.marginTop="8px";
          wrap.innerHTML=`<div style="display:flex;align-items:center;justify-content:space-between;gap:10px">
            <strong>${name}</strong>
            <select data-name="${name}">
              ${S.supportedVoices.map(v=>`<option value="${v}" ${((S.voice_map[name]||S.supportedVoices[0])===v)?"selected":""}>${v}</option>`).join("")}
            </select>
          </div>`;
          box.appendChild(wrap);
        });
        box.querySelectorAll("select").forEach(el=>el.addEventListener("change",(e)=>{
          const sel = e.target; S.voice_map[sel.getAttribute("data-name")] = sel.value;
        }));
      }
      $("#btnSaveAssign")?.addEventListener("click", async ()=>{
        if(!S.script_id) return;
        const roles=uniqueRoles().filter(r=>r!==S.role);
        for(const r of roles) if(!S.voice_map[r]) S.voice_map[r]=S.supportedVoices[0] || "alloy";
        try{ await fetch("/debug/set_voice",{method:"POST",headers:JSON_HDRS,body:JSON.stringify({script_id:S.script_id,voice_map:S.voice_map})}); }catch{}
        showScreen("rehearse");
      });

      /* ------- rehearse listening/respond flow (UNCHANGED) ------- */
      const E={
        linesWrap:$("#lines"), btnPlay:$("#btnPlay"), btnPrev:$("#btnPrev"), btnNext:$("#btnNext"), btnTop:$("#btnTop"),
        selPace:"#selPace", btnMic:$("#btnMic"), micBadge:$("#micBadge"),
        btnToggleEditMode:$("#btnToggleEditMode"), editModeState:$("#editModeState"),
        inlineForm:null, currentSlotPlace:null,
        rehearseAudio:(()=>{ const a=document.createElement("audio"); a.preload="auto"; a.setAttribute("playsinline",""); a.style.display="none"; document.body.appendChild(a); return a; })()
      };
      let idx=0, playing=false;

      const isParenOnly=t=>/^\(.*\)$/.test((t||"").trim());
      const isBoilerplate=t=>{ const s=(t||"").trim().toLowerCase(); if(!s) return true; if(/^[-–—]+$/.test(s)) return true; if(/^\d{1,4}$/.test(s)) return true; if(/^page\s*\d+(\s*of\s*\d+)?$/i.test(s)) return true; if((/^cont'?d\.?$/i.test(s)||/^continued$/i.test(s))&&s.length<=10) return true; if(/^https?:\/\/\S+/i.test(s)) return true; return (s.includes("sides by breakdown services")||s.includes("actors access")||s.includes("do not share")||s.includes("copyright")) && s.length<=80; };

      function buildFiltered(scene){ const out=[]; for(let i=0;i<(scene?.lines?.length||0);i++){ const ln=scene.lines[i]; if(!ln) continue; if(ln.speaker==="NARRATOR") continue; if(isParenOnly(ln.text)) continue; if(isBoilerplate(ln.text)) continue; out.push({orig:i,speaker:ln.speaker,text:ln.text}); } return out; }
      function getScene(){ return S.scenes[0]; }
      function myName(){ return S.role||uniqueRoles()[0]||""; }

      function inlineSlot(place){ return `<div class="inline-slot" data-place="${place}"><div class="ghostline"><button class="btn ghost sm" data-add-button>+ Add here</button></div></div>`; }

      function hydrateRehearse(){
        const scene=getScene(); const list=buildFiltered(scene);
        if(!list.length){ $("#lines").innerHTML="<p class='hint'>Import a script first.</p>"; return; }
        let html=inlineSlot(0);
        list.forEach((ln,i)=>{ const me=ln.speaker===myName(); html+=`<div class="line ${me?"me":""}" data-i="${i}" data-orig="${ln.orig}"><div class="editbar" style="display:${S.editMode?'flex':'none'}"><span class="chip" data-act="edit" data-i="${i}">Edit</span><span class="chip danger" data-act="del" data-i="${i}">Delete</span></div><div class="who">${ln.speaker}</div><div class="text" data-i="${i}" contenteditable="false">${ln.text}</div></div>`; html+=inlineSlot(ln.orig+1); });
        $("#lines").innerHTML=html; idx=Math.max(0,Math.min(idx,list.length-1)); wireEditTools(); wireSlots(); highlightCurrent(); applyEditModeUI();
      }
      function wireEditTools(){ $$(".chip",$("#lines")).forEach(ch=>ch.onclick=(ev)=>{ ev.stopPropagation(); const act=ch.getAttribute("data-act"); const iF=+ch.getAttribute("data-i"); const sc=getScene(); if(!sc) return; const node=document.querySelector(`.line[data-i="${iF}"]`); const orig=+node.getAttribute("data-orig"); if(Number.isNaN(orig)) return; if(act==="edit"){ if(!S.editMode) return; const t=document.querySelector(`.text[data-i="${iF}"]`); const editing=t.getAttribute("contenteditable")==="true"; if(editing){ t.setAttribute("contenteditable","false"); sc.lines[orig].text=t.innerText.trim(); hydrateRehearse(); } else { t.setAttribute("contenteditable","true"); t.focus(); const r=document.createRange(); r.selectNodeContents(t); r.collapse(false); const s=window.getSelection(); s.removeAllRanges(); s.addRange(r); } } else if(act==="del"){ if(!S.editMode) return; sc.lines.splice(orig,1); hydrateRehearse(); } }); }
      function wireSlots(){ $$('[data-add-button]',$("#lines")).forEach(btn=>btn.onclick=(ev)=>{ if(!S.editMode) return; ev.stopPropagation(); const slot=btn.closest('.inline-slot'); openInlineForm(slot, Number(slot.getAttribute("data-place"))); }); }
      function highlightCurrent(){ $$(".line",$("#lines")).forEach(el=>el.classList.remove("playing")); const cur=document.querySelector(`.line[data-i="${idx}"]`); if(cur){ cur.classList.add("playing"); cur.scrollIntoView({block:"center",behavior:(!S.editMode?"smooth":"auto")}); } }

      // simple native TTS (watchdog)
      function synthSpeak(text){
        if(!window.speechSynthesis) return Promise.resolve();
        window.speechSynthesis.cancel();
        const u=new SpeechSynthesisUtterance(text);
        const v=(window.speechSynthesis.getVoices()||[]).find(v=>/en(-|_)?/.test(v.lang));
        if(v) u.voice=v;
        u.rate=1.0; u.pitch=1.0;
        const p=new Promise(res=>{ u.onend=()=>res(); u.onerror=()=>res(); });
        window.speechSynthesis.speak(u);
        const maxMs = Math.min(9000, Math.max(1200, text.trim().length*70));
        return Promise.race([p, new Promise(res=>setTimeout(res,maxMs))]);
      }

      /* Speech Rec (unchanged timings) */
      const SR=window.SpeechRecognition||window.webkitSpeechRecognition;
      const sr=SR?new SR():null;
      let srToggleOn=false, srPermGranted=false, srActive=false;
      let myLineStartMs=0, firstEnergyAt=0, advanceLock=false, advanceCoolUntil=0;
      let latestTranscript="", silenceTimer=null, lastResultAt=0;

      // energy monitor
      let micStream=null, audioCtx=null, analyser=null, energy=0, speaking=false, lastEnergyAt=0;
      const ENERGY_TALK_THRESH=0.035, ENERGY_SILENCE_THRESH=0.020;

      function rms(buf){ let sum=0; for(let i=0;i<buf.length;i++){ const v=buf[i]/128-1; sum+=v*v; } return Math.sqrt(sum/buf.length); }
      function startMicMonitor(){
        if(micStream) return;
        navigator.mediaDevices.getUserMedia({audio:true}).then(stream=>{
          micStream=stream;
          audioCtx=new (window.AudioContext||window.webkitAudioContext)();
          const src=audioCtx.createMediaStreamSource(stream);
          analyser=audioCtx.createAnalyser(); analyser.fftSize=2048;
          src.connect(analyser);
          const data=new Uint8Array(analyser.fftSize);
          const tick=()=>{
            if(!analyser) return;
            analyser.getByteTimeDomainData(data);
            const v=rms(data);
            energy = energy*0.85 + v*0.15;
            const now=performance.now();
            if(energy>ENERGY_TALK_THRESH){ if(!speaking){ firstEnergyAt=now; } speaking=true; lastEnergyAt=now; }
            else if(energy<ENERGY_SILENCE_THRESH){ if(now-(lastEnergyAt||now)>140){ speaking=false; } }
            requestAnimationFrame(tick);
          };
          tick();
        }).catch(()=>{ /* ignore */ });
      }
      function stopMicMonitor(){ try{ micStream?.getTracks().forEach(t=>t.stop()); }catch{}; micStream=null; try{ audioCtx?.close(); }catch{}; audioCtx=null; analyser=null; energy=0; speaking=false; }

      function minElapsedFor(text){ const t=(text||"").trim(); if(t.length<=6) return 180; if(t.length<=15) return 220; if(t.length<=40) return 300; return 420; }
      function silenceDebounceFor(text){ const t=(text||"").trim(); if(t.length<=6) return 180; if(t.length<=15) return 220; if(t.length<=40) return 260; return 320; }
      const AFTER_ADV_COOLDOWN_MS=140;
      const MIN_PROGRESS_FOR_SILENCE = 0.35;

      function tokens(s){ return (s||"").toLowerCase().replace(/[^a-z0-9' ]+/g," ").split(/\s+/).filter(Boolean); }
      function lastCueWords(text){ const tks=tokens(text).filter(w=>!["uh","um"].includes(w)); if(!tks.length) return ""; const take=Math.min(2,tks.length); return tks.slice(-take).join(" "); }
      function transcriptContainsCue(tr){ const cue=lastCueWords(current()?.text||""); if(!cue) return false; return tokens(tr).join(" ").includes(cue); }
      function norm(s){ return (s||"").toLowerCase().replace(/[^a-z0-9' ]+/g," ").trim(); }
      function progressRatio(lineText, tr){ const a=norm(lineText); const b=norm(tr); if(!a) return 0; return Math.min(1, b.length / a.length); }

      function filtered(){ return buildFiltered(getScene()); }
      function current(){ return filtered()[idx]; }
      function onMyLine(){ const ln=current(); return !!ln && ln.speaker===myName(); }
      function maybeSetMyLineStart(){ if(onMyLine() && !myLineStartMs) myLineStartMs=performance.now(); }
      function clearMy(){ myLineStartMs=0; firstEnergyAt=0; advanceLock=false; latestTranscript=""; lastResultAt=0; if(silenceTimer){ clearTimeout(silenceTimer); silenceTimer=null; } }

      function updateMicBadge(){
        const srAvailable = !!sr;
        let label, cls;
        if(!srAvailable){ label = srToggleOn ? "energy only" : "off"; cls = srToggleOn ? "ok" : "warn"; }
        else{ label = !srToggleOn ? "off" : (srActive ? "listening…" : (srPermGranted ? "ready" : "needs permission"));
              cls = !srToggleOn ? "warn" : (srActive ? "ok" : (srPermGranted ? "warn" : "err")); }
        $("#micBadge").textContent = label;
        $("#micBadge").className = "badge " + cls;
        $("#btnMic").textContent = srToggleOn ? "Mic: On" : "Mic: Off";
        $("#btnMic").setAttribute("aria-pressed", srToggleOn ? "true" : "false");
      }

      async function requestMicPermissionOnce(){ if(srPermGranted) return true; try{ const s=await navigator.mediaDevices.getUserMedia({audio:true}); s.getTracks().forEach(t=>t.stop()); srPermGranted=true; return true; }catch{ srPermGranted=false; return false; } finally{ updateMicBadge(); } }

      function advanceFromMyLine(){
        const now=performance.now();
        if(advanceLock||now<advanceCoolUntil) return;
        if(!onMyLine()) return;
        const elapsed=now-(myLineStartMs||now);
        if(elapsed < minElapsedFor(current()?.text||"")) return;

        advanceLock=true;
        const list=filtered(); if(!list.length) return;
        idx=Math.min(idx+1,list.length-1);
        highlightCurrent();
        clearMy();
        try{ sr?.stop(); }catch{}
        const next=current();
        advanceCoolUntil=now+AFTER_ADV_COOLDOWN_MS;
        if(next && next.speaker===myName()){
          if(srToggleOn && srPermGranted){ setTimeout(()=>{ if(sr && !srActive) try{ sr.start(); }catch{}; },80); }
        }else{
          if(!playing) playing=true;
          step(true);
        }
      }

      function armSilenceDebounce(){
        if(silenceTimer) clearTimeout(silenceTimer);
        const need = silenceDebounceFor(current()?.text||"");
        silenceTimer = setTimeout(()=>{
          if(!(onMyLine() && srToggleOn && srPermGranted)) return;
          const now=performance.now();
          const elapsed=now-(myLineStartMs||now);
          if(!firstEnergyAt || elapsed < minElapsedFor(current()?.text||"")) return;
          const quietLongEnough = !speaking && (now - Math.max(lastResultAt||firstEnergyAt, firstEnergyAt)) >= need;
          const cueOk = transcriptContainsCue(latestTranscript);
          const progressOk = progressRatio(current()?.text||"", latestTranscript) >= MIN_PROGRESS_FOR_SILENCE;
          if(quietLongEnough && (cueOk || progressOk)){ advanceFromMyLine(); }
        }, need);
      }

      if(sr){
        sr.continuous=false; sr.interimResults=true; sr.lang="en-US";
        sr.onstart=()=>{ srActive=true; updateMicBadge(); };
        sr.onend=()=>{ srActive=false; updateMicBadge(); if(srToggleOn && srPermGranted && onMyLine() && !(E.inlineForm&&E.inlineForm.isConnected)){ try{ sr.start(); }catch{} } };
        sr.onerror=()=>{ srActive=false; updateMicBadge(); };
        sr.onresult=(ev)=>{
          if(!(onMyLine() && srToggleOn && srPermGranted)) return;
          maybeSetMyLineStart();
          const now=performance.now(); if(now<advanceCoolUntil) return;
          const ln=current(); if(!ln) return;
          const last=ev.results?.[ev.results.length-1]; const alt=last?.[0]; const isFinal=!!last?.isFinal;
          latestTranscript=(alt?.transcript||"").trim(); lastResultAt=now;
          const elapsed=now-(myLineStartMs||now);
          if(isFinal && elapsed>=minElapsedFor(ln.text)){ return advanceFromMyLine(); }
          armSilenceDebounce();
        };
      }

      setInterval(()=>{
        if(!(sr && srToggleOn && srPermGranted)) return;
        if(!(onMyLine()) || (E.inlineForm&&E.inlineForm.isConnected)) return;
        if(!srActive){ try{ sr.start(); }catch{} }
      }, 300);

      $("#btnMic")?.addEventListener("click", async ()=>{
        const srAvailable = !!sr;
        if(!srAvailable){
          if(!srToggleOn){
            try{ await navigator.mediaDevices.getUserMedia({audio:true}); startMicMonitor(); srPermGranted = true; srToggleOn = true; }
            catch{ srToggleOn = false; }
          }else{ srToggleOn = false; stopMicMonitor(); }
          updateMicBadge(); return;
        }
        if(!srToggleOn){
          const ok=await requestMicPermissionOnce();
          srToggleOn=ok;
          if(ok){ startMicMonitor(); await (onMyLine()?maybeSetMyLineStart():Promise.resolve()); }
        }else{
          srToggleOn=false;
          try{ sr.stop(); }catch{}
          clearMy(); stopMicMonitor();
        }
        updateMicBadge();
      });

      // OpenAI pre-render (status shows actual error text)
      const RR = { map: new Map(), failures: 0, rendering: false, dotsTimer: null, dotsState: [0,0,0] };

      function primeReaderFromCacheIfAvailable(){
        try{
          if(RR.map && RR.map.size){ try{ preloadReaderBuffers(); }catch{}; return true; }
          const cached = ReaderCache.get();
          if(cached && typeof cached.size === "number" && cached.size){
            R.readerBuffers = new Map();
            resetReaderActiveSources();
            R.readerLoading = false;
            RR.map = new Map(cached);
            try{ preloadReaderBuffers(); }catch{}
            return true;
          }
        }catch{}
        return false;
      }

      primeReaderFromCacheIfAvailable();
      function setRehearseRenderStatus(msg, cls){
        const el = $("#rehearseRenderStatus");
        el.innerHTML = "";
        if(!msg){ el.textContent = " "; return; } // keep the bar’s height even when idle
        const span = document.createElement("span");
        if(cls) span.style.color = (cls==="ok"? "var(--ok)" : cls==="err" ? "var(--danger)" : cls==="warn" ? "var(--warn)" : "var(--muted)");
        span.textContent = msg + " ";
        el.appendChild(span);
        if(RR.rendering){
          const dots = document.createElement("span");
          dots.className = "dots";
          dots.innerHTML = `<span class="dot ${RR.dotsState[0]?"on":""}"></span><span class="dot ${RR.dotsState[1]?"on":""}"></span><span class="dot ${RR.dotsState[2]?"on":""}"></span>`;
          el.appendChild(dots);
        }
      }
      function startDots(){ stopDots(); RR.dotsTimer=setInterval(()=>{ if(RR.dotsState.join("")==="000"){ RR.dotsState=[1,0,0]; } else if(RR.dotsState[0]){ RR.dotsState=[0,1,0]; } else if(RR.dotsState[1]){ RR.dotsState=[0,0,1]; } else { RR.dotsState=[0,0,0]; } setRehearseRenderStatus("Preparing voices…",""); }, 320); }
      function stopDots(){ if(RR.dotsTimer){ clearInterval(RR.dotsTimer); RR.dotsTimer=null; RR.dotsState=[0,0,0]; } }

      async function renderRehearseVoices(){
        if(RR.rendering) return;
        const scene = getScene();
        const list  = buildFiltered(scene);
        if(!list.length){ setRehearseRenderStatus("No lines to render.","err"); return; }

  RR.rendering = true; RR.failures = 0; RR.map.clear(); R.readerBuffers = new Map(); resetReaderActiveSources(); R.readerLoading = false; startDots(); setRehearseRenderStatus("Preparing voices…"," ");

        const voiceFor = (name)=> (S.voice_map[name] || S.supportedVoices[0] || "alloy");
        const model    = ($("#selTtsModel")).value || "tts-1";

        const CONCURRENCY = isIOS ? 2 : 3;
        const MAX_ATTEMPTS = 3;
        const TIMEOUT_MS   = 30000;

        let i = 0, done = 0, firstErr = null;
        const run = async () => {
          for(;;){
            const myIndex = i++;
            if (myIndex >= list.length) return;

            const ln = list[myIndex];
            if (ln.speaker === myName()){ done++; setRehearseRenderStatus(`Preparing voices… ${done}/${list.length}`," "); continue; }

            const attempt = async (n) => {
              const ctrl = new AbortController();
              const to   = setTimeout(()=>ctrl.abort(), TIMEOUT_MS);
              try {
                const r = await fetch("/debug/tts_line", {
                  method:"POST", headers:JSON_HDRS,
                  body:JSON.stringify({ voice: voiceFor(ln.speaker), model, text: ln.text }),
                  signal: ctrl.signal
                });
                const txt = await r.text();
                let j={}; try { j = JSON.parse(txt); } catch {}
                if (r.ok && j && j.url) return j.url;

                if ([429,500,502,503,504].includes(r.status)) throw new Error("retryable "+r.status);
                throw new Error("bad "+r.status+" "+txt.slice(0,80));
              } catch (e) {
                if (n < MAX_ATTEMPTS) {
                  const backoff = 400 * Math.pow(2, n) + Math.random()*150;
                  await new Promise(res => setTimeout(res, backoff));
                  return attempt(n+1);
                }
                throw e;
              } finally { clearTimeout(to); }
            };

            try {
              const url = await attempt(0);
              RR.map.set(myIndex, url);
            } catch(e) {
              RR.failures++; if(!firstErr) firstErr = String(e||"error");
            } finally {
              done++; if (done % 2 === 0) setRehearseRenderStatus(`Preparing voices… ${done}/${list.length}`, "");
            }
          }
        };

        await Promise.all(Array.from({length:CONCURRENCY}, run));

        RR.rendering = false; stopDots();
        ReaderCache.set(RR.map);

        const okCount = RR.map.size;
        setRehearseRenderStatus(
          okCount
            ? `Voices ready: ${okCount} lines${RR.failures ? ` (fallback on ${RR.failures})`:""}${firstErr? ` — last error: ${String(firstErr).slice(0,120)}`:""}`
            : `No OpenAI clips prepared${firstErr? ` — error: ${String(firstErr).slice(0,160)}`:""}`,
          okCount ? (RR.failures ? "warn":"ok") : "err"
        );
        try{ preloadReaderBuffers(); }catch{}
      }
  function clearRehearseRender(){ RR.map.clear(); RR.failures=0; stopDots(); R.readerBuffers = new Map(); resetReaderActiveSources(); R.readerLoading=false; setRehearseRenderStatus("Cleared pre-render.","warn"); }
      $("#btnRehearseRender")?.addEventListener("click", renderRehearseVoices);
      $("#btnRehearseClear")?.addEventListener("click", clearRehearseRender);

      async function playOpenAiIfCached(i){
        const buf = R.readerBuffers.get(i);
        if(buf){
          await ensureReaderCtx();
          if(!R.readerCtx || !R.readerGain) return false;
          const ctx = R.readerCtx;
          const lookahead = 0.05;
          const startAt = Math.max((ctx.currentTime||0) + lookahead, 0);
          const src = ctx.createBufferSource();
          src.buffer = buf;
          const g = ctx.createGain();
          const fadeInEnd = startAt + 0.03;
          const fadeOutStart = Math.max(startAt, startAt + buf.duration - 0.02);
          g.gain.setValueAtTime(0.0001, startAt);
          g.gain.linearRampToValueAtTime(1.0, fadeInEnd);
          g.gain.setValueAtTime(1.0, fadeOutStart);
          g.gain.linearRampToValueAtTime(0.0001, startAt + buf.duration);
          src.connect(g);
          g.connect(R.readerGain);
          if(R.readerActiveSources) R.readerActiveSources.add(src);
          const done = new Promise(res=>{ src.onended=()=>res(null); src.onerror=()=>res(null); });
          src.start(startAt);
          try{
            await done;
          } finally {
            try{ R.readerActiveSources?.delete(src); }catch{}
            try{ src.disconnect(); g.disconnect(); }catch{}
          }
          return true;
        }

        const url = RR.map.get(i);
        if(!url) return false;
        try{
          E.rehearseAudio.src = url + (url.includes("?") ? "&" : "?") + "t=" + Date.now();
          await E.rehearseAudio.play();
          await new Promise(res=>{ E.rehearseAudio.onended=()=>res(null); E.rehearseAudio.onerror=()=>res(null); });
          return true;
        }catch{}
        finally{
          E.rehearseAudio.onended = null;
          E.rehearseAudio.onerror = null;
        }
        return false;
      }

      async function step(playMode){
        const list=filtered(); if(!list.length) return;
        const pace=Number(($("#selPace")?.value)||0);
        const ln=current(); if(!ln){ playing=false; $("#btnPlay").textContent="Play"; return; }
        // keep bubble synced even if audio fails
        highlightCurrent();

        if(ln.speaker===myName()){
          if(sr && srToggleOn && srPermGranted){ advanceLock=false; maybeSetMyLineStart(); return; }
          if(playMode){ playing=false; $("#btnPlay").textContent="Play"; }
        }else{
          const i = idx;
          const usedOpenAi = await playOpenAiIfCached(i);
          if(!usedOpenAi){ await synthSpeak(ln.text); }
          if(pace>0) await new Promise(r=>setTimeout(r,pace));
          if(playing){ idx=Math.min(idx+1,list.length-1); step(true); }
        }
      }

      $("#btnPlay")?.addEventListener("click",()=>{ playing=!playing; $("#btnPlay").textContent=playing?"Pause":"Play"; if(playing){ step(true); } else { window.speechSynthesis?.cancel(); try{ sr?.stop(); }catch{}; clearMy(); }});
      $("#btnPrev")?.addEventListener("click",()=>{ const list=filtered(); if(!list.length) return; try{ sr?.stop(); }catch{}; clearMy(); idx=Math.max(0,idx-1); highlightCurrent(); if(playing) step(true); else maybeSetMyLineStart(); });
      $("#btnNext")?.addEventListener("click",()=>{ const list=filtered(); if(!list.length) return; try{ sr?.stop(); }catch{}; clearMy(); idx=Math.min(list.length-1,idx+1); highlightCurrent(); if(playing) step(true); else maybeSetMyLineStart(); });
      $("#btnTop")?.addEventListener("click",()=>{ try{ sr?.stop(); }catch{}; clearMy(); idx=0; highlightCurrent(); if(playing) step(true); else maybeSetMyLineStart(); });

      $("#btnToggleEditMode")?.addEventListener("click",()=>{ S.editMode=!S.editMode; applyEditModeUI(); });
      function applyEditModeUI(){ $("#btnToggleEditMode")?.setAttribute("aria-pressed",S.editMode?"true":"false"); $("#editModeState").textContent=S.editMode?"On":"Off"; $$(".editbar",$("#lines")).forEach(el=>el.style.display=S.editMode?"flex":"none"); $$(".inline-slot",$("#lines")).forEach(el=>el.style.display=S.editMode?"flex":"none"); if(E.inlineForm && E.inlineForm.isConnected){ try{ E.inlineForm.remove(); }catch{}; E.currentSlotPlace=null; } }

      /* ----------------- RECORD TAB (updated for 16x9 + right rail) ----------------- */
      const R = {
        status: $("#statusRec"),
        btnRender: $("#btnRender"),
        btnRec: $("#btnRec"),
        btnCamera: $("#btnCamera"),
        btnCountIn: $("#btnCountIn"),
        btnHeadphones: $("#btnHeadphones"),
        audio: $("#readerAudio"),
        preview: $("#preview"),
        countdown: null,
        chunks: [],
        rec: null,
        stream: null,
        render_id: "",
        download_url: "",
        takes: [],
        cameraOn: false,
        countInOn: true,
        headphonesOn: true,
        recording: false,
        prevSrToggle: null,
        facing: "user",               // or "environment"
        mixCtx: null,
        mixDest: null,
        mixGainReader: null,
        mixGainMic: null,
        micHPF: null,
        micCompressor: null,
        readerCtx: null,
        readerGain: null,
        readerBuffers: new Map(),
        readerLoading: false,
        readerDirectConnected: false,
        readerBridge: null,
        readerBridgeSource: null,
        readerRecordGain: null,
        readerActiveSources: new Set(),
        duckHintShown: false,
      };
      R.audio?.setAttribute("playsinline","");

      function setStatusRec(t){ R.status.textContent = t || " "; } // keep height

      function micConstraints(recordingPhase){
        if(recordingPhase){
          return {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false,
            channelCount: 1,
            sampleRate: 48000,
            sampleSize: 16,
            advanced: [
              { echoCancellation:false },
              { noiseSuppression:false },
              { autoGainControl:false },
              { googEchoCancellation:false },
              { googAutoGainControl:false },
              { googNoiseSuppression:false }
            ]
          };
        }
        return {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: false,
          channelCount: 1
        };
      }

      async function ensureReaderCtx(){
        if(R.readerCtx && R.readerCtx.state === "closed"){ R.readerCtx = null; R.readerGain = null; R.readerDirectConnected = false; }
        if(!R.readerCtx){
          R.readerCtx = new (window.AudioContext||window.webkitAudioContext)();
          if(R.readerCtx?.state === "suspended"){ try{ await R.readerCtx.resume(); }catch{} }
          R.readerGain = R.readerCtx.createGain();
          R.readerGain.gain.value = 1.0;
          try{ R.readerGain.connect(R.readerCtx.destination); R.readerDirectConnected = true; }
          catch{}
          R.readerActiveSources = new Set();
        }else if(R.readerCtx?.state === "suspended"){
          try{ await R.readerCtx.resume(); }catch{}
        }
        return R.readerCtx;
      }

      function restoreReaderDirectMonitor(){
        if(R.readerCtx && R.readerGain){
          try{ R.readerGain.disconnect(); }catch{}
          try{ R.readerGain.connect(R.readerCtx.destination); R.readerDirectConnected = true; }
          catch{}
        }
        R.readerBridge = null;
        R.readerBridgeSource = null;
        R.readerRecordGain = null;
      }

      async function preloadReaderBuffers(){
        if(!RR.map || !RR.map.size || R.readerLoading) return;
        R.readerLoading = true;
        try{
          await ensureReaderCtx();
          const entries = Array.from(RR.map.entries());
          let idx = 0;
          const workers = Math.min(3, entries.length);
          async function worker(){
            for(;;){
              const current = idx++;
              if(current >= entries.length) break;
              const [i, url] = entries[current];
              if(R.readerBuffers.has(i)) continue;
              try{
                const suffix = url.includes("?") ? "&" : "?";
                const resp = await fetch(url + suffix + "t=" + Date.now());
                if(!resp.ok) continue;
                const buf = await resp.arrayBuffer();
                const ctx = R.readerCtx;
                if(!ctx) continue;
                const audio = await new Promise((resolve,reject)=>{
                  try{
                    const maybe = ctx.decodeAudioData(buf, resolve, reject);
                    if(maybe && typeof maybe.then === "function") maybe.then(resolve).catch(reject);
                  }catch(e){ reject(e); }
                });
                if(audio) R.readerBuffers.set(i, audio);
              }catch{}
            }
          }
          await Promise.all(Array.from({length:workers}, ()=>worker()));
        }catch{}
        finally{ R.readerLoading = false; }
      }

      function setRailStates(){
        R.btnCamera.setAttribute("aria-pressed", R.cameraOn ? "true":"false");
        R.btnCamera.textContent = "Camera: " + (R.cameraOn ? "On" : "Off");
        R.btnCountIn.setAttribute("aria-pressed", R.countInOn ? "true":"false");
        R.btnCountIn.textContent = "Count-in: " + (R.countInOn ? "On" : "Off");
        R.btnHeadphones.setAttribute("aria-pressed", R.headphonesOn ? "true":"false");
        R.btnHeadphones.textContent = "Headphones: " + (R.headphonesOn ? "On" : "Off");
        if(R.recording){ R.btnRec.classList.add("recording"); R.btnRec.textContent = "STOP"; }
        else { R.btnRec.classList.remove("recording"); R.btnRec.textContent = "REC"; }
      }

      function pickMime(video){
        const vids = ["video/mp4;codecs=avc1.42E01E,mp4a.40.2","video/mp4","video/webm;codecs=vp8,opus","video/webm"];
        const auds = ["audio/mp4","audio/webm;codecs=opus","audio/webm"];
        const list = video ? vids : auds;
        for(const m of list){ if(window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)) return m; }
        return "";
      }

      function cleanupStream(){
        try{ R.stream?.getTracks().forEach(t=>t.stop()); }catch{}
        R.stream = null;
        if(R.preview) R.preview.srcObject = null;
      }

      function resetMicAfterRecording(){
        if(R.prevSrToggle === null){ updateMicBadge(); return; }
        const prev = R.prevSrToggle;
        R.prevSrToggle = null;
        if(prev){
          srToggleOn = true;
          startMicMonitor();
        }else{
          srToggleOn = false;
          stopMicMonitor();
        }
        updateMicBadge();
      }

      async function buildMixedStreamIfPossible(rawStream){
        if(!rawStream) return rawStream;
        try{
          R.mixCtx = new (window.AudioContext||window.webkitAudioContext)();
          if(R.mixCtx?.state === "suspended"){ try{ await R.mixCtx.resume(); }catch{} }
          const speakers = R.mixCtx.destination;
          R.mixDest = R.mixCtx.createMediaStreamDestination();

          const micNode = R.mixCtx.createMediaStreamSource(rawStream);

          R.micHPF = R.mixCtx.createBiquadFilter();
          R.micHPF.type = "highpass";
          R.micHPF.frequency.value = 120;
          R.micHPF.Q.value = 0.707;

          R.micCompressor = R.mixCtx.createDynamicsCompressor();
          R.micCompressor.threshold.value = -28;
          R.micCompressor.knee.value = 24;
          R.micCompressor.ratio.value = 3;
          R.micCompressor.attack.value = 0.005;
          R.micCompressor.release.value = 0.12;

          R.mixGainMic = R.mixCtx.createGain();
          R.mixGainMic.gain.value = 1.0;

          micNode.connect(R.micHPF);
          R.micHPF.connect(R.micCompressor);
          R.micCompressor.connect(R.mixGainMic);
          R.mixGainMic.connect(R.mixDest);

          R.mixGainReader = R.mixCtx.createGain();
          R.mixGainReader.gain.value = R.headphonesOn ? 1.0 : 0.0;
          const readerRecordGain = R.mixCtx.createGain();
          readerRecordGain.gain.value = 1.0;

          if(R.readerCtx && R.readerGain){
            try{ R.readerGain.disconnect(); R.readerDirectConnected = false; }catch{}
            try{
              R.readerBridge = R.readerCtx.createMediaStreamDestination();
              R.readerGain.connect(R.readerBridge);
              R.readerDirectConnected = false;
              const bridgeSource = R.mixCtx.createMediaStreamSource(R.readerBridge.stream);
              R.readerBridgeSource = bridgeSource;
              bridgeSource.connect(R.mixGainReader);
              bridgeSource.connect(readerRecordGain);
            }catch{}
          }

          const readerEl = (RR.map && RR.map.size>0) ? E?.rehearseAudio : R.audio;
          if(readerEl){
            try{
              const src = R.mixCtx.createMediaElementSource(readerEl);
              src.connect(R.mixGainReader);
              src.connect(readerRecordGain);
            }catch(e){
              if(typeof readerEl.captureStream === "function"){
                try{
                  const rs = readerEl.captureStream();
                  const s2 = R.mixCtx.createMediaStreamSource(rs);
                  s2.connect(R.mixGainReader);
                  s2.connect(readerRecordGain);
                }catch{}
              }
            }
          }

          R.mixGainReader.connect(speakers);
          readerRecordGain.connect(R.mixDest);
          R.readerRecordGain = readerRecordGain;

          const tracks = [];
          if(R.cameraOn){
            try{ rawStream.getVideoTracks().forEach(t=>tracks.push(t)); }catch{}
          }
          try{ R.mixDest.stream.getAudioTracks().forEach(t=>tracks.push(t)); }catch{}
          if(tracks.length) return new MediaStream(tracks);
        }catch(e){
          try{ R.mixCtx?.close(); }catch{}
          restoreReaderDirectMonitor();
        }
        R.mixCtx = null;
        R.mixDest = null;
        R.mixGainReader = null;
        R.mixGainMic = null;
        R.micHPF = null;
        R.micCompressor = null;
        R.readerRecordGain = null;
        R.readerBridge = null;
        R.readerBridgeSource = null;
        return rawStream;
      }

      /* --- Render reader (animated dots in status) --- */
      async function prepareReader(){
        if(!S.script_id){ setStatusRec("Import & Assign first."); return; }
        let dots = 0;
        let dotsTimer = setInterval(()=>{
          dots = (dots+1)%4;
          setStatusRec("Preparing reader track" + ".".repeat(dots));
        }, 320);
        setStatusRec("Preparing reader track."); R.btnRender.disabled = true;
        try{
          const r = await fetch("/debug/render", { method:"POST", headers:JSON_HDRS, body:JSON.stringify({ script_id:S.script_id, my_role:(S.role||"").toUpperCase(), pace_ms:0 }) });
          const j = await safeJson(r);
          if(!r.ok){ clearInterval(dotsTimer); setStatusRec("Render error "+r.status+": "+JSON.stringify(j)); R.btnRender.disabled=false; return; }
          R.render_id = j.render_id;
          const poll = async ()=>{
            const s = await fetch(`/debug/render_status?render_id=${encodeURIComponent(R.render_id)}`, { headers:JSON_HDRS });
            const js = await safeJson(s);
            if(js.status==="complete" && js.download_url){
              R.download_url = js.download_url + "?t=" + Date.now();
              R.audio.src = R.download_url; R.audio.load();
              clearInterval(dotsTimer);
              setStatusRec("Reader ready.");
              R.btnRender.disabled = false;
            }else if(js.status==="error"){
              clearInterval(dotsTimer);
              setStatusRec("Render failed: "+(js.error||"unknown")); R.btnRender.disabled=false;
            }else{ setTimeout(poll, 500); }
          };
          setTimeout(poll, 500);
        }catch(e){
          clearInterval(dotsTimer);
          setStatusRec("Network error: "+e); R.btnRender.disabled=false;
        }
      }

      /* --- Count-in: visible 3-2-1 with slower beeps --- */
      async function doBeepsAndCountdown(){
        if(!R.countInOn) return;
        const overlay = $("#countdown"), num = $("#countNum");
        if(overlay){ overlay.style.display="flex"; }

        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        const beep = (freq, dur=0.28)=> new Promise(res=>{
          const o=ctx.createOscillator(), g=ctx.createGain();
          o.frequency.value=freq; o.type="sine"; g.gain.value=0.18;
          o.connect(g); g.connect(ctx.destination); o.start();
          setTimeout(()=>{ o.stop(); res(); }, dur*1000);
        });

        const step = async (n, freq)=>{ if(num){ num.textContent=String(n); } await beep(freq); await new Promise(r=>setTimeout(r,520)); };

        await step(3, 880);
        await step(2, 880);
        await step(1, 660);

        try{ await ctx.close(); }catch{}
        if(overlay){ overlay.style.display="none"; }
      }

      /* --- Recording flow --- */
      async function startPreviewIfNeeded(forceRestart=false){
        if(!R.cameraOn){
          try{ cleanupStream(); }catch{}
          if(R.preview) R.preview.srcObject=null;
          return;
        }
        try{
          if(forceRestart && R.stream){ cleanupStream(); }
          if(!R.stream){
            R.stream = await navigator.mediaDevices.getUserMedia({
              video: { facingMode: R.facing },
              audio: micConstraints(false)
            });
          }
          const at = R.stream?.getAudioTracks?.()[0];
          if(at){
            const settings = at.getSettings ? at.getSettings() : {};
            console.log("[offbook] mic settings (preview)", settings);
            if(!R.duckHintShown && (settings.echoCancellation === true || settings.noiseSuppression === true)){
              setStatusRec("Note: Your device may still apply echo/ducking. Use wired/Bluetooth headphones for best results.");
              R.duckHintShown = true;
            }
          }
          if(R.preview){
            try{ R.preview.muted = true; }catch{}
            R.preview.srcObject = R.stream;
            if(typeof R.preview.play === "function"){
              R.preview.play().catch(()=>{});
            }
          }
        }catch(e){ setStatusRec("Camera/mic permission denied: "+e); }
      }

      let useBackCamera = false;
      async function applyCameraFacing(){
        R.facing = useBackCamera ? "environment" : "user";
        if(!R.cameraOn) return;
        try{ await startPreviewIfNeeded(true); }
        catch(e){ setStatusRec("Camera switch error: "+e); }
      }

      async function startRecording(){
        primeReaderFromCacheIfAvailable();
        const prepped = (RR.map && RR.map.size > 0) || !!R.download_url;
        if(!prepped){ setStatusRec("Render first."); return; }

        const useCachedReader = !!(RR.map && RR.map.size > 0);

        stopAllAudioHard();
        try{ sr?.stop(); }catch{}
        try{ clearMy(); }catch{}

        cleanupStream();
  try{ R.mixCtx?.close(); }catch{}
  R.mixCtx = null; R.mixDest = null; R.mixGainReader = null; R.mixGainMic = null; R.micHPF = null; R.micCompressor = null;

        let userStream;
        try{
          const needVideo = !!R.cameraOn;
          userStream = await navigator.mediaDevices.getUserMedia({
            audio: micConstraints(true),
            video: needVideo ? { facingMode: R.facing } : false
          });
        }catch(e){ setStatusRec("Permission error: "+e); return; }
        R.stream = userStream;
        const track = R.stream?.getAudioTracks?.()[0];
        if(track){
          const settings = track.getSettings ? track.getSettings() : {};
          console.log("[offbook] mic settings (record)", settings);
          if(!R.duckHintShown && (settings.echoCancellation === true || settings.noiseSuppression === true)){
            setStatusRec("Note: Your device may still apply echo/ducking. Use wired/Bluetooth headphones for best results.");
            R.duckHintShown = true;
          }
        }
        if(R.cameraOn && R.preview){
          R.preview.srcObject = R.stream;
          if(typeof R.preview.play === "function"){ R.preview.play().catch(()=>{}); }
        }

        await doBeepsAndCountdown();

        if(useCachedReader){ try{ await ensureReaderCtx(); }catch{} }
        const finalStream = await buildMixedStreamIfPossible(R.stream);

        R.prevSrToggle = srToggleOn;
        try{
          await requestMicPermissionOnce();
          srToggleOn = true;
          startMicMonitor();
        }catch{}
        updateMicBadge();

        try{ idx = 0; }catch{}
        try{ highlightCurrent?.(); }catch{}
        try{ clearMy(); }catch{}

        R.chunks = [];
        const mime = pickMime(!!R.cameraOn);
        try{ R.rec = mime ? new MediaRecorder(finalStream, { mimeType: mime }) : new MediaRecorder(finalStream); }
        catch{ R.rec = new MediaRecorder(finalStream); }

        R.rec.ondataavailable = (e)=>{ if(e.data && e.data.size>0) R.chunks.push(e.data); };
        R.rec.onstop = ()=>{
          stopAllAudioHard();
          resetMicAfterRecording();
          try{ R.mixCtx?.close(); }catch{}
          R.mixCtx = null; R.mixDest = null; R.mixGainReader = null; R.mixGainMic = null; R.micHPF = null; R.micCompressor = null;
          R.readerRecordGain = null; R.readerBridge = null; R.readerBridgeSource = null;
          restoreReaderDirectMonitor();
          finalizeTake();
          cleanupStream();
          if(R.cameraOn){ try{ startPreviewIfNeeded(); }catch{} }
          R.recording=false;
          setRailStates();
        };

        R.recording = true;
        setRailStates();

        try{ R.rec.start(); }
        catch(e){
          R.recording = false;
          setRailStates();
          setStatusRec("Recorder error: "+e);
          stopAllAudioHard();
          resetMicAfterRecording();
          try{ R.mixCtx?.close(); }catch{}
          R.mixCtx = null; R.mixDest = null; R.mixGainReader = null; R.mixGainMic = null; R.micHPF = null; R.micCompressor = null; R.readerRecordGain = null; R.readerBridge = null; R.readerBridgeSource = null;
          restoreReaderDirectMonitor();
          cleanupStream();
          if(R.cameraOn){ try{ startPreviewIfNeeded(); }catch{} }
          return;
        }

        setStatusRec("Recording…");

        await new Promise(r=>setTimeout(r,220));

        if(useCachedReader){
          try{
            playing = true;
            step(true);
            const endWatch = setInterval(()=>{
              if(!R.recording) return clearInterval(endWatch);
              if(!playing){
                try{ R.rec?.stop(); }catch{}
                clearInterval(endWatch);
              }
            }, 300);
          }catch{}
        }

        if(R.audio){
          if(R.download_url && !useCachedReader){
            try{ R.audio.currentTime = 0; await R.audio.play(); }catch{}
            R.audio.onended = ()=>{ setTimeout(()=>{ try{ R.rec?.stop(); }catch{} }, 120); };
          }else{
            try{ R.audio.pause(); R.audio.currentTime = 0; }catch{}
            R.audio.onended = null;
          }
        }
      }

      function stopRecording(){
        if(!R.recording){
          stopAllAudioHard();
          cleanupStream();
          restoreReaderDirectMonitor();
          return;
        }
        try{ R.rec?.stop(); }catch{}
        R.recording = false;
        setRailStates();
        setStatusRec("Stopping…");
      }

      function finalizeTake(){
        const isVid = !!R.cameraOn;
        const blob = new Blob(R.chunks, { type: (R.rec && R.rec.mimeType) ? R.rec.mimeType : (isVid ? "video/mp4" : "audio/mp4") });
        if (!blob || !blob.size) { setStatusRec("No data captured."); return; }
        const url = URL.createObjectURL(blob);
        const ts = new Date().toISOString().replace(/[:.]/g,"-");
        const ext = (blob.type.startsWith("video/") ? "mp4" : (blob.type.includes("webm") ? "webm" : "m4a"));
        const name = `${isVid?"take-video":"take-audio"}-${ts}.${ext}`;
        R.takes.unshift({ url, name, type: blob.type, size: blob.size });
        setStatusRec("Saved to Gallery.");
      }

      /* --- Button wiring --- */
      R.btnRender?.addEventListener("click", async ()=>{
        // If we already have pre-rendered clips in RR.map from Rehearse, reuse them.
        const hasCached = primeReaderFromCacheIfAvailable() || (RR.map && RR.map.size);
        if(hasCached && RR.map && RR.map.size){
          setStatusRec(`Voices ready: ${RR.map.size} lines (cached).`);
          try{ preloadReaderBuffers(); }catch{}
          return;
        }
        setStatusRec("Preparing voices…");
        try{
          await renderRehearseVoices(); // fills RR.map
          if(RR.map.size){ setStatusRec("Reader ready."); try{ preloadReaderBuffers(); }catch{}; return; }
        }catch(e){ /* fall through to server render */ }
        // Fallback: server-side combined reader track
        await prepareReader();
      });

      R.btnRec?.addEventListener("click", ()=>{
        if(R.recording) { stopRecording(); }
        else { startRecording(); }
      });

      R.btnCamera?.addEventListener("click", async ()=>{
        R.cameraOn = !R.cameraOn;
        setRailStates();
        await startPreviewIfNeeded();
      });

      R.btnCountIn?.addEventListener("click", ()=>{ R.countInOn = !R.countInOn; setRailStates(); });
      R.btnHeadphones?.addEventListener("click", ()=>{
        R.headphonesOn = !R.headphonesOn;
        try{ if(R.mixGainReader) R.mixGainReader.gain.value = R.headphonesOn ? 1.0 : 0.0; }catch{}
        setRailStates();
      });

      $("#btnFlipCam")?.addEventListener("click", async ()=>{
        useBackCamera = !useBackCamera;
        await applyCameraFacing();
      });

      /* Warm permissions when user navigates to Record */
      const _origShowScreen = showScreen;
      showScreen = function(name){
        _origShowScreen(name);
        if(name==="record"){
          try{ requestMicPermissionOnce(); }catch{}
          try{ startPreviewIfNeeded(); }catch{}
          setRailStates();
        }
      };

      window.addEventListener("pagehide", ()=>{
        resetReaderActiveSources();
        try{ R.readerCtx?.close(); }catch{}
        R.readerCtx = null;
        R.readerGain = null;
        R.readerBridge = null;
        R.readerBridgeSource = null;
        R.readerRecordGain = null;
        R.readerDirectConnected = false;
        R.readerBuffers = new Map();
        R.readerLoading = false;
        R.duckHintShown = false;
      });

      // initial safe boot
      try{
        hydrateRehearse(); applyEditModeUI(); (function initAssign(){ $("#pillScript").textContent="script: "+(S.script_id||"—"); })();
      }catch(e){ showErr("UI init error: "+e); }
    };

    // Safe boot: never leave page inert
    try {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", boot, { once:true });
      } else {
        boot();
      }
    } catch (e) {
      const eb = document.getElementById("errbar");
      if (eb) { eb.textContent = "Fatal init error: "+e; eb.classList.add("show"); }
    }
  </script>

  <div class="countdown" id="countdown" aria-hidden="true" style="display:none">
    <div class="count-num" id="countNum">3</div>
  </div>
</body>
</html>
