<!doctype html>

<html lang="en">

<head>

  <meta charset="utf-8" />

  <title>OFFBOOK — Rehearsal MVP</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />

  <!-- PWA / iOS standalone niceties -->

  <link rel="manifest" href="/manifest.webmanifest">

  <meta name="apple-mobile-web-app-capable" content="yes">

  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <link rel="apple-touch-icon" href="/icons/icon-192.png">

  <script>

    (function () {

      const vp = document.querySelector('meta[name=viewport]');

      if (vp) {

        vp.setAttribute('content', 'width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover');

      }



      let lastTouchEnd = 0;

      document.addEventListener('touchend', function (e) {

        const now = Date.now();

        if (now - lastTouchEnd <= 350) e.preventDefault();

        lastTouchEnd = now;

      }, { passive: false });



      document.addEventListener('gesturestart', e => e.preventDefault(), { passive: false });

    })();

  </script>

    <style>

    /* Safe-area headroom (iOS Dynamic Island / status bars) */

    :root {

      --safe-top: env(safe-area-inset-top, 0px);

      --bg:#05070d;

      --panel:rgba(18,21,30,0.78);

      --panel-2:rgba(12,14,22,0.85);

      --text:#f2f4ff;

      --muted:#9aa3bc;

      --border:rgba(118,130,164,0.2);

      --focus:#9ab2ff;

      --accent:#8da2ff;

      --danger:#ef4444;

      --ok:#16a34a;

      --warn:#f4c542;

      --maxw:760px;

      --rail-w: clamp(160px, 22vw, 220px);

      --btn-h: 44px;

      --btn-fs: 14px;

      --btn-pad-v: 10px;

      --btn-pad-h: 12px;

  --preview-ar: 16/9;

  --tabsH: 86px;

  --railW: 200px;

    }

    /* Orientation utility classes */

    @media (orientation: portrait){ .landscape-only{ display:none !important; } }

    @media (orientation: landscape){ .portrait-only{ display:none !important; } }

    @media (max-width: 600px){

      :root{ --tabsH: 102px; }

    }

    *{ box-sizing:border-box }

    html,body{

      overscroll-behavior:none;

      touch-action:manipulation;

      margin:0;

      padding:0;

      min-height:100%;

      background:

        radial-gradient(circle at 20% 18%, rgba(74,97,162,0.32), transparent 58%),

        radial-gradient(circle at 78% 4%, rgba(156,104,255,0.22), transparent 52%),

        radial-gradient(circle at 48% 120%, rgba(76,83,112,0.35), transparent 55%),

        #05060a;

      color:var(--text);

      font-family:"SF Pro Display","SF Pro Text",-apple-system,system-ui,"Segoe UI",Roboto,Arial,sans-serif;

      -webkit-font-smoothing:antialiased;

    }

    /* Give the whole app a small buffer at the very top */

    body{

      position:relative;

      padding-top:0;

    }

    body::before{

      content:"";

      position:fixed;

      inset:0;

      pointer-events:none;

      background:linear-gradient(150deg, rgba(255,255,255,0.05), rgba(0,0,0,0.68) 65%);

      mix-blend-mode:screen;

      opacity:0.7;

      z-index:0;

    }

    /* If a header is still present anywhere, respect safe-area */

    header{

      padding:calc(28px + var(--safe-top)) 20px 18px;

      position:relative;

      z-index:1;

    }

    header .brand{

      max-width:var(--maxw);

      margin:0 auto;

      display:flex;

      align-items:center;

      gap:16px;

      position:relative;

    }

    .brand-copy{

      display:flex;

      flex-direction:column;

      gap:4px;

    }

    .brand-title{

      font-size:18px;

      font-weight:700;

      letter-spacing:.4px;

    }

    .brand-subtitle{

      position:absolute;

      right:0;

      top:2px;

      font-size:13px;

      color:var(--muted);

      letter-spacing:2.4px;

      text-transform:uppercase;

      white-space:nowrap;

    }

    main{

      /* existing padding stays; add safe-top on top */

      padding:calc(8px + var(--safe-top)) 20px 120px;

      max-width:var(--maxw);

      margin:0 auto;

      position:relative;

      z-index:1;

    }

    main::before{

      content:"";

      position:absolute;

      inset:0;

      border-radius:36px;

      background:linear-gradient(140deg, rgba(255,255,255,0.05), rgba(12,14,21,0.82));

      box-shadow:0 50px 120px rgba(3,5,12,0.6);

      z-index:-1;

      pointer-events:none;

    }

  .hidden{ display:none; }

  #routeWarn,#routeWarnRecord{ display:none !important; }

  html { -webkit-text-size-adjust: 100%; }

  button,[role="button"]{ touch-action:manipulation; }

  /* First card breathing room (covers all tabs) */

  main > *:first-child{ margin-top:0; }

    .card{

      background:var(--panel);

      border:1px solid var(--border);

      border-radius:24px;

      padding:20px;

      box-shadow:0 25px 60px rgba(3,6,15,0.45);

      backdrop-filter:blur(24px);

      -webkit-backdrop-filter:blur(24px);

    }

    h3,h4{

      margin:4px 0 14px;

      font-size:20px;

      font-weight:700;

      letter-spacing:.3px;

    }

    .hint{

      color:var(--muted);

      font-size:13px;

      line-height:1.5;

      letter-spacing:.2px;

    }

    label{

      display:block;

      font-size:12px;

      color:var(--muted);

      margin:10px 0 6px;

      letter-spacing:.4px;

      text-transform:uppercase;

    }

    input[type="text"],textarea,select{

      width:100%;

      border:1px solid rgba(147,160,195,0.28);

      background:rgba(9,11,20,0.75);

      color:var(--text);

      border-radius:16px;

      padding:12px 14px;

      font-size:15px;

      transition:border-color .2s ease, box-shadow .2s ease, background .2s ease;

    }

    input[type="text"]:focus,textarea:focus,select:focus{

      outline:none;

      border-color:var(--focus);

      box-shadow:0 0 0 4px rgba(130,158,255,0.18);

      background:rgba(12,14,24,0.92);

    }

    textarea{ min-height:130px; line-height:1.4; resize:vertical }

    select{ appearance:none }

    .assign-voice-select {

      min-width: 90px;

      max-width: 140px;

      padding-inline: 8px;

      border-radius: 16px;

    }

    .btn{

      display:inline-flex;

      align-items:center;

      justify-content:center;

      background:linear-gradient(135deg, rgba(147,167,255,0.96), rgba(218,223,255,0.96));

      color:#05070d;

      border:none;

      padding:12px 18px;

      border-radius:16px;

      font-weight:700;

      font-size:15px;

      min-height:46px;

      cursor:pointer;

      letter-spacing:.3px;

      box-shadow:0 18px 36px rgba(85,115,255,0.35);

      transition:transform .2s ease, box-shadow .2s ease;

    }

    .btn.loading {

      opacity: 0.6;

      pointer-events: none;

    }

    .btn:hover{ transform:translateY(-1px); box-shadow:0 20px 40px rgba(85,115,255,0.4) }

    .btn:active{ transform:translateY(0); box-shadow:0 12px 26px rgba(85,115,255,0.28) }

    .btn.secondary{

      background:rgba(15,19,30,0.6);

      color:var(--text);

      border:1px solid rgba(150,164,200,0.3);

      box-shadow:none;

    }

    .btn.secondary:hover{ border-color:rgba(154,178,255,0.5) }

    .btn.ghost{

      background:rgba(10,12,20,0.45);

      color:var(--muted);

      border:1px dashed rgba(150,164,200,0.3);

      box-shadow:none;

    }

    .btn.danger{

      background:linear-gradient(135deg, rgba(239,68,68,0.95), rgba(200,48,48,0.95));

      color:#fff;

      box-shadow:0 18px 36px rgba(239,68,68,0.35);

    }

    .btn.danger:hover{ box-shadow:0 20px 40px rgba(239,68,68,0.4) }

    .btn.danger:active{ box-shadow:0 12px 26px rgba(239,68,68,0.28) }

    .btn.sm{ padding:8px 12px; font-size:12px; border-radius:12px; min-height:34px }

    .row{ display:flex; gap:10px } .row>*{ flex:1 }

    .linkRow{ display:flex; align-items:center; }

    .ml-auto{ margin-left:auto; }

    .spacer6{ height:6px } .spacer8{ height:8px } .spacer12{ height:12px } .spacer16{ height:16px }

    .tabbar{

      position:fixed;

      bottom:0;

      left:0;

      right:0;

      background:rgba(10,12,20,0.88);

      border-top:1px solid rgba(120,132,168,0.2);

      padding:8px 12px 16px;

      z-index:40;

      backdrop-filter:blur(22px);

      -webkit-backdrop-filter:blur(22px);

      box-shadow:0 -12px 24px rgba(0,0,0,0.4);

    }

    .tabbar-inner{

      max-width:var(--maxw);

      margin:0 auto;

      display:grid;

      grid-template-columns:repeat(6,1fr);

      gap:8px;

    }

    .tabbar button{

      appearance:none;

      border:none;

      background:transparent;

      color:var(--muted);

      padding:12px 4px;

      font-size:12px;

      font-weight:600;

      letter-spacing:.3px;

      border-radius:14px;

      transition:color .2s ease, background .2s ease;

    }

    .tabbar button.active{

      color:var(--text);

      background:linear-gradient(135deg, rgba(147,167,255,0.18), rgba(229,233,255,0.05));

    }

    .screen{ display:none; pointer-events:auto } .screen.active{ display:block }

    .inner-tabs{ display:flex; gap:10px }

    .inner-tabs button{

      flex:1;

      border:1px solid rgba(147,160,195,0.3);

      background:rgba(9,12,20,0.6);

      color:var(--text);

      padding:11px;

      border-radius:14px;

      font-weight:700;

      letter-spacing:.3px;

      transition:border-color .2s ease, background .2s ease;

    }

    .inner-tabs button.active{

      background:rgba(17,21,34,0.85);

      border-color:var(--focus);

      box-shadow:0 10px 24px rgba(85,115,255,0.25);

    }

    .import-saved-scripts {

      padding: 8px 12px;

    }

    .saved-scripts-header {

      display: flex;

      justify-content: space-between;

      align-items: center;

      margin-bottom: 6px;

    }

    .saved-scripts-title {

      font-weight: 600;

      font-size: 14px;

    }

    .saved-scripts-status {

      font-size: 11px;

      opacity: 0.7;

    }

    .saved-scripts-strip {

      display: flex;

      overflow-x: auto;

      gap: 8px;

      padding-bottom: 4px;

    }

    .saved-script-card {

      flex: 0 0 auto;

      min-width: 120px;

      max-width: 160px;

      padding: 8px;

      border-radius: 10px;

      border: 1px solid rgba(255,255,255,0.12);

      background-color: rgba(0,0,0,0.3);

      font-size: 12px;

    }

    .saved-script-card,

    .saved-script-card:active,

    .saved-script-card:focus {

      -webkit-tap-highlight-color: transparent;

      outline: none;

    }

    .saved-script-card .script-title {

      font-weight: 600;

      margin-bottom: 2px;

    }

    .saved-script-card .script-meta {

      font-size: 11px;

      opacity: 0.8;

    }

    .saved-script-card.saved-script-new {

      border-style: dashed;

      display: flex;

      align-items: center;

      justify-content: center;

      text-align: center;

    }

    .saved-script-confirm-overlay {

      position: fixed;

      inset: 0;

      background: rgba(0, 0, 0, 0.5);

      display: flex;

      align-items: center;

      justify-content: center;

      z-index: 9999;

    }

    .saved-script-confirm-dialog {

      background: #101018;

      border-radius: 16px;

      padding: 16px 20px;

      max-width: 260px;

      width: calc(100% - 40px);

      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5);

    }

    .saved-script-confirm-title {

      font-weight: 600;

      margin-bottom: 4px;

    }

    .saved-script-confirm-text {

      font-size: 0.85rem;

      opacity: 0.9;

      margin-bottom: 12px;

    }

    .saved-script-confirm-buttons {

      display: flex;

      justify-content: flex-end;

      gap: 8px;

    }

    /* Prevent long-press text selection in the delete modal */

    .saved-script-confirm-dialog,

    .saved-script-confirm-dialog * {

      -webkit-user-select: none;

      user-select: none;

    }

    /* Avoid text-selection handles on long-press of saved script cards */

    .saved-script-card,

    .saved-script-card * {

      -webkit-user-select: none;

      user-select: none;

    }

    .import-editor {

      padding: 8px 12px 16px;

      border-top: 1px solid rgba(255,255,255,0.12);

      margin-top: 4px;

    }

    .import-editor-header {

      display: flex;

      justify-content: space-between;

      align-items: baseline;

      margin-bottom: 6px;

    }

    .import-editor-title {

      font-weight: 600;

      font-size: 14px;

    }

    .import-editor-meta {

      font-size: 11px;

      opacity: 0.8;

    }

    .import-scene-selector {

      display: flex;

      flex-wrap: nowrap;

      overflow-x: auto;

      gap: 6px;

      margin-bottom: 8px;

    }

    .import-scene-chip {

      flex: 0 0 auto;

      padding: 4px 8px;

      border-radius: 999px;

      border: 1px solid rgba(255,255,255,0.18);

      font-size: 11px;

      opacity: 0.9;

      background: transparent;

      color: inherit;

    }

    .import-scene-chip.active {

      background-color: rgba(255,255,255,0.12);

      border-color: rgba(255,255,255,0.4);

    }

    .import-lines-list {

      display: flex;

      flex-direction: column;

      gap: 4px;

      max-height: 260px;

      overflow-y: auto;

      padding-right: 2px;

    }

    .import-line-textarea {

      flex: 1 1 0;

      border-radius: 12px;

      border: 1px solid rgba(255,255,255,0.16);

      background-color: rgba(0,0,0,0.2);

      color: inherit;

      font: inherit;

      padding: 6px 8px;

      resize: none;

      overflow: hidden;

      min-height: 2.4rem;

      max-height: none;

      line-height: 1.5;

      height: auto;

      box-sizing: border-box;

    }

    /* MVP: hide bottom "Add line" control in Import editor */

    .import-editor-add-row,

    .import-line-add {

      display: none !important;

    }

    .import-editor-footer {

      margin-top: 10px;

    }

    .import-editor-hint {

      margin-bottom: 8px;

      max-width: 100%;

      font-size: 11px;

      opacity: 0.7;

    }

    .import-editor-actions {

      display: flex;

      gap: 8px;

    }

    .import-editor-actions .btn {

      flex: 1 1 0;

    }

    .import-editor-empty {

      font-size: 12px;

      opacity: 0.7;

    }

    pre.status{

      white-space:pre-wrap;

      word-break:break-word;

      background:rgba(7,9,16,0.75);

      border:1px dashed rgba(147,160,195,0.35);

      border-radius:16px;

      padding:10px 12px;

      color:#b5c0d8;

      min-height:24px;

    }

    .pill{

      display:inline-block;

      padding:6px 12px;

      border-radius:999px;

      border:1px solid rgba(147,160,195,0.32);

      background:rgba(12,15,24,0.75);

      font-size:12px;

      margin-right:6px;

      letter-spacing:.3px;

    }

    .small{ font-size:12px; color:var(--muted); letter-spacing:.2px }

    /* Settings action row: tidy 2×2 grid on small screens */

    #screen-settings #authActionsRow {

      display: grid;

      grid-template-columns: 1fr 1fr;

      gap: 10px;

    }

    @media (min-width: 560px) {

      #screen-settings #authActionsRow {

        grid-template-columns: repeat(4, 1fr);

      }

    }



    #screen-settings .settings-row{

      display:flex;

      align-items:center;

      justify-content:space-between;

      gap:10px;

      padding:6px 0;

    }

    #screen-settings .settings-label{

      font-size:13px;

      color:var(--muted);

      letter-spacing:.2px;

    }

    #screen-settings .settings-value{

      font-size:14px;

      font-weight:700;

      text-align:right;

      word-break:break-word;

    }

    

    /* Rehearse render status - keep visible and readable */

    #rehearseRenderStatus{

      display:block;

      margin-top:6px;

      padding:8px 10px;

      background:rgba(9,12,20,0.65);

      border:1px dashed rgba(147,160,195,0.35);

      border-radius:12px;

      line-height:1.35;

      min-height:22px;              /* keeps the bar from collapsing */

    }

    #rehearseRenderStatus .dots{ margin-left:6px }

    /* Rehearse */

    .line{

      padding:12px 14px;

      border-radius:18px;

      border:1px solid rgba(120,134,170,0.25);

      margin-bottom:10px;

      background:rgba(9,12,20,0.68);

      position:relative;

      box-shadow:0 16px 36px rgba(3,6,15,0.35);

    }

    .line.me{ border-color:rgba(144,167,255,0.55); background:rgba(17,20,32,0.9); box-shadow:0 22px 40px rgba(90,118,255,0.35) }

    .line .who{ font-weight:700; margin-bottom:6px; letter-spacing:.25px }

    .line .text{ line-height:1.5; color:var(--text) }

    .controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }

    .playing{ outline:2px solid var(--focus); outline-offset:2px }

    .badge{

      font-size:11px;

      padding:5px 10px;

      border-radius:999px;

      border:1px solid rgba(147,160,195,0.32);

      background:rgba(10,12,20,0.7);

      color:#b5c0d8;

      letter-spacing:.2px;

    }

    .badge.ok{ color:#4ade80 }

    .badge.warn{ color:#f4c542 }

    .badge.err{ color:#ff7b7b }

    .editbar{ position:absolute; top:10px; right:10px; display:flex; gap:8px }

    .chip{

      font-size:11px;

      padding:5px 10px;

      border-radius:999px;

      border:1px solid rgba(147,160,195,0.32);

      background:rgba(12,15,24,0.7);

      color:#b5c0d8;

      cursor:pointer;

      user-select:none;

      letter-spacing:.2px;

    }

    .chip.danger{ border-color:#e96; color:#ff7b7b }

    .text[contenteditable="true"]{ outline:1px dashed var(--focus); border-radius:10px; padding:6px; background:rgba(7,10,18,0.6) }

    .inline-slot{ display:none; align-items:center; justify-content:center; margin:12px 0 14px }

    .inline-slot .ghostline{ width:100%; border:1px dashed rgba(147,160,195,0.3); border-radius:16px; padding:12px }

    .inline-form{ width:100%; background:rgba(9,12,20,0.72); border:1px solid rgba(147,160,195,0.3); border-radius:18px; padding:14px; margin-top:10px }



    /* Sticky toolbar */

    .toolbar{

      position:sticky;

      top:calc(var(--safe-top) + 2px); /* stop just below iOS status/Dynamic Island */

      z-index:40;

      margin:0 -20px 16px;

      padding:16px env(safe-area-inset-right) 16px env(safe-area-inset-left);

      background:linear-gradient(180deg, rgba(10,12,20,0.92) 0%, rgba(9,11,18,0.88) 100%);

      border-bottom:1px solid rgba(118,130,164,0.2);

      border-top-left-radius:24px;

      border-top-right-radius:24px;

      backdrop-filter:blur(18px);

      -webkit-backdrop-filter:blur(18px);

      box-shadow:0 25px 60px rgba(3,6,15,0.45);

    }

    .toolbar .controls{ justify-content:space-between }

    .toolbar .left, .toolbar .right{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }

    .btn.icon{ min-width:auto; padding:12px }

    .btn.icon::before{ content:"⟲"; font-weight:900; font-size:20px; line-height:1; display:block; }



    /* Record */

    .countdown{

      position:fixed;

      inset:0;

      display:none;

      align-items:center;

      justify-content:center;

      background:rgba(5,7,12,0.78);

      backdrop-filter:blur(10px);

      z-index:1000;

    }

    .countdown.show{ display:flex }

    .count-num{

      font-size:68px;

      font-weight:800;

      background:linear-gradient(135deg, rgba(20,22,32,0.95), rgba(7,8,14,0.95));

      color:#fff;

      padding:26px 42px;

      border-radius:22px;

      border:1px solid rgba(147,160,195,0.3);

      box-shadow:0 28px 70px rgba(0,0,0,0.55);

    }

    .gallery-item{

      border:1px solid rgba(147,160,195,0.28);

      border-radius:18px;

      padding:12px;

      margin-bottom:10px;

      background:rgba(9,12,20,0.7);

      box-shadow:0 18px 40px rgba(3,6,15,0.35);

    }



    /* === Record: narrow rail alongside preview === */

    .record-grid{

      display:grid;

      grid-template-columns: minmax(0,1fr) var(--rail-w);

      grid-template-rows: 1fr;

      grid-template-areas:"preview rail";

      gap:14px;

      align-items:start;

      padding:calc(16px + env(safe-area-inset-top,0px)) calc(16px + env(safe-area-inset-right,0px)) calc(24px + env(safe-area-inset-bottom,0px)) calc(16px + env(safe-area-inset-left,0px));

    }



    .preview-wrap{

      grid-area:preview;

      width:100%;

      background:rgba(9,12,20,0.45);

      border:1px solid var(--border);

      border-radius:18px;

      padding:8px;

      box-shadow:0 25px 55px rgba(3,6,15,0.45);

      position:relative;

    }



    #preview{

      width:100%;

      object-fit:cover;

      border-radius:16px;

      border:1px solid rgba(118,130,164,0.25);

      background:#000;

      display:block;

      aspect-ratio:var(--preview-ar, 16/9);

      transition:aspect-ratio .25s ease;

    }



    .control-rail{

      grid-area:rail;

      display:grid;

      gap:12px;

      align-content:start;

      justify-items:stretch;

      grid-auto-rows:minmax(var(--btn-h), auto);

      grid-auto-flow:row;

    }



    .control-rail .btn{

      width:100%;

      min-height:var(--btn-h);

      font-size:var(--btn-fs);

      padding:var(--btn-pad-v) var(--btn-pad-h);

      border-radius:18px;

      box-shadow:0 12px 24px rgba(0,0,0,0.28);

    }



    /* Button-as-progress */

    .btn-render.progressing{

      position:relative;

      color:#fff;

    }

    .btn-render.progressing::after{

      content:"";

      position:absolute;

      inset:0;

      background:linear-gradient(90deg, rgba(255,255,255,0.15), rgba(255,255,255,0.35));

      transform:translateX(-100%);

      animation:renderSweep 1.2s linear infinite;

      border-radius:inherit;

    }

    @keyframes renderSweep{ to{ transform:translateX(100%); } }



    body.record-active{

      height:100vh;

      overflow:hidden;

    }

    body.record-active main{

      height:100%;

      overflow:hidden;

    }

    body.record-active #screen-record .record-grid{

      height:100%;

      overflow:hidden;

    }

    @media (max-width: 860px){

      .record-grid{

        grid-template-columns: 1fr;

        grid-template-rows: auto auto;

        grid-template-areas:

          "preview"

          "rail";

        gap:12px;

      }

      .control-rail{

        grid-template-columns: repeat(2,1fr);

        grid-auto-rows: var(--btn-h);

        align-items:start;

      }

      #btnRender, #btnRec{ grid-column: 1 / -1; }

      #btnHeadphones{ grid-column: auto; }

    }



    /* Portrait Record: cap preview so controls always fit without scrolling */

    body.record-active.is-portrait #screen-record .record-grid{

      grid-template-areas:

        "preview"

        "rail";

      gap:8px;

      height:calc(100dvh - env(safe-area-inset-bottom,0px));

    }

    body.record-active.is-portrait #screen-record #preview{

      width:100%;

      height:100%;

      aspect-ratio:9/16;

      object-fit:cover;

    }



    /* ===== Record (portrait): remove stacked headroom and hug status bar ===== */

    @media (orientation: portrait){

      .record-card{ overflow:hidden; }

      /* kill the global main top padding + first-child margin while recording */

      body.record-active main{

        padding-top:calc(env(safe-area-inset-top,0px) + 2px) !important;

        padding-bottom:calc(env(safe-area-inset-bottom,0px) + var(--tabsH) + 8px) !important;

      }

      body.record-active main > *:first-child{ margin-top:0 !important; }



      /* shrink the record card’s own top padding (was adding more headroom) */

      body.record-active #screen-record .card.record-grid{

        padding-top:calc(env(safe-area-inset-top,0px) + 2px) !important;

        gap:8px;

      }



      /* trim interior padding above the preview so the video can move up */

      body.record-active #screen-record .preview-wrap{

        padding-top:4px !important;

        /* tabs height + two control rows ≈ 150px total */

        max-height:calc(100dvh - var(--tabsH) - 150px) !important;

        margin-top:0 !important;

      }



      /* ensure preview area expands to fill remaining height exactly */

      body.record-active #screen-record .record-grid{

        height:calc(100dvh - env(safe-area-inset-bottom,0px) - var(--tabsH)) !important;

        grid-template-rows:1fr auto !important;

      }

      /* compact buttons remain */

      body.record-active.is-portrait{ --btn-h:40px; --btn-fs:13px; }

      #screen-record .control-rail{

        display:grid;

        grid-template-columns:1fr 1fr;

        grid-template-areas:

          "camera headphones"

          "rec     rec";

        grid-auto-rows:var(--btn-h);

        gap:10px;

        padding-bottom:0;

        margin-top:-6px;

      }

      .record-card .controls-stack{ gap:8px; }

      body.record-active #screen-record .pos-camera{ grid-area:camera; }

      body.record-active #screen-record .pos-headphones{ grid-area:headphones; }

      body.record-active #screen-record .pos-rec{

        grid-area:rec;

        width:100%;

      }

      body.record-active #screen-record #btnRec{ grid-column:1 / -1; }

      body.record-active #screen-record #btnRender,

      body.record-active #screen-record #btnHeadphones{

        grid-column:auto !important;

      }

    }



    /* —— Force REC full-width in portrait ———————————————————————— */

    @media (orientation: portrait){

      body.record-active #screen-record .control-rail{

        display:grid !important;

        grid-template-columns:1fr 1fr !important;

        grid-auto-rows:var(--btn-h);

        gap:10px;

      }

      /* camera | headphones on row 1, REC across row 2 */

      body.record-active #screen-record #btnRec{

        grid-column:1 / -1 !important;

        width:100% !important;

      }

    }



  #screen-record{ max-height:100dvh; overflow:hidden; }



    @media (orientation: landscape) and (max-width: 1024px){

      body.record-active main{

        max-width:none;

        margin:0;

        padding:calc(12px + env(safe-area-inset-top,0px)) calc(12px + env(safe-area-inset-right,0px)) calc(96px + env(safe-area-inset-bottom,0px)) calc(12px + env(safe-area-inset-left,0px));

      }

      body.record-active main::before{ display:none; }

      body.record-active #screen-record .record-grid{

        grid-template-columns:minmax(0, calc(100% - var(--railW) - 12px)) var(--railW);

        grid-template-areas:"preview rail";

        grid-template-rows:1fr;

        gap:12px;

        align-items:start;

      }

      body.record-active #screen-record .preview-wrap{

        padding:8px;

        border-radius:18px;

      }

      body.record-active #screen-record #preview{

        border-radius:14px;

      }

      body.record-active #screen-record .control-rail{

        /* iOS Safari: use relative positioning to avoid clipping */

        position:relative;

        top:auto;

        align-self:start;

        gap:8px;

        min-height:0;

        max-height:100%;

        overflow-y:auto;

        -webkit-overflow-scrolling:touch;

      }

      body.record-active #screen-record .control-rail .btn{

        font-size:11px;

        min-height:30px;

        padding:6px 8px;

        border-radius:10px;

        line-height:1.1;

      }

      body.record-active .tabbar{

        padding:6px 8px calc(env(safe-area-inset-bottom,0px) + 8px);

      }

    }



    @media (orientation: landscape) and (max-width: 1024px){

      body.record-active #screen-record .record-grid{

        grid-template-areas:"preview rail";

        grid-template-rows:1fr;

        align-items:start;

      }

      body.record-active #screen-record .control-rail{

        height:100%;

        align-content:start;

        gap:12px;

        padding-bottom:12px;

      }

    }



    /* Landscape Record: fill the viewport, minimize gutters */

    @media (orientation: landscape) and (max-width: 1024px){

      body.record-active #screen-record .card.record-grid{

        padding:8px;

        border-radius:16px;

      }

      body.record-active #screen-record .record-grid{

        grid-template-areas:"preview rail";

        grid-template-rows:1fr;

        gap:8px;

        height:calc(100dvh - (env(safe-area-inset-bottom, 0px) + var(--tabbarH, 96px)));

        min-height:0;

      }

      body.record-active #screen-record .preview-wrap{

        padding:6px;

        border-radius:14px;

        min-height:0;

      }

      body.record-active #screen-record #preview{

        height:100%;

        width:100%;

        aspect-ratio:var(--preview-ar, 16/9);

        object-fit:cover;

        object-position:50% 50%;

      }

      body.record-active #screen-record .control-rail{

        height:100%;

        align-content:start;

        gap:12px;

        padding-bottom:12px;

      }

    }



    @media (orientation: landscape){

      body.record-active main{

        /* lift content slightly to free space near the tabbar */

        padding-bottom:calc(env(safe-area-inset-bottom,0px) + 92px);

        padding-top:calc(env(safe-area-inset-top,0px) + 2px);

      }

      #screen-record .record-grid{ gap:10px; min-height:0; }

      body.record-active #screen-record .record-grid{

        align-items:start;

        min-height:0;

      }

      body.record-active #screen-record .control-rail{

        display:grid;

        grid-template-columns:1fr;

        grid-auto-rows:var(--btn-h, 64px);

        gap:14px;

        align-content:start;

        padding-block:0;

        padding-top:0;

        padding-bottom:0;

        height:100%;

        margin:0;

        align-self:stretch;

        position:relative;

        top:auto;

        min-height:0;

        max-height:100%;

        overflow-y:auto;

        -webkit-overflow-scrolling:touch;

      }

      body.record-active #screen-record .control-rail .btn{

        margin:0;

      }

      /* Full-width buttons */

      body.record-active #screen-record .control-rail .note,

      body.record-active #screen-record #btnRender,

      body.record-active #screen-record #btnRec{

        grid-column:1 / -1;

      }

      /* Single-column toggles (original layout) */

      body.record-active #screen-record #btnGrid,

      body.record-active #screen-record #btnCamera,

      body.record-active #screen-record #btnCountIn,

      body.record-active #screen-record #btnHeadphones{

        grid-column:1 / -1;

      }

    }

    /* ============================================================
       iOS Safari (26+) landscape Record rail fix:
       - Forces a stable single-column layout so buttons don't disappear
       - Keeps existing layout by only overriding in iOS + landscape
       ============================================================ */
    @supports (-webkit-touch-callout: none) {
      @media (orientation: landscape) and (max-width: 1024px) {
        body.record-active #screen-record .control-rail {
          display: grid !important;
          grid-template-columns: 1fr !important;
          grid-template-areas:
            "note"
            "render"
            "rec"
            "grid"
            "camera"
            "countin"
            "headphones";
          gap: 14px;
          align-content: start;
          min-height: 0;
          overflow-y: auto;
        }

        /* Optional note banner (if present) */
        body.record-active #screen-record #recordNote,
        body.record-active #screen-record .record-note {
          grid-area: note;
        }

        /* Button placement (using both IDs and classes for compatibility) */
        body.record-active #screen-record #btnRender,
        body.record-active #screen-record .control-rail .pos-render { grid-area: render; }
        body.record-active #screen-record #btnRec,
        body.record-active #screen-record .control-rail .pos-rec { grid-area: rec; }
        body.record-active #screen-record #btnGrid,
        body.record-active #screen-record .control-rail .pos-grid { grid-area: grid; }
        body.record-active #screen-record #btnCamera,
        body.record-active #screen-record .control-rail .pos-camera { grid-area: camera; }
        body.record-active #screen-record #btnCountIn,
        body.record-active #screen-record .control-rail .pos-countin { grid-area: countin; }
        body.record-active #screen-record #btnHeadphones,
        body.record-active #screen-record .control-rail .pos-headphones { grid-area: headphones; }

        /* Override safety: ensure buttons stack vertically in single column */
        body.record-active #screen-record #btnGrid,
        body.record-active #screen-record #btnCamera,
        body.record-active #screen-record #btnCountIn,
        body.record-active #screen-record #btnHeadphones {
          grid-column: 1 / -1 !important;
        }

        /* Preview fills wide 16:9 in landscape (no letterboxing) */
        body.record-active #screen-record #preview {
          object-fit: cover !important;
          object-position: center center;
          aspect-ratio: 16/9 !important;
        }
      }
    }

    /* REC visual states */

    .btn.rec{

      background:radial-gradient(120px 120px at 50% 30%, rgba(255,88,88,0.4), rgba(255,0,0,0.15)), linear-gradient(135deg, #ff6666, #ff2d2d);

      color:#fff; box-shadow:0 18px 36px rgba(255,80,80,0.35);

    }

    .btn.rec.recording{

      background:linear-gradient(135deg, #191b28, #121522);

      color:#ff6969; border:1px solid rgba(255,120,120,0.4);

    }



    /* Flip camera translucent overlay */

    .flipcam{

      position:absolute;

      right:12px;

      bottom:12px;

      z-index:5;

      transform:translateZ(0);

      width:var(--btn-h);

      height:var(--btn-h);

      border-radius:999px;

      border:1px solid rgba(147,160,195,0.35);

      background:rgba(12,15,24,0.55);

      color:#cfd7ff;

      font-weight:700;

      box-shadow:0 10px 24px rgba(3,6,15,0.35);

      backdrop-filter:blur(8px);

      cursor:pointer;

    }

    .flipcam:active{ transform:scale(0.98) }



    /* Keep flip camera button pinned inside the preview bottom-right */

    #screen-record .preview-wrap{ position:relative; }

    #btnFlipCam{ position:absolute; right:12px; bottom:12px; z-index:5; }



    

    /* Gallery */

  .take-card{ position:relative; border:1px solid rgba(147,160,195,0.28); border-radius:18px; padding:12px; margin-bottom:12px; background:rgba(9,12,20,0.7); }

  .take-thumb{ width:100%; border-radius:14px; display:block; background:#000; object-fit:cover; }

    .take-row{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-top:8px; }

    .take-meta{ font-size:12px; color:var(--muted); }

    .take-note{ width:100%; margin-top:8px; font-size:13px; border-radius:12px; padding:10px 12px; background:rgba(10,12,20,0.5); border:1px solid rgba(147,160,195,0.3); color:var(--text); }

    .take-actions{ display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:8px; align-items:center; }
    .take-actions .btn{ width:100%; }

    .chip-filter{ display:inline-block; padding:6px 10px; border-radius:999px; border:1px solid rgba(147,160,195,0.32); background:rgba(12,15,24,0.7); margin-right:6px; cursor:pointer; }

    .chip-filter.active{ border-color:var(--focus); }



    /* L→R dots for loading */

    .dots { display:inline-flex; gap:6px; align-items:center; vertical-align:middle }

    .dot { width:6px; height:6px; border-radius:50%; background:#7aa0ff; opacity:.25; }

    .dot.on { opacity:1 }



    /* Error banner */

    .errbar{

      position:sticky;

      top:0;

      z-index:50;

      display:none;

      padding:10px 16px;

      background:rgba(43,15,18,0.85);

      color:#ffb3b3;

      border-bottom:1px solid rgba(122,42,42,0.5);

      font-size:12px;

      letter-spacing:.3px;

      backdrop-filter:blur(14px);

      -webkit-backdrop-filter:blur(14px);

    }

    .errbar.show{ display:block }



    /* === Record (portrait) — tuck all frames to the very top =============== */

    @media (orientation: portrait){



      /* 1) Remove the global top padding while recording (main will handle safe area) */

      body.record-active{

        padding-top:0 !important;

      }



      /* 2) Hide the rounded glass/backdrop behind the content in record-portrait

            so we don't see a "second frame" above the preview */

      body.record-active main::before{

        display:none !important;

      }



      /* 3) Make main hug the status bar (keep safe-area) and reserve bottom for tabs */

      body.record-active main{

        padding-top:calc(env(safe-area-inset-top, 0px) + 0px) !important;

        padding-bottom:calc(env(safe-area-inset-bottom, 0px) + var(--tabsH)) !important;

      }



      /* 4) Remove any top spacing from the record card and grid */

      body.record-active #screen-record .card.record-grid{

        margin-top:0 !important;

        padding-top:0 !important;

      }

      body.record-active #screen-record .record-grid{

        height:calc(100dvh - var(--tabsH)) !important;

        grid-template-rows:1fr auto !important; /* preview grows, controls stick */

      }



      /* 5) Preview wrapper: no top padding/margin; let the video sit flush */

      body.record-active #screen-record .preview-wrap{

        margin-top:0 !important;

        padding-top:0 !important;

        /* cap so controls never get pushed off-screen */

        max-height:calc(100dvh - var(--tabsH) - (var(--btn-h) * 2 + 10px) - env(safe-area-inset-bottom,0px)) !important;

      }



      /* 6) Video keeps portrait aspect and fills the wrapper */

      body.record-active #screen-record #preview{

        width:100%;

        height:100%;

        aspect-ratio:9 / 16;

        object-fit:cover;

      }



      /* 7) Control rail: two rows (camera|headphones, then full-width REC) */

      body.record-active #screen-record .control-rail{

        display:grid !important;

        grid-template-columns:1fr 1fr !important;

        grid-template-areas:

          "camera headphones"

          "rec     rec";

        grid-auto-rows:var(--btn-h);

        gap:10px;

        padding-bottom:0;

        margin-top:0;

      }

      body.record-active #screen-record .pos-camera{ grid-area:camera; }

      body.record-active #screen-record .pos-headphones{ grid-area:headphones; }

      body.record-active #screen-record .pos-rec{ grid-area:rec; width:100%; }

      body.record-active #screen-record #btnRec{

        grid-column:1 / -1 !important;

        width:100% !important;

      }

    }



    /* Rehearse: center the "Edit mode" pill and prevent flex stretching */

    #screen-rehearse .row > .badge{

      flex:0 0 auto !important;

      display:inline-flex;

      align-items:center;

      justify-content:center;

      text-align:center;

      white-space:nowrap;

      line-height:1.2;

      padding:6px 12px;

    }



    /* === Record: rule-of-thirds overlay ====================================== */

    #screen-record .preview-wrap{ position:relative; }



    .grid-overlay{

      position:absolute;

      inset:8px;

      border-radius:inherit;

      pointer-events:none;

      display:none;

      z-index:4;

    }

    .grid-overlay .v,

    .grid-overlay .h{

      position:absolute;

      background:rgba(230,240,255,0.38);

      box-shadow:0 0 0 1px rgba(0,0,0,0.18) inset;

      transform:translateZ(0);

    }

    .grid-overlay .v{ top:0; bottom:0; width:1px; }

    .grid-overlay .h{ left:0; right:0; height:1px; }

    .grid-overlay .v1{ left:33.333%; }

    .grid-overlay .v2{ left:66.666%; }

    .grid-overlay .h1{ top:33.333%; }

    .grid-overlay .h2{ top:66.666%; }



    /* Align overlay inset with the tighter padding used on small landscape */

    @media (orientation: landscape) and (max-width: 1024px){

      body.record-active #screen-record .grid-overlay{ inset:6px; }

    }



    /* === Record: Count-in picker ================================================= */

    .countin-menu{

      position:fixed;

      z-index:1100;

      display:none;

      background:rgba(12,15,24,0.96);

      border:1px solid var(--border);

      border-radius:12px;

      padding:6px;

      box-shadow:0 18px 40px rgba(3,6,15,0.45);

      backdrop-filter:blur(10px);

    }

    .countin-menu[hidden]{ display:none; }

    .countin-menu button{

      display:block;

      width:100%;

      background:transparent;

      color:var(--text);

      border:1px solid rgba(147,160,195,0.28);

      border-radius:10px;

      padding:8px 10px;

      margin:4px 0;

      font-weight:700;

      letter-spacing:.2px;

    }

    .countin-menu button:active{ transform:scale(0.98); }



    /* Hide picker in portrait just in case */

    @media (orientation: portrait){

      .countin-menu{ display:none !important; }

    }



    /* Record (rail buttons): prevent iOS long-press text selection/callout */

    #screen-record .control-rail .btn,

    #screen-record .control-rail .btn *{

      -webkit-user-select:none;

      user-select:none;

      -webkit-touch-callout:none;

    }

    /* Remove the gray tap flash for nicer feel */

    #screen-record .control-rail .btn{

      -webkit-tap-highlight-color:transparent;

    }



    /* --- Route guidance modal -------------------------------------------------- */

    .ob-hidden { display: none !important; }

    .ob-modal { position: fixed; inset: 0; z-index: 9999; }

    .ob-modal__scrim {

      position: absolute; inset: 0;

      background: rgba(0,0,0,0.45);

      backdrop-filter: blur(2px);

    }

    .ob-modal__card {

      position: absolute; left: 50%; top: 50%;

      transform: translate(-50%, -50%);

      width: min(520px, 92vw);

      max-height: calc(100svh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - 32px);

      background: #1a1a1a; color: #f5f5f5;

      border-radius: 16px; box-shadow: 0 18px 48px rgba(0,0,0,0.4);

      padding: 20px; overflow: auto;

    }

    .ob-modal__title { margin: 0 0 6px; font-size: 18px; font-weight: 700; }

    .ob-modal__body { margin: 0 0 10px; font-size: 14px; line-height: 1.4; }

    .ob-modal__details summary { cursor: pointer; margin-bottom: 6px; }

    .ob-modal__actions { display: flex; justify-content: flex-end; gap: 8px; margin-top: 12px; }

    .ob-modal__close {

      position: absolute; top: 8px; right: 8px; width: 32px; height: 32px;

      border-radius: 8px; border: none; background: rgba(255,255,255,0.06); color: #fff; cursor: pointer;

    }

    .btn.btn-primary {

      appearance: none; border: none; border-radius: 12px; padding: 10px 16px;

      background: #ff4d4f; color: #fff; font-weight: 600; cursor: pointer;

    }

    @supports (padding:max(0px)) {

      .ob-modal__card { padding-bottom: max(20px, env(safe-area-inset-bottom)); }

    }

    /* === Auth Landing (full-screen lock) ====================================== */

    .auth-landing-scrim{

      background: radial-gradient(1200px 800px at 70% 20%, rgba(30,35,50,0.7), rgba(0,0,0,0.7)),

                  rgba(0,0,0,0.55);

      backdrop-filter: blur(6px);

    }



    .ob-modal__card.auth-landing{

      width:min(720px, 94vw);

      max-width:720px;

      border-radius:24px;

      background: linear-gradient(160deg, rgba(14,16,24,0.96), rgba(8,10,16,0.96));

      border:1px solid rgba(150,164,200,0.18);

      padding:0;

      overflow:hidden;

    }



    .auth-inner{

      padding:24px;

    }



    .auth-brand{

      display:flex; align-items:center; gap:14px;

      margin-top:0;

    }

    .auth-logo{

      width:64px; height:64px; border-radius:14px;

      box-shadow:0 10px 28px rgba(0,0,0,0.35), 0 0 0 1px rgba(160,180,220,0.2) inset;

      background:#000;

    }

    .auth-text{ display:flex; flex-direction:column; gap:2px; }

    .auth-title{

      margin:0; font-size:22px; letter-spacing:.6px; font-weight:800;

    }

    .auth-subtitle{

      font-size:13px; color:var(--muted); letter-spacing:.3px;

    }



    .auth-copy{ margin:14px 0 8px; color:var(--muted); }

    .auth-actions{

      display:grid; grid-template-columns:1fr; gap:10px; margin-top:8px;

    }

    @media (min-width: 520px){

      .auth-actions{ grid-template-columns:1fr 1fr; }

    }



      .auth-actions .btn{

        min-height:48px; font-size:15px; border-radius:16px;

      }

      /* Dev tools: compact but readable */

      #devEntButtons .btn { min-height: 40px; font-size: 14px; }

      /* Credit card styles */
      .creditCard {
        margin-top: 12px;
        padding: 16px;
        border: 1px solid #444;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.02);
      }

      .creditRow {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
      }

      .creditLabel {
        font-weight: 600;
        font-size: 14px;
        margin-bottom: 4px;
      }

      .creditSub {
        font-size: 12px;
        color: var(--muted);
        line-height: 1.4;
      }

      .creditValue {
        text-align: right;
        flex-shrink: 0;
      }

      .creditBig {
        font-size: 26px;
        font-weight: 700;
        line-height: 1;
      }

      .creditTiny {
        font-size: 11px;
        color: var(--muted);
        margin-top: 2px;
      }

      .creditDivider {
        height: 1px;
        background: #444;
        margin: 12px 0;
      }

      /* Rehearse: make Count-in pill compact instead of full-width */

      #selRehearseCountIn {

        flex: 0 0 auto;

        width: auto;

        min-width: 64px;

        max-width: 88px;

        text-align: center;

        padding-inline: 10px;

      }



      /* On very small screens, keep it from stretching */

      .toolbar .right #selRehearseCountIn {

        align-self: center;

      }

      /* Full-screen busy overlay */
      .ob-busy {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
      }

      .ob-busy.hidden {
        display: none;
      }

      .ob-busy-card {
        background: #1e1e1e;
        border: 1px solid #444;
        border-radius: 8px;
        padding: 32px;
        text-align: center;
        max-width: 300px;
      }

      .ob-spin {
        width: 48px;
        height: 48px;
        border: 4px solid #333;
        border-top-color: #fff;
        border-radius: 50%;
        margin: 0 auto 16px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      .ob-busy-text {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 8px;
        color: #fff;
      }

      .ob-busy-sub {
        font-size: 13px;
        color: #999;
      }

  </style>

</head>

<body>

  <div id="errbar" class="errbar" role="alert"></div>

  <main>

    <!-- IMPORT -->

  <section id="screen-import" class="screen active">

      <div class="card">

        <h3>Import</h3>

        <p class="hint">Two ways to import. <b>Paste Script Text</b> is most reliable; <b>Upload PDF</b> extracts text with an OCR fallback for scanned PDFs.</p>

        <div class="inner-tabs" role="tablist">

          <button id="tab-text" class="active" role="tab" aria-controls="panel-text" aria-selected="true">Paste Script Text</button>

          <button id="tab-pdf" role="tab" aria-controls="panel-pdf" aria-selected="false">Upload PDF</button>

        </div>

        <div class="spacer12"></div>



        <!-- TEXT PANEL -->

        <div id="panel-text" role="tabpanel" aria-labelledby="tab-text">

          <label>Title</label>

          <input id="titleText" type="text" placeholder="My Sides" />

          <label>Paste script here</label>

          <textarea id="scriptText" placeholder="JANE: Hi.

GABE: Hey.

JANE: Ready?"></textarea>

          <div class="spacer8"></div>

          <div class="row">

            <button id="btnTextUpload" class="btn">Upload & Continue</button>

            <button id="btnTextClear" class="btn secondary">Clear</button>

          </div>

          <div class="spacer12"></div>

          <label>Status</label>

          <pre id="status" class="status"></pre>

        </div>



        <!-- PDF PANEL -->

        <div id="panel-pdf" role="tabpanel" aria-labelledby="tab-pdf" hidden>

          <label>Title</label>

          <input id="titlePdf" type="text" placeholder="My PDF Sides" />

          <label>PDF File</label>

          <input id="pdfFile" type="file" accept="application/pdf" />

          <div class="spacer8"></div>

          <div class="row">

            <button id="btnPdfUpload" class="btn">Upload & Continue</button>

            <button id="btnPdfOcr" class="btn ghost" title="Use OCR if your PDF is scanned images" disabled>Try OCR (slow)</button>

          </div>

          <div class="spacer12"></div>

          <label>Status</label>

          <pre id="statusPdf" class="status"></pre>

          <div class="small">Tip: OCR processes the first 3 pages for speed.</div>

        </div>

        <div id="savedScriptsContainer" class="import-saved-scripts">

          <div class="saved-scripts-header">

            <div class="saved-scripts-title">Your Scripts</div>

            <div id="savedScriptsStatus" class="saved-scripts-status"></div>

          </div>

          <div id="savedScriptsStrip" class="saved-scripts-strip">

            <!-- Filled by renderSavedScriptsStrip() -->

          </div>

        </div>

        <div id="importEditorContainer" class="import-editor">

          <div class="import-editor-header">

            <div class="import-editor-title">Script Viewer</div>

            <div id="importEditorMeta" class="import-editor-meta"></div>

          </div>

          <div id="importSceneSelector" class="import-scene-selector"></div>

          <div id="importLinesList" class="import-lines-list"></div>

            <div class="import-editor-footer">

              <div class="small import-editor-hint">

                Edits here update this device's copy. AI audio may still follow the original script until sync is added.

              </div>

              <div id="importPersistenceDebug" class="small import-editor-hint"></div>

              <div class="import-editor-actions">

                <button id="importSaveEdits" type="button" class="btn sm">

                  Save Changes

                </button>

              <button id="importGoAssign" type="button" class="btn sm secondary">

                Continue → Assign

              </button>

            </div>

          </div>

        </div>



      </div>

    </section>



    <!-- ASSIGN -->

    <section id="screen-assign" class="screen">

      <div class="card">

        <h3>Assign</h3>

        <div><span class="pill" id="pillScript">script: —</span> <span class="pill" id="pillScenes">scenes: 0</span></div>

        <div class="spacer8"></div>

        <label>I am…</label>

        <select id="selectRole"></select>

        <div class="spacer8"></div>

        <div id="voicePickers"></div>

        <div class="spacer8"></div>

        <button id="btnSaveAssign" class="btn">Save Voices</button>

      </div>

    </section>



    <!-- REHEARSE -->

    <section id="screen-rehearse" class="screen">

      <div class="card">

        <h3>Rehearse</h3>

  <div id="routeWarn" class="hidden" style="display:none!important;background:#fff4e5;border:1px solid #ffd4a8;color:#8a4b00;padding:10px 12px;border-radius:10px;margin:8px 0;line-height:1.3">

          <div style="font-weight:600;margin-bottom:4px">Heads-up: iPhone may be in “call” mode</div>

          <div style="font-size:14px">

            If you can’t hear the reader during your line, flip your iPhone’s <b>ringer switch ON</b> (side of the phone) and avoid Bluetooth “call audio” mode.

            <span id="routeWarnMore" data-route-warn-more style="text-decoration:underline;cursor:pointer">Learn how</span>

          </div>

        </div>



        <div class="hint" id="rehearseBanner"><b>Review and edit your script in the Import tab</b> before rendering for rehearsal. When ready, press "Render for rehearsal (OpenAI)" to pre-load partner voices for perfect timing.</div>

        <div class="spacer8"></div>



        <div class="row">

          <button id="btnRehearseRender" class="btn">Render for rehearsal (OpenAI)</button>

          <button id="btnRehearseClear" class="btn secondary" title="Discard pre-rendered clips">Clear Render</button>

        </div>

        <div class="spacer6"></div>

        <div class="row">

          <label>Render quality</label>

          <select id="selTtsModel">

            <option value="tts-1" selected>Fast</option>

            <option value="tts-1-hd">Natural (HD)</option>

          </select>

        </div>

        <div class="spacer6"></div>

        <div class="small" id="rehearseRenderStatus"></div>

  <!-- Audio route unlock (appears only if iOS blocks playback after backgrounding) -->

  <button id="btnEnableAudio" class="btn secondary" style="display:none;margin-top:8px">Enable Audio</button>



        <div class="spacer12"></div>



        <div class="toolbar" aria-label="Playback controls">

          <div class="controls">

            <div class="left">

              <button id="btnPlay" class="btn">Play</button>

              <button id="btnPrev" class="btn secondary">Prev</button>

              <button id="btnNext" class="btn secondary">Next</button>

              <button id="btnTop" class="btn secondary icon" title="From the top"></button>

              <select id="selPace" title="Partner pacing">

                <option value="0" selected>No gap</option>

                <option value="80">+80 ms</option>

                <option value="160">+160 ms</option>

                <option value="300">+300 ms</option>

              </select>

            </div>

                <div class="right">

                  <label for="selRehearseCountIn" class="small">Count-in</label>

                  <select id="selRehearseCountIn" title="Rehearse count-in">

                    <option value="0" selected>0s</option>

                    <option value="3">3s</option>

                    <option value="5">5s</option>

                    <option value="10">10s</option>

                  </select>

                  <button id="btnMic" class="btn secondary" aria-pressed="false">Mic: Off</button>

                  <span id="micBadge" class="badge warn">off</span>

                </div>

          </div>

        </div>



        <div id="lines"></div>

      </div>

    </section>



    <!-- RECORD -->

    <section id="screen-record" class="screen">

      <div id="routeWarnRecord" class="hidden" style="background:#fff4e5;border:1px solid #ffd4a8;color:#8a4b00;padding:10px 12px;border-radius:10px;margin:8px 0;line-height:1.3">

        <div style="font-weight:600;margin-bottom:4px">Heads-up: iPhone may be in “call” mode</div>

        <div style="font-size:14px">

          If you can’t hear the reader during your line, flip your iPhone’s <b>ringer switch ON</b> (side of the phone) and avoid Bluetooth “call audio” mode.

          <span id="routeWarnMoreRecord" data-route-warn-more style="text-decoration:underline;cursor:pointer">Learn how</span>

        </div>

      </div>

      <div class="card record-grid record-card">

        <!-- Preview -->

        <div class="preview-wrap">

          <video id="preview" autoplay muted playsinline></video>

          <audio id="readerAudio" preload="auto" playsinline></audio>

          <!-- Rule-of-thirds overlay (hidden by default) -->

          <div id="gridOverlay" class="grid-overlay" aria-hidden="true">

            <span class="v v1"></span><span class="v v2"></span>

            <span class="h h1"></span><span class="h h2"></span>

          </div>

          <button id="btnFlipCam" class="flipcam" aria-label="Flip camera" title="Flip camera">⟳</button>

        </div>



        <!-- Controls -->

        <div class="control-rail controls-stack">

          <button id="btnRender" class="btn btn-render rail landscape-only pos-render">Render</button>

          <button id="btnRec" class="btn rec pos-rec">REC</button>

          <button id="btnGrid" class="btn secondary rail landscape-only pos-grid" aria-pressed="false">Grid: Off</button>

          <button id="btnCamera" class="btn secondary rail pos-camera" aria-pressed="false">Camera: Off</button>

          <button id="btnCountIn" class="btn secondary rail landscape-only pos-countin" aria-pressed="false">Count-in: Off</button>

          <button id="btnHeadphones" class="btn secondary rail pos-headphones" aria-pressed="true">Headphones: On</button>

        </div>

      </div>

    </section>



    <!-- GALLERY -->

    <section id="screen-gallery" class="screen">

      <div class="card">

        <h3>Gallery</h3>

        <div id="takes"></div>

        <div class="hint">Takes are saved on this device for 14 days (max 10). Use “Download” to save/share.</div>

      </div>

    </section>



    <!-- SETTINGS -->

    <section id="screen-settings" class="screen">

      <div class="card">

        <h3>Settings</h3>

        <div class="hint">

          Sign in with your device passkey to unlock rehearsal, recording, and credit top-ups.

          Access codes are still supported while we’re in beta.

        </div>

        <div class="spacer8"></div>



        <div id="inviteBlock" style="display:none">

          <label>Access Code</label>

          <input id="inviteCode" type="text" placeholder="Enter invite/access code" autocomplete="one-time-code" />

          <div class="spacer8"></div>

          <div class="row">

            <button id="btnSubmitInvite" class="btn">Enter Access Code</button>

          </div>

          <div class="spacer8"></div>

        </div>

        <div id="authActionsRow" class="row">

          <button id="btnRegisterPasskey" class="btn">Register Passkey</button>

          <button id="btnSignIn" class="btn secondary">Sign In</button>

          <button id="btnSignOut" class="btn secondary">Sign Out</button>

          <button id="btnAddCreditsSettings" class="btn secondary" disabled>Add credits</button>

          <button id="btnGoProMonthly" class="btn secondary" disabled>Go Pro Monthly ($14.99/mo)</button>

          <button id="btnManageSubscription" class="btn secondary" disabled style="display:none">Manage subscription</button>

        </div>

        <div id="addCreditsHintSettings" class="small">Sign in to add credits.</div>

        <div id="addCreditsToastSettings" class="small" style="display:none; margin-top:6px">Stripe checkout coming soon.</div>

        <div id="proCreditCard" class="creditCard" style="display:none;">
          <div class="creditRow">
            <div>
              <div class="creditLabel">Pro monthly credits</div>
              <div class="creditSub" id="proMonthlySub">Used 0/120 • Renews 2025-01-15</div>
            </div>
            <div class="creditValue">
              <div class="creditBig" id="proMonthlyRemaining">120</div>
              <div class="creditTiny">remaining</div>
            </div>
          </div>

          <div class="creditDivider"></div>

          <div class="creditRow">
            <div>
              <div class="creditLabel">Top-up credits</div>
              <div class="creditSub">Used after monthly credits run out. Roll over while Pro is active. If you cancel, they expire at the end of this paid period.</div>
            </div>
            <div class="creditValue">
              <div class="creditBig" id="topupBalance">0</div>
              <div class="creditTiny">top-ups</div>
            </div>
          </div>
        </div>

        <div id="proStatusLine" class="small" style="margin-top:6px"></div>

        <div class="spacer8"></div>

        <!-- Link another device section -->
        <div id="linkDeviceSection" style="display:none; margin-top:12px; padding:12px; border:1px solid #444; border-radius:4px;">
          <div class="linkRow">
            <div style="font-weight:600;">Link another device</div>
            <button id="btnGetLinkCode" class="btn secondary ml-auto">Get Link Code</button>
          </div>
          <div id="getLinkCodeStatus" class="small" style="margin-top:8px; color:var(--muted);"></div>
          <div id="linkCodeDisplay" style="display:none; margin-top:12px;">
            <div style="font-size:24px; font-family:monospace; letter-spacing:4px; text-align:center; padding:12px; background:#1e1e1e; border-radius:4px;" id="linkCodeText"></div>
            <div class="small" style="margin-top:6px; text-align:center;" id="linkCodeExpiry"></div>
          </div>

          <!-- Linked devices list -->
          <div style="margin-top:16px;">
            <div style="font-weight:600; margin-bottom:8px;">Linked devices</div>
            <div id="linkedDevicesStatus" class="muted" style="margin-top:6px;"></div>
            <div id="linkedDevicesList" style="margin-top:10px; display:flex; flex-direction:column; gap:10px;"></div>
          </div>
        </div>

        <div id="claimLinkSection" style="display:none; margin-top:12px; padding:12px; border:1px solid #444; border-radius:4px;">
          <div style="font-weight:600; margin-bottom:8px;">Link to existing account</div>
          <input id="linkCodeInput" type="text" placeholder="Enter Link Code (ABCD-EFGH)" style="width:100%; margin-bottom:8px; text-transform:uppercase;" />
          <button id="btnClaimLinkCode" class="btn">Link & Register Passkey</button>
          <div id="linkCodeStatus" class="small" style="margin-top:6px;"></div>
        </div>

        <div class="spacer8"></div>

        <pre id="authStatus" class="status" aria-live="polite"></pre>

        <div id="authStatusFriendly" class="small" style="display:none"></div>

        <div class="settings-row">

          <div class="settings-label">Signed in as</div>

          <div class="settings-value" id="settings-session-user-id">Checking...</div>

        </div>

        <div id="profileDisplayNameBlock" style="display:none; margin-top:12px;">

          <label>Display name</label>

          <div style="display:flex; gap:8px; align-items:center;">

            <input id="profileDisplayNameInput" type="text" placeholder="Enter your display name" style="flex:1;" />

            <button id="btnSaveDisplayName" class="btn secondary">Save</button>

          </div>

        </div>

        <div id="entitlementLine" class="small" style="display:none"></div>

        <div id="devEntButtons" style="display:none; margin-top:6px;">

          <button id="btnDevGrantCredits" class="btn">Grant 200 test credits</button>

        </div>

        <div id="billingAdminPanel" style="display:none; margin-top:12px; padding:12px; border:1px solid #444; border-radius:4px;">
          <div style="font-weight:600; margin-bottom:8px;">Billing Admin</div>
          <input id="billingReplayEventId" type="text" placeholder="evt_..." style="width:100%; margin-bottom:8px; font-family:monospace;" />
          <div style="display:flex; gap:8px; margin-bottom:8px;">
            <button id="btnBillingReplayEvent" class="btn secondary">Replay Stripe event</button>
            <button id="btnBillingRefreshSession" class="btn secondary">Refresh session</button>
          </div>
          <pre id="billingAdminOut" class="status" style="font-size:11px; max-height:200px; overflow:auto;"></pre>
        </div>

        <div class="spacer8"></div>

        <div id="reauthTip" class="small" style="display:none">

          Got a 401? <a href="#" id="linkReenterCode">Re-enter Access Code</a>.

        </div>



        <div class="spacer12"></div>

        <h3>Info & How to Use</h3>

        <p class="hint">Quick start guide. Headphones recommended for clean timing.</p>



        <ol style="margin:0; padding-left:18px; line-height:1.55">

          <li><b>Import</b>

            <div class="small">

              • <b>Paste Script Text</b> (most reliable) — give it a title and press <i>Continue → Assign</i>.<br>

              • <b>Upload PDF</b> — text PDFs auto-extract; scanned PDFs show <i>Try OCR</i> for the first 3 pages.

            </div>

          </li>

          <div class="spacer8"></div>

          <li><b>Assign</b>

            <div class="small">

              • Choose <b>I am…</b> (your role).<br>

              • Pick partner <b>voices</b>. Save.

            </div>

          </li>

          <div class="spacer8"></div>

          <li><b>Rehearse</b>

            <div class="small">

              • Scripts are read-only here. To change lines, go back to <b>Import</b>, adjust your script, then return to Rehearse.<br>

              • Press <b>Render for rehearsal (OpenAI)</b> to pre-load partner clips. Choose Fast/HD.<br>

              • Use <b>Play / Prev / Next</b>. Turn <b>Mic: On</b> to enable listen/respond.<br>

              • <b>Interruption rule:</b> if your line ends with an em dash “—”, the partner comes in fast.<br>

              • Pacing select adjusts small gaps after partner lines.

            </div>

          </li>

          <div class="spacer8"></div>

          <li><b>Record</b>

            <div class="small">

              • <b>Render</b> reuses cached rehearsal clips when available (best timing).<br>

              • Toggle <b>Camera / Count-in / Headphones</b>. Tap <b>REC</b> to start/stop.

            </div>

          </li>

          <div class="spacer8"></div>

          <li><b>Gallery</b>

            <div class="small">

              • Plays inline. <b>Download</b> or <b>Share</b>. Auto-prunes after 14 days (max 10).<br>

              • Filter by aspect (16:9 / 9:16). Add a note per take.

            </div>

          </li>

        </ol>



        <div class="spacer12"></div>

        <div class="small">

          <b>Tips:</b> Use wired/Bluetooth headphones to avoid echo/ducking. If TTS shows a 429 quota message, top up credits and press Render again. “Clear Render” removes cached clips.

        </div>

        <details id="advTroubleshoot" style="margin:12px 0">

          <summary>Advanced · Troubleshooting</summary>

          <label style="display:flex;align-items:center;gap:8px;margin-top:8px">

            <input id="advSpeakerFallback" type="checkbox">

            <span>Always use phone speaker while I’m speaking (session only)</span>

          </label>

          <div style="opacity:.7;font-size:12px;margin-top:4px">

            Use only if your Bluetooth headphones enter "call mode" and hide the reader audio.

          </div>

        </details>

      </div>

    </section>

  </main>



  <!-- Bottom bar -->

  <nav class="tabbar" role="tablist" aria-label="App sections">

    <div class="tabbar-inner">

      <button data-tab="import" class="active" role="tab" aria-selected="true">Import</button>

      <button data-tab="assign" role="tab" aria-selected="false">Assign</button>

      <button data-tab="rehearse" role="tab" aria-selected="false">Rehearse</button>

      <button data-tab="record" role="tab" aria-selected="false">Record</button>

      <button data-tab="gallery" role="tab" aria-selected="false">Gallery</button>

      <button data-tab="settings" role="tab" aria-selected="false">Settings</button>

    </div>

  </nav>



  <!-- Vendor -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.6.82/pdf.min.mjs" type="module"></script>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>



  <!-- App -->

    <script type="module">

    import { expectedMinMsFor, AFTER_ADV_COOLDOWN_MS, isSpeaking, endsWithDashy, readyForAdvance, progressRatio } from "./js/speech-timing.js";

    // Maximum time we’ll sit on a single “my” line once we’ve heard speech

    // before we force an advance. Shared by Rehearse and Record so they

    // behave the same. Tuned to stop “ghosting” without feeling rushed.

    const MAX_MY_LINE_MS = 9000; // ~9s safety net

    const boot = () => {

      const qs = new URLSearchParams(location.search);

      const cookieSecret = (() => {

        try {

          const match = document.cookie.split(";").map(s => s.trim()).find(s => s.startsWith("ob_secret="));

          if (!match) return "";

          return decodeURIComponent(match.slice("ob_secret=".length));

        } catch { return ""; }

      })();

      let storedSecret = "";

      try {

        storedSecret = (localStorage.getItem("offbook_secret") || "").trim();

      } catch { storedSecret = ""; }

      const querySecret = (qs.get("secret") || "").trim();

      const secret = querySecret || storedSecret || cookieSecret || "";

      if (secret) {

        window.__OB_SECRET__ = secret;

        try { document.cookie = `ob_secret=${encodeURIComponent(secret)}; Path=/; Max-Age=31536000; SameSite=Lax`; } catch {}

        try { localStorage.setItem("offbook_secret", secret); } catch {}

      } else {

        try { delete window.__OB_SECRET__; } catch { window.__OB_SECRET__ = undefined; }

      }

      const JSON_HDRS = { "Content-Type":"application/json" };

      // OpenAI TTS / audio voices we support

      const OPENAI_VOICES = [

        "alloy",

        "ash",

        "ballad",

        "coral",

        "echo",

        "fable",

        "onyx",

        "nova",

        "sage",

        "shimmer"

      ];

      const isNgrokHost = /ngrok/i.test(location.hostname);

      function withSecretHeaders(init = {}) {

        const next = { ...(init || {}) };

        const baseHeaders = init?.headers instanceof Headers ? init.headers : init?.headers;

        const headers = new Headers(baseHeaders || {});

        const activeSecret = window.__OB_SECRET__;

      if (activeSecret) headers.set("X-Shared-Secret", activeSecret);

      if (isNgrokHost) headers.set("ngrok-skip-browser-warning", "true");

      next.headers = headers;

      // Ensure session cookies survive iOS fetches
      if (!next.credentials) next.credentials = "include";
      if (!next.cache) next.cache = "no-store";

      return next;

    }

    async function downloadBinaryToDevice(url, filename) {
      const resp = await fetch(url, {
        method: "GET",
        headers: withSecretHeaders({}),
        credentials: "include",
      });

      if (!resp.ok) {
        let msg = `${resp.status}`;
        try { msg = await resp.text(); } catch {}
        throw new Error(`Download failed (${resp.status}): ${msg}`);
      }

      const blob = await resp.blob();
      const type = blob.type || "application/octet-stream";
      const file = new File([blob], filename, { type });

      // Prefer iOS share sheet (avoids "black page")
      if (navigator.share && (!navigator.canShare || navigator.canShare({ files: [file] }))) {
        await navigator.share({ files: [file], title: filename });
        return;
      }

      // Fallback: force a download
      const blobUrl = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = blobUrl;
      a.download = filename;
      a.rel = "noopener";
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(blobUrl), 10_000);
    }

    // Mix Ready Modal (OffBook-styled) + Room file cache
    const roomFileCache = new Map(); // takeId -> { file, filename, timestamp }
    const ROOM_CACHE_TTL = 2 * 60 * 1000; // 2 minutes

    function showMixReadyModal(takeId) {
      return new Promise((resolve) => {
        // Create dark overlay
        const overlay = document.createElement("div");
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.85);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
          animation: fadeIn 0.2s ease;
        `;

        // Create dialog panel with OffBook styling
        const panel = document.createElement("div");
        panel.style.cssText = `
          background: #1a1a1a;
          border: 1px solid #333;
          border-radius: 12px;
          padding: 24px;
          min-width: 280px;
          max-width: 340px;
          text-align: center;
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        `;

        // Title
        const title = document.createElement("h3");
        title.textContent = "Mix ready!";
        title.style.cssText = "margin: 0 0 20px 0; font-size: 18px; font-weight: 600; color: #fff;";

        // Button container
        const btnContainer = document.createElement("div");
        btnContainer.style.cssText = "display: flex; gap: 12px; justify-content: center;";

        // Cancel button
        const btnCancel = document.createElement("button");
        btnCancel.textContent = "Cancel";
        btnCancel.style.cssText = `
          padding: 12px 24px;
          border: 1px solid #444;
          background: transparent;
          color: #aaa;
          border-radius: 8px;
          cursor: pointer;
          font-size: 15px;
          font-weight: 500;
          transition: all 0.2s;
        `;
        btnCancel.onmouseenter = () => {
          btnCancel.style.background = "#222";
          btnCancel.style.color = "#fff";
        };
        btnCancel.onmouseleave = () => {
          btnCancel.style.background = "transparent";
          btnCancel.style.color = "#aaa";
        };
        btnCancel.onclick = () => {
          document.body.removeChild(overlay);
          resolve({ action: "cancel" });
        };

        // Save/Share button
        const btnSave = document.createElement("button");
        btnSave.textContent = "Save/Share";
        btnSave.style.cssText = `
          padding: 12px 24px;
          border: none;
          background: #4a9eff;
          color: #fff;
          border-radius: 8px;
          cursor: pointer;
          font-size: 15px;
          font-weight: 500;
          transition: all 0.2s;
        `;
        btnSave.onmouseenter = () => {
          btnSave.style.background = "#6ab0ff";
        };
        btnSave.onmouseleave = () => {
          btnSave.style.background = "#4a9eff";
        };
        btnSave.onclick = async () => {
          // Get cached file
          const cached = roomFileCache.get(takeId);
          if (!cached) {
            document.body.removeChild(overlay);
            resolve({ action: "error", message: "File not found in cache" });
            return;
          }

          // Check cache expiry
          if (Date.now() - cached.timestamp > ROOM_CACHE_TTL) {
            roomFileCache.delete(takeId);
            document.body.removeChild(overlay);
            resolve({ action: "expired" });
            return;
          }

          const { file, filename } = cached;

          try {
            // Try navigator.share immediately (no awaits before this!)
            const canShareFiles =
              !!navigator.share &&
              (!navigator.canShare || navigator.canShare({ files: [file] }));

            if (canShareFiles) {
              await navigator.share({ files: [file], title: filename });
              document.body.removeChild(overlay);
              resolve({ action: "shared" });
              return;
            }
          } catch (shareErr) {
            console.warn("[offbook] share failed, falling back to download", shareErr);
          }

          // Fallback: <a download>
          try {
            const objUrl = URL.createObjectURL(file);
            const a = document.createElement("a");
            a.href = objUrl;
            a.download = filename;
            a.rel = "noopener";
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => URL.revokeObjectURL(objUrl), 20000);
            document.body.removeChild(overlay);
            resolve({ action: "downloaded" });
          } catch (dlErr) {
            console.error("[offbook] download fallback failed", dlErr);
            document.body.removeChild(overlay);
            resolve({ action: "error", message: String(dlErr) });
          }
        };

        btnContainer.appendChild(btnCancel);
        btnContainer.appendChild(btnSave);
        panel.appendChild(title);
        panel.appendChild(btnContainer);
        overlay.appendChild(panel);
        document.body.appendChild(overlay);
      });
    }

    // --- Dev flag: enable server STT plumbing when ?stt2=1 is present ---

    const STT2_ENABLED = new URLSearchParams(window.location.search).has("stt2");

    // Rolling mic recorder for STT2 debug (audio → /debug/stt_transcribe_chunk)

    let stt2Recorder = null;

    // Safari / MediaRecorder usually puts the WebM header in the first chunk.

    // We keep that header chunk forever and only roll the *body* chunks.

    let stt2HeaderChunk = null;

    let stt2BodyChunks = [];

    let stt2Mime = "";



    let sttOverlayEl = null;

    function ensureSttOverlay() {

      if (!STT2_ENABLED) return null;

      if (sttOverlayEl) return sttOverlayEl;

      const el = document.createElement("div");

      el.id = "stt-debug-overlay";

      el.style.position = "fixed";

      el.style.left = "0";

      el.style.right = "0";

      el.style.bottom = "0";

      el.style.padding = "6px 10px";

      el.style.fontSize = "12px";

      el.style.background = "rgba(0,0,0,0.85)";

      el.style.color = "#fff";

      el.style.zIndex = "9999";

      el.style.pointerEvents = "none";

      el.style.maxHeight = "35vh";

      el.style.overflow = "auto";

      el.style.fontFamily = "system-ui, -apple-system, BlinkMacSystemFont, sans-serif";

      el.style.whiteSpace = "pre-wrap";

      document.body.appendChild(el);

      sttOverlayEl = el;

      return el;

    }



    function updateSttOverlay(text) {

      if (!STT2_ENABLED) return;

      const el = ensureSttOverlay();

      if (!el) return;

      el.textContent = text || "";

    }

    async function sendSttChunkToServer(opts = {}) {

      // opts: { audioBlob | audioBuffer, mime?, scriptId?, sceneId?, lineId? }

      const audioBlob = opts.audioBlob || null;

      const audioBuffer = opts.audioBuffer || null;

      const mime = opts.mime || "audio/webm";



      let blob;

      if (audioBlob instanceof Blob) {

        blob = audioBlob;

      } else if (audioBuffer instanceof ArrayBuffer || ArrayBuffer.isView(audioBuffer)) {

        blob = new Blob([audioBuffer], { type: mime });

      } else {

        console.warn("[stt] sendSttChunkToServer called without audio");

        return null;

      }



      try {

        const buf = await blob.arrayBuffer();

        const bytes = new Uint8Array(buf);



        // Browser-safe base64 encode

        let binary = "";

        for (let i = 0; i < bytes.length; i++) {

          binary += String.fromCharCode(bytes[i]);

        }

        const audio_b64 = btoa(binary);



        const payload = {

          audio_b64,

          mime: blob.type || mime

        };

        if (opts.scriptId) payload.script_id = opts.scriptId;

        if (opts.sceneId) payload.scene_id = opts.sceneId;

        if (opts.lineId) payload.line_id = opts.lineId;



        const res = await fetch(

          "/debug/stt_transcribe_chunk",

          withSecretHeaders({

            method: "POST",

            headers: { "Content-Type": "application/json" },

            body: JSON.stringify(payload)

          })

        );



        // Always try to return a payload so the overlay can show details.

        let data;

        try {

          data = await res.json();

        } catch (err) {

          console.error("[stt] failed to parse JSON", err);

          data = null;

        }



        if (!res.ok) {

          console.error("[stt] HTTP", res.status, data);

          return {

            ok: false,

            error: `http_${res.status}`,

            message: (data && data.message) || "Non-200 HTTP from /debug/stt_transcribe_chunk",

          };

        }



        if (!data || typeof data.ok !== "boolean") {

          console.warn("[stt] bad payload", data);

          return {

            ok: false,

            error: "bad_payload",

            message: "Missing or invalid { ok, text } in STT response",

          };

        }



        return data; // e.g. { ok: true, text, partial } or { ok: false, error, message }

      } catch (err) {

        console.error("[stt] sendSttChunkToServer failed", err);

        return null;

      }

    }

    async function callServerSttStub(opts = {}){

      const scriptId = opts.scriptId || opts.script_id || null;

      const sceneId  = opts.sceneId  || opts.scene_id  || null;

      const lineId   = opts.lineId   || opts.line_id   || null;

      const text     = typeof opts.text === "string" ? opts.text : "";

      const audioMs  = (typeof opts.audioMs === "number" && Number.isFinite(opts.audioMs))

        ? opts.audioMs

        : null;



      try{

        const res = await fetch(

          "/debug/stt",

          withSecretHeaders({

            method: "POST",

            headers: { "Content-Type":"application/json" },

            body: JSON.stringify({

              script_id: scriptId,

              scene_id:  sceneId,

              line_id:   lineId,

              text,

              audio_ms:  audioMs

            })

          })

        );

        if(!res.ok) throw new Error("stt_http_failed");

        const data = await res.json();

        if(!data || data.ok !== true) return null;

        return data; // { ok, script_id, scene_id, line_id, transcript, confidence, ... }

      }catch(err){

        console.error("[stt] stub failed", err);

        return null;

      }

    }

    async function getSession() {

      const res = await fetch("/auth/session", withSecretHeaders());

      if (!res.ok) throw new Error("session_fetch_failed");

      return await res.json();

    }

    // Returns a stable key for the currently signed-in user, or null if no user is signed in.

    function getSignedInUserKey() {

      const auth = (typeof S !== "undefined" && S) ? S.auth : null;

      if (!auth) return null;



      // Only treat the user as "signed in" when the auth/session says so.

      const isLoggedIn = !!(

        (auth.passkey && auth.passkey.loggedIn) ||

        (auth.dev && auth.dev.loggedIn) ||

        (auth.cookieSession && auth.cookieSession.loggedIn)

      );

      if (!isLoggedIn) return null;



      const user = auth.user;

      if (!user) return null;



      const id =

        user.id ||

        user.userId ||

        user.user_id ||

        user.email ||

        user.emailAddress ||

        null;



      return id ? `user:${id}` : null;

    }

      function openPaywall(message){

        const m = document.getElementById("paywallMsg");

        if (m && message) m.textContent = message;

        const pw = document.getElementById("paywall");

        pw?.classList.remove("ob-hidden");

        pw?.setAttribute("aria-hidden","false");

        document.body.classList.add("ob-modal-open");

      }

      function closePaywall(){

        const pw = document.getElementById("paywall");

        pw?.classList.add("ob-hidden");

        pw?.setAttribute("aria-hidden","true");

        document.body.classList.remove("ob-modal-open");

      }

      (function wirePaywallModal(){

        const btnClose = document.getElementById("paywallClose");

        const btnStartSub = document.getElementById("btnStartSub");

        const btnAddCredits = document.getElementById("btnAddCredits");



        function goToSettings(){

          closePaywall();

          try {

            showScreen("settings");

            const settings = document.getElementById("screen-settings");

            settings?.scrollIntoView({ behavior: "smooth", block: "start" });

          } catch {}

        }



        btnClose?.addEventListener("click", () => {

          closePaywall();

        });



        btnStartSub?.addEventListener("click", () => {

          goToSettings();

        });



        btnAddCredits?.addEventListener("click", () => {

          goToSettings();

        });

      })();

      async function hasEntitlementToRender(){

        const s = await getSession();

        const ent = s?.entitlement || {};

        const hasPlan = ent.plan && ent.plan !== "none";

        const quotaLeft = (ent.included_quota || 0) - (ent.renders_used || 0);

        const hasCredits = (ent.credits_available || 0) > 0;

        return Boolean(hasPlan || quotaLeft > 0 || hasCredits);

      }

      function guardMeteredButtons(){

        const targets = [

          document.getElementById("btnRehearseRender"),

          document.getElementById("btnRender"),

        ].filter(Boolean);



        for (const el of targets) {

          el.addEventListener("click", (e) => {

            // If this click has already been approved by the guard, let it pass.

            if (el.dataset.obGuardApproved === "1") {

              // Clear the flag so the next real click is checked again.

              delete el.dataset.obGuardApproved;

              return;

            }



            // Stop the original click immediately so the normal render handler

            // can't run until we've checked entitlements.

            e.stopImmediatePropagation();

            e.preventDefault();



            (async () => {

              try {

                const ok = await hasEntitlementToRender();

                if (!ok) {

                  openPaywall("Start a subscription or add credits to render.");

                  return;

                }



                // Mark this element as approved and fire a second synthetic click.

                // Our capture handler will see the flag and let it fall through.

                el.dataset.obGuardApproved = "1";

                const evt = new MouseEvent("click", {

                  bubbles: true,

                  cancelable: true,

                  view: window

                });

                el.dispatchEvent(evt);

              } catch {

                openPaywall("We couldn't verify your access. Please try again.");

              }

            })();

          }, { capture: true });

        }

      }

      function show(el, on) {

        if (el) el.style.display = on ? "" : "none";

      }

      function clearCurrentScriptView() {

        try {

          // Reset in-memory script state

          S.script_id = null;

          S.scenes = [];

          S.currentSceneIndex = 0;



          // Re-render Import editor in its empty state

          if (typeof hydrateImportEditor === "function") {

            hydrateImportEditor();

          }



          // Optionally clear any Import-specific status text

          const savedStatus = document.getElementById("savedScriptsStatus");

          if (savedStatus) {

            // Do not override a more specific message set by auth; just leave as-is.

            // savedStatus.textContent = savedStatus.textContent || "";

          }

        } catch (e) {

          console.warn("clearCurrentScriptView failed", e);

        }

      }

      // Hide legacy inline "Used: X • Credits: Y" line (old build).
      function hideLegacyCreditsInlineSummary() {
        const creditsCard = document.getElementById("proCreditCard");

        // Most robust: hide any element in Settings that *looks like* the old inline summary,
        // but isn't inside the new credits card.
        const settingsRoot =
          document.getElementById("tab-settings") ||
          document.getElementById("settings") ||
          document.body;

        const nodes = settingsRoot.querySelectorAll("div, p, span");
        for (const el of nodes) {
          if (creditsCard && creditsCard.contains(el)) continue;

          const t = (el.textContent || "").trim();
          // Matches: "Used: 5 • Credits: 100"
          if (/^Used:\s*\d+\s*[•·]\s*Credits:\s*\d+/i.test(t)) {
            el.style.display = "none";
            el.setAttribute("data-hidden-legacy-credits", "true");
          }
        }
      }

      async function refreshAuthUI() {

        try {

          const s = await getSession();

          if (typeof S !== "undefined") {

            S.auth = s;

            if (S.auth && !S.auth.user && (s?.userId || s?.user_id)) {

              S.auth.user = { id: s.userId || s.user_id };

            }

          }

          const inviteBlock = document.getElementById("inviteBlock");

          show(inviteBlock, Boolean(s?.hasInviteCode));



          const userIdEl = document.getElementById("settings-session-user-id");

          if (userIdEl) {

            const rawUserId =

              (s && s.userId) ||

              (s && s.user_id) ||

              (s && s.user && (s.user.id || s.user.email)) ||

              null;



            const isSignedIn = Boolean(rawUserId);



            // Fetch and render profile

            if (isSignedIn) {

              fetchAndRenderProfile(rawUserId);

            } else {

              userIdEl.textContent = "Not signed in.";

              const displayNameBlock = document.getElementById("profileDisplayNameBlock");

              if (displayNameBlock) displayNameBlock.style.display = "none";

            }



            // Optional: keep the raw ID available for debugging (not visible in UI)

            userIdEl.setAttribute("data-raw-user-id", rawUserId || "");

          }



          // Decide whether we're in dev view (also used for debugging output)

          const isDev = new URLSearchParams(location.search).has("dev");



          // Elements

          const authStatus = document.getElementById("authStatus");                 // debug <pre>

          const authStatusFriendly = document.getElementById("authStatusFriendly"); // human text



          // Friendly line

          if (authStatusFriendly) {

            let msg = "";

            if (s?.passkey?.loggedIn) {

              msg = "You're signed in with a passkey.";

            } else if (s?.hasInviteCode && !s?.invited) {

              msg = "Enter your access code to continue.";

            } else {

              msg = "";

            }

            authStatusFriendly.textContent = msg;

            authStatusFriendly.style.display = isDev ? "none" : "";

          }



          // Debug block: only when ?dev=1

          if (authStatus) {

            if (isDev) {

              const invitedTxt = s?.invited ? "yes" : "no";

              const passkeyTxt = s?.passkey?.registered ? (s?.passkey?.loggedIn ? "registered+logged-in" : "registered") : "none";

              authStatus.textContent =

                `Auth gate: ${s?.enforceAuthGate ? "ON" : "off"} · Invite set: ${s?.hasInviteCode ? "yes" : "no"} · Invited: ${invitedTxt}\n` +

                `Passkey: ${passkeyTxt} · userId: ${s?.userId ?? "—"}`;

              authStatus.style.display = "";

            } else {

              authStatus.style.display = "none";

            }

          }



          // --- Entitlement (read-only) ---

          const ent = s?.entitlement || {};

          const elEnt = document.getElementById("entitlementLine");

          if (elEnt) {

            const isSignedIn = Boolean(s?.passkey?.loggedIn);

            const used = Number.isFinite(ent.renders_used) ? ent.renders_used : 0;

            const credits = Number.isFinite(ent.credits_available) ? ent.credits_available : 0;



            if (!isSignedIn) {

              elEnt.textContent = "Not signed in. Sign in to see your credits.";

            } else {

              elEnt.textContent = `Used: ${used} • Credits: ${credits}`;

            }

            elEnt.style.display = "";

          }



          // Toggle visibility of saved scripts based on sign-in state

          const savedContainer = document.getElementById("savedScriptsContainer");

          const savedStatus = document.getElementById("savedScriptsStatus");

          const isSignedInForScripts = Boolean(s?.passkey?.loggedIn);



          if (savedContainer) {

            // Hide the whole "Your Scripts" block when signed out

            savedContainer.style.display = isSignedInForScripts ? "" : "none";

          }



          if (isSignedInForScripts) {

            // When signed IN: clear hint, reload scripts from server

            if (savedStatus) {

              savedStatus.textContent = "";

            }

            // Fetch and refresh saved scripts

            if (typeof fetchSavedScriptsFromServer === "function") {

              fetchSavedScriptsFromServer().catch(err => console.error("Failed to fetch saved scripts:", err));

            }

          } else {

            // When signed OUT: show hint, clear local list, clear UI

            if (savedStatus) {

              savedStatus.textContent = "Sign in to access your saved scripts.";

            }

            if (typeof S !== "undefined") {

              S.savedScripts = [];

            }

            if (typeof renderSavedScriptsStrip === "function") {

              renderSavedScriptsStrip();

            }

            if (typeof clearCurrentScriptView === "function") {

              clearCurrentScriptView();

            }

          }



          // Dev entitlement controls (Grant 200 test credits)

          const devBtns = document.getElementById("devEntButtons");

          if (devBtns) devBtns.style.display = isDev ? "" : "none";

          // Billing Admin panel (dev only)
          const billingAdminPanel = document.getElementById("billingAdminPanel");
          if (billingAdminPanel) billingAdminPanel.style.display = isDev ? "" : "none";



          // Settings → Add credits button state

          const btnAdd = document.getElementById("btnAddCreditsSettings");

          const addHint = document.getElementById("addCreditsHintSettings");

          const addToast = document.getElementById("addCreditsToastSettings");

          if (btnAdd && addHint && addToast) {

            const isSignedIn = Boolean(s?.passkey?.loggedIn);

            const canAdd = isSignedIn || isDev; // dev mode can always test checkout



            btnAdd.disabled = !canAdd;

            if (canAdd) {

              addHint.textContent = "Add credits opens a test checkout link in this build.";

            } else {

              addHint.textContent = "Sign in to add credits.";

            }

            // Hide any old toast until user taps the button again

            addToast.style.display = "none";

          }

          // Settings → Pro subscription buttons and status
          const btnGoProMonthly = document.getElementById("btnGoProMonthly");
          const btnManageSubscription = document.getElementById("btnManageSubscription");
          const proStatusLine = document.getElementById("proStatusLine");
          const proCreditCard = document.getElementById("proCreditCard");
          const proMonthlyRemaining = document.getElementById("proMonthlyRemaining");
          const proMonthlySub = document.getElementById("proMonthlySub");
          const topupBalance = document.getElementById("topupBalance");

          if (btnGoProMonthly && btnManageSubscription && proStatusLine) {
            const isSignedIn = Boolean(s?.passkey?.loggedIn);
            const plan = s?.entitlement?.plan || "none";
            const includedQuota = s?.entitlement?.included_quota || 0;
            const rendersUsed = s?.entitlement?.renders_used || 0;
            const creditsAvailable = s?.entitlement?.credits_available || 0;
            const periodEnd = s?.entitlement?.period_end;
            const subscriptionRemaining = s?.entitlement?.subscription_remaining ?? Math.max(0, includedQuota - rendersUsed);
            const topups = s?.entitlement?.topup_balance ?? creditsAvailable;

            if (!isSignedIn) {
              // Signed out: disable both buttons, hide card
              btnGoProMonthly.disabled = true;
              btnManageSubscription.disabled = true;
              btnGoProMonthly.style.display = "";
              btnManageSubscription.style.display = "none";
              if (proCreditCard) proCreditCard.style.display = "none";
              proStatusLine.style.display = "";
              proStatusLine.textContent = "Sign in to upgrade to Pro.";
            } else if (plan === "pro") {
              // Pro user: hide Go Pro, show Manage, show credit card
              btnGoProMonthly.style.display = "none";
              btnManageSubscription.style.display = "";
              btnManageSubscription.disabled = false;

              // Format renewal date (handle both unix seconds and ISO string)
              let renewalStr = "";
              if (periodEnd) {
                try {
                  let renewalDate;
                  if (typeof periodEnd === "number") {
                    renewalDate = new Date(periodEnd * 1000);
                  } else if (typeof periodEnd === "string") {
                    renewalDate = new Date(periodEnd);
                  }

                  if (renewalDate && !isNaN(renewalDate.getTime())) {
                    renewalStr = renewalDate.toISOString().split('T')[0]; // YYYY-MM-DD
                  } else {
                    renewalStr = "Unknown";
                  }
                } catch (e) {
                  renewalStr = "Unknown";
                }
              }

              // Show credit card with details
              if (proCreditCard) proCreditCard.style.display = "";
              proStatusLine.style.display = "none";

              if (proMonthlyRemaining) proMonthlyRemaining.textContent = String(subscriptionRemaining);
              if (proMonthlySub) proMonthlySub.textContent = `Used ${rendersUsed}/${includedQuota}${renewalStr ? ` • Renews ${renewalStr}` : ""}`;
              if (topupBalance) topupBalance.textContent = String(topups);
            } else {
              // Free user: show Go Pro, hide Manage, hide card
              btnGoProMonthly.style.display = "";
              btnManageSubscription.style.display = "none";
              btnGoProMonthly.disabled = false;
              if (proCreditCard) proCreditCard.style.display = "none";
              proStatusLine.style.display = "";
              proStatusLine.textContent = `Free • Credits: ${creditsAvailable}`;
            }
          }

          // Link Code sections visibility
          const linkDeviceSection = document.getElementById("linkDeviceSection");
          const claimLinkSection = document.getElementById("claimLinkSection");
          const isPasskeyLoggedIn = Boolean(s?.passkey?.loggedIn);

          if (linkDeviceSection) {
            linkDeviceSection.style.display = isPasskeyLoggedIn ? "" : "none";
          }

          // Refresh linked devices list
          try {
            const fn = window.refreshLinkedDevices;
            if (typeof fn === "function") fn().catch(() => {});
          } catch {}

          if (claimLinkSection) {
            claimLinkSection.style.display = !isPasskeyLoggedIn ? "" : "none";
          }



          if (typeof S !== "undefined") {

            try {

              setTimeout(() => {

                try {

                  loadTakes().catch((err) => {

                    console.warn("[offbook] gallery refresh failed", err);

                  });

                } catch (err) {

                  console.warn("[offbook] gallery refresh failed", err);

                }

              }, 0);

            } catch (err) {

              console.warn("[offbook] gallery refresh failed", err);

            }

          }

        } catch {

          // soft-fail; keep UI as-is

        }

        // Hide legacy credits line after updating entitlement UI
        hideLegacyCreditsInlineSummary();

      }

      (function wireInviteUI(){

        const btn = document.getElementById("btnSubmitInvite");

        if (btn) {

          btn.addEventListener("click", async () => {

            const input = document.getElementById("inviteCode");

            const code = (input?.value || "").trim();

            if (!code) { alert("Please enter your access code."); return; }

            try {

              const res = await fetch("/auth/enter-code", withSecretHeaders({

                method: "POST",

                headers: { "Content-Type": "application/json" },

                body: JSON.stringify({ code }),

              }));

              if (res.ok) {

                await refreshAuthUI();

                if (input) input.value = "";

              } else {

                const data = await res.json().catch(() => ({}));

                alert(data?.error === "invalid_code" ? "Invalid access code." : "Couldn't apply access code.");

              }

            } catch {

              alert("Network error while submitting code.");

            }

          });

        }



        const relink = document.getElementById("linkReenterCode");

        if (relink) {

          relink.addEventListener("click", (e) => {

            e.preventDefault();

            const blk = document.getElementById("inviteBlock");

            show(blk, true);

            document.getElementById("inviteCode")?.focus();

          });

        }

      })();

      // ---- WebAuthn helpers (no external libs) ----

      const b64uToBuf = (b64u) => {

        if (b64u instanceof ArrayBuffer) return b64u;

        if (b64u instanceof Uint8Array) return b64u.buffer;

        if (typeof b64u !== "string") throw new Error("Expected base64url string for WebAuthn field");

        const pad = "=".repeat((4 - (b64u.length % 4)) % 4);

        const b64 = (b64u.replace(/-/g, "+").replace(/_/g, "/") + pad);

        const str = atob(b64);

        const bytes = new Uint8Array(str.length);

        for (let i = 0; i < str.length; i++) bytes[i] = str.charCodeAt(i);

        return bytes.buffer;

      };

      const bufToB64u = (buf) => {

        const bytes = new Uint8Array(buf);

        let str = '';

        for (let i = 0; i < bytes.byteLength; i++) str += String.fromCharCode(bytes[i]);

        const b64 = btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/,'');

        return b64;

      };



      function transformRegOptions(optsIn) {

        const src = optsIn && optsIn.publicKey ? optsIn.publicKey : optsIn;

        if (!src || !src.challenge) { throw new Error("Registration options missing challenge"); }

        const o = { ...src };

        o.challenge = b64uToBuf(src.challenge);

        if (o.user && typeof o.user.id === "string") o.user = { ...o.user, id: b64uToBuf(o.user.id) };

        if (Array.isArray(o.excludeCredentials)) {

          o.excludeCredentials = o.excludeCredentials.map(c => ({ ...c, id: b64uToBuf(c.id) }));

        }

        return o;

      }

      function transformAuthOptions(optsIn) {

        const src = optsIn && optsIn.publicKey ? optsIn.publicKey : optsIn;

        if (!src || !src.challenge) { throw new Error("Authentication options missing challenge"); }

        const o = { ...src };

        o.challenge = b64uToBuf(src.challenge);

        if (Array.isArray(o.allowCredentials)) {

          o.allowCredentials = o.allowCredentials.map(c => ({ ...c, id: b64uToBuf(c.id) }));

        }

        return o;

      }

      function credToJSON(cred) {

        // Recursively convert ArrayBuffers in PublicKeyCredential to base64url for JSON

        const recurse = (x) => {

          if (x instanceof ArrayBuffer) return bufToB64u(x);

          if (Array.isArray(x)) return x.map(recurse);

          if (x && typeof x === 'object') {

            const out = {};

            for (const k of Object.keys(x)) out[k] = recurse(x[k]);

            return out;

          }

          return x;

        };

        return recurse(cred);

      }

      async function beginRegister() {

        let lastOpts = null;

        try {

          const accessCode = document.getElementById("inviteCode")?.value || "";

          const r1 = await fetch("/auth/begin-register", withSecretHeaders({

            method: "POST",

            headers: { "Content-Type":"application/json" },

            body: JSON.stringify({ accessCode })

          }));

          if (!r1.ok) { document.getElementById("authStatus").textContent = "Register: " + await r1.text(); return; }

          const opts = await r1.json();

          lastOpts = opts;

          const publicKey = transformRegOptions(opts);

          const attResp = await navigator.credentials.create({ publicKey });

          const payload = credToJSON(attResp);

          const r2 = await fetch("/auth/finish-register", withSecretHeaders({

            method: "POST",

            headers: { "Content-Type":"application/json" },

            body: JSON.stringify(payload)

          }));

          document.getElementById("authStatus").textContent = r2.ok ? "Passkey registered." : ("Register failed: " + await r2.text());

          refreshAuthUI();

        } catch (err) {

          const msg = (err && err.message) ? err.message : String(err);

          const statusEl = document.getElementById("authStatus");

          if (statusEl) statusEl.textContent = "Register error: " + msg;

          try {

            const txt = await (await fetch("/auth/session", withSecretHeaders())).text();

            void txt;

          } catch {}

          if (statusEl && /missing challenge/i.test(msg)) {

            const payloadObj = lastOpts && lastOpts.publicKey ? lastOpts.publicKey : lastOpts;

            const keys = payloadObj && typeof payloadObj === "object" ? Object.keys(payloadObj) : [];

            statusEl.textContent = msg + " · payload keys: " + JSON.stringify(keys);

          }

          console.error("beginRegister error", err);

        }

      }



      async function beginLogin() {

        let lastOpts = null;

        try {

          const r1 = await fetch("/auth/begin-login", withSecretHeaders({ method:"POST" }));

          if (!r1.ok) { document.getElementById("authStatus").textContent = "Login: " + await r1.text(); return; }

          const opts = await r1.json();

          lastOpts = opts;

          const publicKey = transformAuthOptions(opts);

          const assertion = await navigator.credentials.get({ publicKey });

          const payload = credToJSON(assertion);

          const r2 = await fetch("/auth/finish-login", withSecretHeaders({

            method:"POST",

            headers: { "Content-Type":"application/json" },

            body: JSON.stringify(payload)

          }));

          document.getElementById("authStatus").textContent = r2.ok ? "Signed in." : ("Login failed: " + await r2.text());

          if (r2.status === 401) { const t = document.getElementById("reauthTip"); if (t) t.style.display = "block"; }

          refreshAuthUI();

        } catch (err) {

          const msg = (err && err.message) ? err.message : String(err);

          const statusEl = document.getElementById("authStatus");

          if (statusEl) statusEl.textContent = "Login error: " + msg;

          try {

            const txt = await (await fetch("/auth/session", withSecretHeaders())).text();

            void txt;

          } catch {}

          if (statusEl && /missing challenge/i.test(msg)) {

            const payloadObj = lastOpts && lastOpts.publicKey ? lastOpts.publicKey : lastOpts;

            const keys = payloadObj && typeof payloadObj === "object" ? Object.keys(payloadObj) : [];

            statusEl.textContent = msg + " · payload keys: " + JSON.stringify(keys);

          }

          console.error("beginLogin error", err);

        }

      }



      async function signOut() {

        await fetch("/auth/logout", withSecretHeaders({ method:"POST" }));

        document.getElementById("authStatus").textContent = "Signed out.";

        refreshAuthUI();

      }



      // --- WebAuthn helpers (dev-friendly) -------------------------------------

      function bufToUrl(b){

        return btoa(String.fromCharCode(...new Uint8Array(b))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");

      }

      function urlToBuf(s){

        const n = s.replace(/-/g, "+").replace(/_/g, "/");

        const pad = "===".slice((n.length + 3) % 4);

        const bin = atob(n + pad);

        const bytes = new Uint8Array(bin.length);

        for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);

        return bytes.buffer;

      }

      async function startLoginFlow(){

        const r1 = await fetch("/auth/passkey/login/start", withSecretHeaders({ method:"POST" }));

        if(!r1.ok) throw new Error("login_start_failed");

        const { options } = await r1.json();

        options.challenge = urlToBuf(options.challenge);

        if (Array.isArray(options.allowCredentials)) {

          options.allowCredentials = options.allowCredentials.map(c => ({ ...c, id: urlToBuf(c.id) }));

        }

        const cred = await navigator.credentials.get({ publicKey: options });

        if(!cred) throw new Error("no_credential");

        const payload = {

          id: cred.id,

          type: cred.type,

          rawId: bufToUrl(cred.rawId),

          response: {

            clientDataJSON: bufToUrl(cred.response.clientDataJSON),

            authenticatorData: cred.response.authenticatorData ? bufToUrl(cred.response.authenticatorData) : undefined,

            signature: cred.response.signature ? bufToUrl(cred.response.signature) : undefined,

            userHandle: cred.response.userHandle ? bufToUrl(cred.response.userHandle) : undefined,

          }

        };

        const r2 = await fetch("/auth/passkey/login/finish", withSecretHeaders({

          method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(payload)

        }));

        if(!r2.ok) {
          const errData = await r2.json().catch(() => ({}));
          const errMsg = errData.error || "login_finish_failed";
          const errDetails = errData.expected && errData.got ? ` (expected: ${errData.expected}, got: ${errData.got})` : "";
          throw new Error(errMsg + errDetails);
        }

        return r2.json();

      }

      async function startRegisterFlow(){

        const r1 = await fetch("/auth/passkey/register/start", withSecretHeaders({ method:"POST" }));

        if(!r1.ok) throw new Error("register_start_failed");

        const { options } = await r1.json();

        options.challenge = urlToBuf(options.challenge);

        if (options.user && options.user.id) options.user.id = urlToBuf(options.user.id);

        if (Array.isArray(options.excludeCredentials)) {

          options.excludeCredentials = options.excludeCredentials.map(c => ({ ...c, id: urlToBuf(c.id) }));

        }

        const cred = await navigator.credentials.create({ publicKey: options });

        if(!cred) throw new Error("no_credential");

        const payload = {

          id: cred.id,

          type: cred.type,

          rawId: bufToUrl(cred.rawId),

          response: {

            clientDataJSON: bufToUrl(cred.response.clientDataJSON),

            attestationObject: cred.response.attestationObject ? bufToUrl(cred.response.attestationObject) : undefined,

          }

        };

        const r2 = await fetch("/auth/passkey/register/finish", withSecretHeaders({

          method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(payload)

        }));

        if(!r2.ok) {
          const errData = await r2.json().catch(() => ({}));
          const errMsg = errData.error || "register_finish_failed";
          const errDetails = errData.expected && errData.got ? ` (expected: ${errData.expected}, got: ${errData.got})` : "";
          throw new Error(errMsg + errDetails);
        }

        return r2.json();

      }



      // --- Gate controller (enforced = fully blocking) --------------------------

      async function maybeShowAuthGate(){

        const gate = document.getElementById("authGate");

        if (!gate) return;



        const main = document.querySelector("main");

        const tabbar = document.querySelector("nav.tabbar");

        const header = document.querySelector("header");

        const closeBtn = document.getElementById("authGateClose");



        try{

          const s = await getSession();

          const enforced = Boolean(s?.enforceAuthGate);

          const needsGate = enforced && !(s?.invited) && !(s?.passkey?.loggedIn);



          gate.classList.toggle("ob-hidden", !needsGate);

          gate.setAttribute("aria-hidden", String(!needsGate));

          document.body.classList.toggle("ob-modal-open", needsGate);



          if (needsGate) {

            if (closeBtn) closeBtn.style.display = "none";

            if (main)  { main.setAttribute("inert", "");  main.setAttribute("aria-hidden", "true"); }

            if (tabbar){ tabbar.setAttribute("inert", ""); tabbar.setAttribute("aria-hidden", "true"); }

            if (header){ header.setAttribute("inert", ""); header.setAttribute("aria-hidden", "true"); }

          } else {

            if (closeBtn) closeBtn.style.display = "";

            if (main)  { main.removeAttribute("inert");  main.removeAttribute("aria-hidden"); }

            if (tabbar){ tabbar.removeAttribute("inert"); tabbar.removeAttribute("aria-hidden"); }

            if (header){ header.removeAttribute("inert"); header.removeAttribute("aria-hidden"); }

          }

        } catch {

          gate.classList.add("ob-hidden");

          gate.setAttribute("aria-hidden", "true");

          document.body.classList.remove("ob-modal-open");

          if (main)  { main.removeAttribute("inert");  main.removeAttribute("aria-hidden"); }

          if (tabbar){ tabbar.removeAttribute("inert"); tabbar.removeAttribute("aria-hidden"); }

          if (header){ header.removeAttribute("inert"); header.removeAttribute("aria-hidden"); }

        }

      }



      function wireAuthGateUI(){

        const gate = document.getElementById("authGate");

        if (!gate) return;



        const btnPasskey = document.getElementById("authGatePasskey");

        const btnInvite  = document.getElementById("authGateInvite");

        const btnClose   = document.getElementById("authGateClose");



        btnPasskey?.addEventListener("click", async () => {

          try{

            await startLoginFlow().catch(async () => { await startRegisterFlow(); });

            await refreshAuthUI();

            await maybeShowAuthGate();

          } catch(err){

            alert("Passkey sign-in failed. You can try again or use an invite code.");

          }

        });



        btnInvite?.addEventListener("click", () => {

          const tabBtn = document.querySelector('nav [data-tab="settings"]');

          tabBtn?.click?.();

          const blk = document.getElementById("inviteBlock");

          if (blk) { blk.style.display = ""; document.getElementById("inviteCode")?.focus(); }

        });



        // Dev-only convenience: allow closing ONLY when not enforced

        btnClose?.addEventListener("click", async () => {

          try {

            const s = await getSession();

            if (s?.enforceAuthGate) {

              return;

            }

          } catch {}

          document.getElementById("authGate")?.classList.add("ob-hidden");

          document.body.classList.remove("ob-modal-open");

        });

      }



      const _origRefreshAuthUI = refreshAuthUI;

      refreshAuthUI = async function(){

        await _origRefreshAuthUI();

        await maybeShowAuthGate();

      };



      wireAuthGateUI();

      maybeShowAuthGate();



      // Profile display name functions

      async function fetchAndRenderProfile(userId) {

        const userIdEl = document.getElementById("settings-session-user-id");

        const displayNameBlock = document.getElementById("profileDisplayNameBlock");

        const displayNameInput = document.getElementById("profileDisplayNameInput");



        try {

          const res = await fetch("/api/profile", withSecretHeaders());

          const data = await res.json();



          const displayName = data.display_name || null;



          // Format short ID: pk_886d5e…b0a

          let shortId = "";

          if (userId && userId.startsWith("passkey:")) {

            const token = userId.substring(8); // Remove "passkey:" prefix

            if (token.length > 10) {

              const prefix = token.substring(0, 7);

              const suffix = token.substring(token.length - 3);

              shortId = `pk_${prefix}…${suffix}`;

            } else {

              shortId = `pk_${token}`;

            }

          }



          // Render sign-in status

          if (userIdEl) {

            if (displayName) {

              userIdEl.innerHTML = `Signed in as <strong>${displayName}</strong><br><span style="font-size:11px;color:var(--muted);">${shortId}</span>`;

            } else {

              userIdEl.innerHTML = `Signed in as <strong>${shortId}</strong>`;

            }

          }



          // Show display name input and populate it

          if (displayNameBlock) {

            displayNameBlock.style.display = "";

          }

          if (displayNameInput) {

            displayNameInput.value = displayName || "";

          }

        } catch (err) {

          console.error("Failed to fetch profile:", err);

          if (userIdEl) {

            userIdEl.textContent = "Signed in (profile error)";

          }

        }

      }



      function wireProfileSaveButton() {

        const btn = document.getElementById("btnSaveDisplayName");

        const input = document.getElementById("profileDisplayNameInput");



        if (!btn || !input) return;



        btn.addEventListener("click", async () => {

          const displayName = input.value.trim();



          try {

            const res = await fetch("/api/profile", withSecretHeaders({

              method: "POST",

              headers: { "Content-Type": "application/json" },

              body: JSON.stringify({ display_name: displayName }),

            }));



            if (!res.ok) {

              throw new Error("Failed to save display name");

            }



            // Refresh profile display

            await refreshAuthUI();

            alert("Display name saved.");

          } catch (err) {

            console.error("Failed to save display name:", err);

            alert("Failed to save display name. Please try again.");

          }

        });

      }



      function wireSettingsPasskeyButtons(){

        const btnReg = document.getElementById("btnRegisterPasskey");

        const btnIn  = document.getElementById("btnSignIn");

        const btnOut = document.getElementById("btnSignOut");



        if (btnReg) {

          btnReg.addEventListener("click", async () => {

            try {

              await startRegisterFlow();

              await refreshAuthUI();

              alert("Passkey registered.");

            } catch (e) {

              alert("Passkey registration failed. Try again or check Safari settings.");

            }

          });

        }



        if (btnIn) {

          btnIn.addEventListener("click", async () => {

            try {

              await startLoginFlow();

              await refreshAuthUI();

              alert("Signed in with passkey.");

            } catch (e) {

              alert("Passkey sign-in failed. If you don't have one yet, try Register Passkey.");

            }

          });

        }



        if (btnOut) {

          btnOut.addEventListener("click", async () => {

            try {

              await fetch("/auth/signout", withSecretHeaders({ method:"POST" }));

              // Clear link code errors on sign out
              const statusEl = document.getElementById("linkCodeStatus");
              if (statusEl) statusEl.textContent = "";

              await refreshAuthUI();

              alert("Signed out.");

            } catch (e) {

              alert("Sign out failed.");

            }

          });

        }

        async function refreshLinkedDevices() {
          const statusEl = document.getElementById("linkedDevicesStatus");
          const listEl = document.getElementById("linkedDevicesList");
          if (!statusEl || !listEl) return;

          // If not signed in, clear
          const sess = await getSession().catch(() => null);
          const rawUserId = sess?.userId || sess?.user_id || null;
          const passkeyLoggedIn = Boolean(
            sess?.passkey?.loggedIn ??
            sess?.passkeyLoggedIn ??
            sess?.loggedIn
          );

          if (!rawUserId || !passkeyLoggedIn) {
            statusEl.textContent = "";
            listEl.innerHTML = "";
            return;
          }

          statusEl.textContent = "Loading linked devices…";
          listEl.innerHTML = "";

          const resp = await fetch("/auth/devices", { credentials: "include" }).catch(() => null);
          if (!resp) {
            statusEl.textContent = "Could not load linked devices. Please try again.";
            return;
          }

          const data = await resp.json().catch(() => null);
          if (!data || !data.ok) {
            statusEl.textContent = "Could not load linked devices. Please try again.";
            return;
          }

          const devices = Array.isArray(data.devices) ? data.devices : [];
          const current = data.currentCredentialId || null;

          if (devices.length === 0) {
            statusEl.textContent = "No linked devices yet.";
            return;
          }

          statusEl.textContent = devices.length >= 2
            ? "Max devices linked (2). Revoke one to link another."
            : "";

          devices.forEach((d, idx) => {
            const isCurrent = current && d.credentialId === current;

            const row = document.createElement("div");
            row.style.display = "flex";
            row.style.alignItems = "center";
            row.style.justifyContent = "space-between";
            row.style.gap = "10px";
            row.style.padding = "10px 12px";
            row.style.border = "1px solid rgba(255,255,255,0.08)";
            row.style.borderRadius = "14px";
            row.style.background = "rgba(255,255,255,0.03)";

            const left = document.createElement("div");
            const created = d.createdAt ? new Date(d.createdAt) : null;
            const createdStr = created && !isNaN(created.getTime()) ? created.toLocaleString() : "";

            left.innerHTML = `
              <div style="font-weight:700;">${isCurrent ? "This device" : `Device ${idx + 1}`}</div>
              <div class="muted" style="margin-top:2px;">
                ${createdStr ? `Linked ${createdStr}` : ""}
              </div>
            `;

            const right = document.createElement("div");

            if (!isCurrent) {
              const btn = document.createElement("button");
              btn.className = "btn";
              btn.textContent = "Revoke";
              btn.onclick = async () => {
                if (!confirm("Revoke this device? It will be signed out.")) return;
                const rr = await fetch("/auth/devices/revoke", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  credentials: "include",
                  body: JSON.stringify({ credentialId: d.credentialId })
                }).catch(() => null);

                const jj = rr ? await rr.json().catch(() => null) : null;
                if (!rr || !jj || !jj.ok) {
                  alert("Failed to revoke device. Please try again.");
                  return;
                }
                await refreshLinkedDevices();
              };
              right.appendChild(btn);
            } else {
              const badge = document.createElement("div");
              badge.className = "muted";
              badge.textContent = "Active";
              right.appendChild(badge);
            }

            row.appendChild(left);
            row.appendChild(right);
            listEl.appendChild(row);
          });
        }

        // Expose to refreshAuthUI (avoid scope/ReferenceError)
        window.refreshLinkedDevices = refreshLinkedDevices;

        // Link Code handlers
        const btnGetLinkCode = document.getElementById("btnGetLinkCode");
        const btnClaimLinkCode = document.getElementById("btnClaimLinkCode");
        const linkCodeInput = document.getElementById("linkCodeInput");

        if (btnGetLinkCode) {
          btnGetLinkCode.addEventListener("click", async () => {
            try {
              const resp = await fetch("/auth/device-link/start", withSecretHeaders({ method: "POST" }));
              const data = await resp.json();

              if (!data.ok) {
                // Handle reauth_required error with friendly message
                if (data.error === "reauth_required") {
                  const statusEl = document.getElementById("getLinkCodeStatus") || document.getElementById("linkCodeStatus");
                  if (statusEl) {
                    statusEl.textContent = "For security, tap Sign In (Face ID) and then try Get Link Code again.";
                  }
                  return;
                }
                // Handle cooldown error with friendly message
                if (data.error === "cooldown" && data.retry_after_s) {
                  const statusEl = document.getElementById("getLinkCodeStatus");
                  if (statusEl) {
                    statusEl.textContent = `Please wait ${data.retry_after_s}s before generating another link code.`;
                  }
                  return;
                }
                // Other errors: show alert
                alert("Failed to generate link code: " + (data.error || "unknown error"));
                return;
              }

              const codeDisplay = document.getElementById("linkCodeText");
              const expiryDisplay = document.getElementById("linkCodeExpiry");
              const linkCodeDisplayDiv = document.getElementById("linkCodeDisplay");
              const statusEl = document.getElementById("getLinkCodeStatus");

              if (codeDisplay) codeDisplay.textContent = data.code;
              if (expiryDisplay) expiryDisplay.textContent = "Expires in 10 minutes";
              if (linkCodeDisplayDiv) linkCodeDisplayDiv.style.display = "";

              // Clear status when new code is generated
              if (statusEl) statusEl.textContent = "";

              // Clear any claim errors when new code is generated
              const claimStatusEl = document.getElementById("linkCodeStatus");
              if (claimStatusEl) claimStatusEl.textContent = "";
            } catch (err) {
              console.error("Failed to get link code:", err);
              alert("Failed to generate link code. Please try again.");
            }
          });
        }

        if (btnClaimLinkCode && linkCodeInput) {
          // Clear error when input changes
          linkCodeInput.addEventListener("input", () => {
            const statusEl = document.getElementById("linkCodeStatus");
            if (statusEl) statusEl.textContent = "";
          });

          btnClaimLinkCode.addEventListener("click", async () => {
            const code = linkCodeInput.value.trim().toUpperCase();
            const statusEl = document.getElementById("linkCodeStatus");

            if (!code) {
              if (statusEl) statusEl.textContent = "Please enter a link code.";
              return;
            }

            // Disable button during request
            btnClaimLinkCode.disabled = true;

            try {
              // Claim the code
              const claimResp = await fetch("/auth/device-link/claim", withSecretHeaders({
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ code })
              }));

              const claimData = await claimResp.json();

              if (!claimData.ok) {
                if (claimData.error === "code_already_used") {
                  if (statusEl) statusEl.textContent = "This code was already used. Generate a new link code on the signed-in device.";
                } else {
                  if (statusEl) statusEl.textContent = "Error: " + (claimData.error || "unknown error");
                }
                return;
              }

              // Check if account is already at max capacity (preflight)
              if (claimData?.count != null && claimData?.max != null && Number(claimData.count) >= Number(claimData.max)) {
                if (statusEl) statusEl.textContent = `Max devices used (${claimData.max}). This account can't link more devices.`;
                return;
              }

              // Code claimed successfully, now register passkey
              if (statusEl) statusEl.textContent = "Code accepted! Registering passkey...";

              await startRegisterFlow();
              await refreshAuthUI();
              await refreshLinkedDevices();

              alert("Successfully linked! You can now sign in on this device.");
              linkCodeInput.value = "";
              if (statusEl) statusEl.textContent = "";
            } catch (err) {
              console.error("Failed to claim link code:", err);
              // Show friendly message for device cap
              const errStr = String(err);
              if (errStr.includes("device_cap_reached")) {
                if (statusEl) statusEl.textContent = "This account is already linked to 2 devices. Revoke one device to link a new one.";
              } else if (errStr.includes("timed out or was not allowed") || errStr.includes("NotAllowedError")) {
                if (statusEl) statusEl.textContent = "Passkey request was cancelled or blocked. If you're linking a 3rd device, this account may already be full.";
              } else {
                // Show the actual error message for debugging
                const errMsg = err?.message || errStr;
                if (statusEl) statusEl.textContent = "Error: " + errMsg;
              }
            } finally {
              btnClaimLinkCode.disabled = false;
            }
          });
        }

      }

      function wireAddCreditsButton(){

        const btn = document.getElementById("btnAddCreditsSettings");

        const toast = document.getElementById("addCreditsToastSettings");

        if (!btn) return;



        btn.addEventListener("click", async function () {

          if (btn.disabled) return;

          if (!toast) return;



          clearTimeout(toast._t);

          toast.textContent = "Contacting billing (stub checkout)...";

          toast.style.display = "block";

          try {

            const resp = await fetch("/billing/create_checkout", withSecretHeaders({

              method: "POST",

              headers: { ...JSON_HDRS, "Accept": "application/json" },

              body: JSON.stringify({ planId: "credits-100" }),

            }));

            const data = await resp.json().catch(() => ({}));



          if (resp.ok && data && data.checkout_url) {

            const url = String(data.checkout_url);

            // Show the URL in the toast for a moment (debug-friendly)

            toast.textContent = "Opening checkout: " + url;

            toast.style.display = "block";

            try {

              window.location.href = url;

            } catch (e) {

              console.warn("redirect to checkout failed", e);

            }

          } else {

            const errMsg =

              (data && (data.error || data.message)) ||

              "Billing not configured yet. (Stripe test.)";

            toast.textContent = "Billing error: " + errMsg;

          }

          } catch (e) {

            console.warn("billing/create_checkout failed", e);

            toast.textContent = "Could not contact billing service.";

          }



          clearTimeout(toast._t);

          toast._t = setTimeout(() => {

            toast.style.display = "none";

          }, 5000);

        });

      }

      function wireProSubscriptionButtons() {
        const btnGoProMonthly = document.getElementById("btnGoProMonthly");
        const btnManageSubscription = document.getElementById("btnManageSubscription");
        const toast = document.getElementById("addCreditsToastSettings");

        if (btnGoProMonthly) {
          btnGoProMonthly.addEventListener("click", async function () {
            if (btnGoProMonthly.disabled) return;
            if (!toast) return;

            clearTimeout(toast._t);
            toast.textContent = "Creating Pro subscription checkout...";
            toast.style.display = "block";

            try {
              const resp = await fetch("/billing/create_checkout", withSecretHeaders({
                method: "POST",
                headers: { ...JSON_HDRS, "Accept": "application/json" },
                body: JSON.stringify({ planId: "pro-monthly" }),
              }));

              const data = await resp.json();

              if (data && data.ok && data.checkout_url) {
                toast.textContent = "Redirecting to Stripe checkout...";
                setTimeout(() => {
                  window.location.href = data.checkout_url;
                }, 500);
              } else {
                const errMsg = (data && (data.error || data.message)) || "Billing not configured yet.";
                toast.textContent = "Billing error: " + errMsg;
              }
            } catch (e) {
              console.warn("billing/create_checkout failed", e);
              toast.textContent = "Could not contact billing service.";
            }

            clearTimeout(toast._t);
            toast._t = setTimeout(() => {
              toast.style.display = "none";
            }, 5000);
          });
        }

        if (btnManageSubscription) {
          btnManageSubscription.addEventListener("click", async function () {
            if (btnManageSubscription.disabled) return;
            if (!toast) return;

            clearTimeout(toast._t);
            toast.textContent = "Opening subscription portal...";
            toast.style.display = "block";

            try {
              const resp = await fetch("/billing/create_portal", withSecretHeaders({
                method: "POST",
                headers: { ...JSON_HDRS, "Accept": "application/json" },
              }));

              const data = await resp.json();

              if (data && data.ok && data.url) {
                toast.textContent = "Redirecting to Stripe portal...";
                setTimeout(() => {
                  window.location.href = data.url;
                }, 500);
              } else {
                let errMsg = (data && (data.message || data.error)) || "No subscription found.";
                // Frontend safety net: ensure relink_required and "No such customer" always show friendly message
                if (data && data.error === "relink_required" && data.message) {
                  errMsg = data.message;
                } else if (/no such customer/i.test(errMsg || "")) {
                  errMsg = "This account was linked to a Stripe Test subscription. Please subscribe again to create a Live subscription.";
                }
                toast.textContent = "Portal error: " + errMsg;
              }
            } catch (e) {
              console.warn("billing/create_portal failed", e);
              toast.textContent = "Could not contact billing service.";
            }

            clearTimeout(toast._t);
            toast._t = setTimeout(() => {
              toast.style.display = "none";
            }, 5000);
          });
        }
      }

      wireSettingsPasskeyButtons();

      wireProfileSaveButton();

      wireAddCreditsButton();

      wireProSubscriptionButtons();

      guardMeteredButtons();

      (function wireDevEntitlement(){

        const btn = document.getElementById("btnDevGrantCredits");

        if (!btn) return;

        btn.addEventListener("click", async () => {

          try{

            const res = await fetch("/auth/dev/grant-credits?dev=1", withSecretHeaders({

              method:"POST",

              headers:{ "Content-Type":"application/json" },

              body: JSON.stringify({ amount: 200 })

            }));

            const data = await res.json().catch(()=> ({}));

            if (!res.ok || !data?.ok) throw new Error(data?.error || "failed");

            await refreshAuthUI();

            alert("Added 200 test credits.");

          } catch(e){

            alert("Could not grant credits (dev tools disabled?).");

          }

        });

      })();

      // Wire Billing Admin panel buttons
      (function wireBillingAdmin(){
        const btnReplay = document.getElementById("btnBillingReplayEvent");
        const btnRefresh = document.getElementById("btnBillingRefreshSession");
        const inputEventId = document.getElementById("billingReplayEventId");
        const output = document.getElementById("billingAdminOut");

        if (!btnReplay || !btnRefresh || !inputEventId || !output) return;

        btnReplay.addEventListener("click", async () => {
          const eventId = inputEventId.value.trim();
          if (!eventId) {
            output.textContent = "Error: Please enter an event ID (evt_...)";
            return;
          }

          try {
            const url = `/debug/billing/replay_event?event_id=${encodeURIComponent(eventId)}`;
            const res = await fetch(url, withSecretHeaders({ method: "GET" }));
            const data = await res.json().catch(() => ({}));

            output.textContent = JSON.stringify({ status: res.status, ...data }, null, 2);
          } catch (e) {
            output.textContent = `Error: ${e.message}`;
          }
        });

        btnRefresh.addEventListener("click", async () => {
          try {
            await refreshAuthUI();
            output.textContent = "Session refreshed";
          } catch (e) {
            output.textContent = `Error refreshing session: ${e.message}`;
          }
        });
      })();

    const $ = (s,r=document)=>r.querySelector(s);

    const $$ = (s,r=document)=>Array.from(r.querySelectorAll(s));

    // --- TDZ fix: declare R early so Safari doesn't throw before it's assigned ---

    let R = null;

      if(typeof window !== "undefined"){

        if(typeof window.__OB_BT_IN === "undefined") window.__OB_BT_IN = false;

        if(typeof window.__OB_MIC_STREAM === "undefined") window.__OB_MIC_STREAM = null;

        if(typeof window.__OB_MIC_TRACK === "undefined") window.__OB_MIC_TRACK = null;

        if(typeof window.__OB_AP === "undefined") window.__OB_AP = null;

        if(typeof window.isRecording === "undefined") window.isRecording = false;

        if(typeof window.__OB_STT2_RECORDER === "undefined") window.__OB_STT2_RECORDER = null;

        if(typeof window.__OB_STT2_LAST_BLOB === "undefined") window.__OB_STT2_LAST_BLOB = null;

      }

      // Reader element singleton (idempotent)

      window.__OB_READER_EL = window.__OB_READER_EL

        || document.querySelector('audio[data-reader]')

        || document.getElementById('readerAudio')

        || (function(){

             const a = document.createElement('audio');

             a.setAttribute('data-reader','1');

             a.preload = 'auto';

             a.crossOrigin = 'anonymous';

             a.style.display = 'none';

             document.body.appendChild(a);

             return a;

           })();



      async function ensureAudioContext() {

        try {

          if (!window.audioCtx || window.audioCtx.state === 'closed') {

            window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            try {

              window.audioCtx.addEventListener('statechange', () => {

                // If we’re suspended/interrupted after a background, require a user tap.

                if (window.audioCtx && (window.audioCtx.state === 'suspended' || window.audioCtx.state === 'interrupted')) {

                  window.__OB_NEEDS_UNLOCK = true;

                }

              });

            } catch {}

          }

          if (window.audioCtx.state === 'suspended') {

            try { await window.audioCtx.resume(); } catch { window.__OB_NEEDS_UNLOCK = true; }

          }

        } catch {}

        return window.audioCtx;

      }



      // TEMP DIAG: log AudioContext state right before countdown

      async function _diagAudioCtx(tag) {

        const st = window.audioCtx?.state;

        console.debug('[AUDIO]', tag, 'ctx=', st);

      }



      async function playTestBeep(ms=200) {

        try {

          const ctx = window.audioCtx || (window.audioCtx = new (window.AudioContext||window.webkitAudioContext)());

          if (ctx.state !== 'running') await ctx.resume();

          const o = ctx.createOscillator();

          const g = ctx.createGain();

          o.type = 'sine';

          o.frequency.value = 880;

          g.gain.setValueAtTime(0.0001, ctx.currentTime);

          g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.01);

          g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + ms/1000);

          o.connect(g).connect(ctx.destination);

          o.start();

          o.stop(ctx.currentTime + ms/1000);

        } catch (err) {

          console.debug('[AUDIO] playTestBeep error', err);

        }

      }



      // === UI NOTE ENGINE (retro-but-soothing) =====================================

      // Uses the global window.audioCtx so it never rides the Record mix

      const UINotes = (() => {

        if (window.__OB_UI_NOTES) return window.__OB_UI_NOTES;



        const STATE = {

          master: null,         // GainNode

          lastAt: 0,

          voices: new Set(),

          maxVoices: 4,

        };



        // Natural notes A–G (A4..G5 span, gentle)

        const NOTE_FREQS = [440.00, 493.88, 523.25, 587.33, 659.25, 698.46, 783.99]; // A4,B4,C5,D5,E5,F5,G5



        function hashToIndex(s) {

          s = String(s || "");

          let h = 0;

          for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;

          return h % NOTE_FREQS.length;

        }



        async function ctx() {

          const c = await (window.audioCtx ? Promise.resolve(window.audioCtx) : ensureAudioContext());

          if (c.state === "suspended") { try { await c.resume(); } catch {} }

          if (!STATE.master) {

            const g = c.createGain();

            g.gain.value = 0.08; // soft

            try { g.connect(c.destination); } catch {}

            STATE.master = g;

          } else {

            // If the destination changed (new context/destination), re-connect.

            try {

              // A no-op disconnect throws if already disconnected; guard.

              STATE.master.disconnect();

            } catch {}

            try { STATE.master.connect(c.destination); } catch {}

          }

          return window.audioCtx;

        }



        function playOnce(freq, durMs = 120) {

          if (STATE.voices.size >= STATE.maxVoices) return; // avoid pileup

          const c = window.audioCtx; if (!c || (c.state !== 'running' && c.state !== 'interactive')) return;

          const start = c.currentTime + 0.001;

          const dur = Math.max(0.06, Math.min(0.25, durMs / 1000));

          const stopAt = start + dur;



          const osc = c.createOscillator();

          // "Atari but soothing": blend square/triangle via waveshaper-lite

          osc.type = 'square';

          // slight, random detune for "never the same"

          const cents = (Math.random() * 8 - 4); // ±4 cents

          try { osc.detune.value = cents * 100; } catch {}

          osc.frequency.setValueAtTime(freq, start);



          const g = c.createGain();

          // gentle envelope

          g.gain.setValueAtTime(0.0001, start);

          g.gain.exponentialRampToValueAtTime(0.18, start + 0.012);

          // creamy lowpass to tame harshness

          const lp = c.createBiquadFilter();

          lp.type = 'lowpass';

          lp.frequency.setValueAtTime(Math.min(3200, freq * 3), start);



          g.gain.setValueAtTime(0.18, stopAt - 0.03);

          g.gain.exponentialRampToValueAtTime(0.0001, stopAt);



          osc.connect(lp);

          lp.connect(g);

          g.connect(STATE.master);



          osc.start(start);

          osc.stop(stopAt);



          const voice = { osc, g, lp };

          STATE.voices.add(voice);

          osc.onended = () => {

            try { osc.disconnect(); lp.disconnect(); g.disconnect(); } catch {}

            STATE.voices.delete(voice);

          };

        }



        async function pingFor(el, evtName = "click") {

          // Do not emit while actively recording; keeps takes clean

          try { if (typeof R !== "undefined" && R && R.recording) return; } catch {}

          const now = performance.now();

          if ((now - (STATE.lastAt || 0)) < 30) return;

          STATE.lastAt = now;

          // Heuristic: stable ID → stable note; otherwise use text/role

          const key =

            el?.id ||

            el?.getAttribute?.("data-act") ||

            el?.getAttribute?.("aria-controls") ||

            el?.textContent?.trim() ||

            evtName ||

            "btn";

          const idx = hashToIndex(key);

          const base = NOTE_FREQS[idx];

          await ctx();

          // slight random duration gives "never exactly the same"

          const durMs = 90 + Math.round(Math.random() * 50);

          playOnce(base, durMs);

        }



        window.__OB_UI_NOTES = { pingFor };

        return window.__OB_UI_NOTES;

      })();



      // === Reader restore state (idempotent) ======================================

      // Always resolve the *current* reader element (Rehearse or Record)

      function getReaderEl() {

        // Prefer the rehearse element if present during Rehearse

        const rehearseEl = (typeof E !== "undefined" && E && E.rehearseAudio) ? E.rehearseAudio : null;

        const recordEl   = document.getElementById('readerAudio');

        const el = rehearseEl || recordEl || window.__OB_READER_EL || null;

        if (el) window.__OB_READER_EL = el; // keep the singleton pointing at what we actually use

        return el;

      }

      if (typeof window.__OB_LAST_READER_URL === 'undefined') window.__OB_LAST_READER_URL = null;

      if (typeof window.__OB_NEEDS_UNLOCK === 'undefined') window.__OB_NEEDS_UNLOCK = false;

      const btnEnableAudio = document.getElementById('btnEnableAudio');



      function rememberReaderUrl(url) {

        if (url && typeof url === 'string') window.__OB_LAST_READER_URL = url;

      }



      async function kickReaderElement() {

        // Try both elements if they exist

        const candidates = [];

        const a = getReaderEl(); if (a) candidates.push(a);

        const rehearseEl = (typeof E !== "undefined" && E && E.rehearseAudio) ? E.rehearseAudio : null;

        const recordEl   = document.getElementById('readerAudio');

        if (rehearseEl && !candidates.includes(rehearseEl)) candidates.push(rehearseEl);

        if (recordEl && !candidates.includes(recordEl)) candidates.push(recordEl);



        for (const el of candidates) {

          try {

            el.pause();

            const url = window.__OB_LAST_READER_URL;

            el.removeAttribute('src');

            el.load();

            if (url) {

              el.src = url;

              rememberReaderUrl(url);

              el.load();

            }

          } catch (e) {

            console.debug('[AUDIO] kickReaderElement', e);

          }

        }

      }



      async function restoreAudioRoute(tag = 'restore') {

        try {

          // 1) Resume the global beep ctx (used by test pings / UI sounds)

          const ctx = await ensureAudioContext();

          if (ctx?.state === 'suspended') { try { await ctx.resume(); } catch {} }



          // 2) Resume the reader’s WebAudio graph if present (buffer playback path)

          try {

            if (typeof hasR === 'function' && hasR()) {

              try { await ensureReaderCtx(); } catch {}

              if (R.readerCtx?.state === 'suspended') { try { await R.readerCtx.resume(); } catch {} }



              // If our gain isn’t connected (e.g., after a prior mix graph), restore direct monitor

              if (R.readerCtx && R.readerGain && !R.readerDirectConnected) {

                try { restoreReaderDirectMonitor(); } catch {}

              }

            }

          } catch {}



          // 3) For HTMLMediaElement path, reattach src to rebind the output route

          await kickReaderElement();



          // 4) Warmup ping (binds route on some iOS versions)

          await playTestBeep(120);

        } catch (e) {

          console.debug('[AUDIO] restoreAudioRoute', tag, e);

        }

      }



      document.addEventListener('visibilitychange', async () => {

        if (!document.hidden) {

          // Coming back to foreground: always assume we may need a gesture to unlock.

          window.__OB_NEEDS_UNLOCK = true;

          if (typeof btnEnableAudio !== 'undefined' && btnEnableAudio) {

            btnEnableAudio.style.display = '';

          }

          console.debug('[AUDIO] visibility -> foreground');

          await restoreAudioRoute('visibility');

        }

      }, { passive: true });



      window.addEventListener('pageshow', async (ev) => {

        if (ev?.persisted === true || !document.hidden) {

          // Coming back from bfcache or foreground: mark audio dirty so next tap can unlock.

          window.__OB_NEEDS_UNLOCK = true;

          if (typeof btnEnableAudio !== 'undefined' && btnEnableAudio) {

            btnEnableAudio.style.display = '';

          }

          console.debug('[AUDIO] pageshow (bfcache or foreground)');

          await restoreAudioRoute('pageshow');

        }

      }, { passive: true });



      window.addEventListener('pageshow', async () => {

        try { if (typeof hasR === 'function' && hasR()) await ensureReaderCtx(); } catch {}

      });



      document.addEventListener('visibilitychange', async () => {

        if (!document.hidden) {

          try { if (typeof hasR === 'function' && hasR()) await ensureReaderCtx(); } catch {}

        }

      });



      async function tryUnlockAudio(from = 'tap') {

        try {

          const ctx = await ensureAudioContext();

          if (ctx && (ctx.state === 'suspended' || ctx.state === 'interrupted')) {

            try { await ctx.resume(); } catch {}

          }

          const _el = getReaderEl();

          if (_el && window.__OB_LAST_READER_URL) {

            await kickReaderElement();

            try { await _el.play(); } catch {}

          }

          window.__OB_NEEDS_UNLOCK = false;

          if (btnEnableAudio) btnEnableAudio.style.display = 'none';

        } catch (e) {

          console.debug('[AUDIO] tryUnlockAudio', from, e);

          window.__OB_NEEDS_UNLOCK = true;

          if (btnEnableAudio) btnEnableAudio.style.display = '';

        }

      }



      ['click', 'touchend'].forEach((ev) => {

        document.addEventListener(ev, () => {

          if (window.__OB_NEEDS_UNLOCK) tryUnlockAudio(ev);

        }, { passive: true });

      });



      if (btnEnableAudio) {

        btnEnableAudio.addEventListener('click', () => tryUnlockAudio('button'));

      }



      // --- Belt & suspenders guard (safe checks for the Record state object) ---

      const hasR = () => !!(typeof R !== "undefined" && R && typeof R === "object");

      // Tight mode when recording

      // For now, disable tight mode so Record uses the same timing as Rehearse.

      const tightMode = () => false;

      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform==='MacIntel' && navigator.maxTouchPoints>1);



      const mqlPortrait = window.matchMedia('(orientation: portrait)');

      const isPortrait = () => mqlPortrait.matches;

      const applyOrientationClasses = (event)=>{

        const portrait = event ? event.matches : isPortrait();

        document.body.classList.toggle('is-portrait', portrait);

        document.body.classList.toggle('is-landscape', !portrait);

        updateRecordLayout();

        try{ syncGridOverlayVisibility(); }catch{}

      };

      applyOrientationClasses();

      if(typeof mqlPortrait.addEventListener === 'function'){

        mqlPortrait.addEventListener('change', applyOrientationClasses);

      } else if(typeof mqlPortrait.addListener === 'function') {

        mqlPortrait.addListener(applyOrientationClasses);

      }



      const errbar=$("#errbar");

      const LOCKED_MSG = "Locked: add ?secret=YOUR_CODE to the URL or re-open your invite link.";

      function showErr(msg){

        if(!errbar) return;

        errbar.textContent=msg;

        errbar.classList.add("show");

        if(msg === LOCKED_MSG){ errbar.dataset.locked="1"; } else { errbar.removeAttribute("data-locked"); }

      }

      function showLocked(){ showErr(LOCKED_MSG); }

      function showBusy(msg){
        const el = document.getElementById("obBusy");
        const tx = document.getElementById("obBusyText");
        if (tx) tx.textContent = msg || "Working…";
        if (el) el.classList.remove("hidden");
      }

      function hideBusy(){
        const el = document.getElementById("obBusy");
        if (el) el.classList.add("hidden");
      }

      if(errbar){

        errbar.addEventListener("click", () => {

          errbar.classList.remove("show");

          errbar.removeAttribute("data-locked");

        });

      }



      // --- Screen Wake Lock to prevent auto-sleep during rehearse/record ---

      let wakeLock = null;

      async function acquireWakeLock(){

        try{

          if("wakeLock" in navigator && document.visibilityState === "visible"){

            wakeLock = await navigator.wakeLock.request("screen");

            wakeLock?.addEventListener?.("release", ()=>{ wakeLock=null; });

          }

        }catch{ /* ignore */ }

      }

      function releaseWakeLock(){ try{ wakeLock?.release(); }catch{} wakeLock=null; }

      document.addEventListener("visibilitychange", ()=>{

        const onActiveTab = document.querySelector(".tabbar button.active")?.dataset.tab;

        if(document.visibilityState === "visible" && (onActiveTab==="rehearse" || onActiveTab==="record")){

          acquireWakeLock();

        }else{

          releaseWakeLock();

        }

      });



      function showScreen(name){

  $$(".countdown").forEach(x=>x.classList.remove("show"));

  stopAllAudioHard();

        const prevTab = S?.activeTab || "import";

        if (prevTab === "import" && name !== "import" && typeof saveImportEdits === "function") {

          try {

            saveImportEdits();

          } catch (e) {

            console.warn("Auto-save from Import failed on tab change", e);

          }

        }

        try{

          if(name==="rehearse" || name==="record") acquireWakeLock();

          else releaseWakeLock();

        }catch{}

        if(name!=="record"){

          try{ if(R?.recording){ stopRecording(); } }catch{}

          try{ cleanupStream(); }catch{}

        }

        document.body.classList.toggle("record-active", name==="record");

        $$(".screen").forEach(s=>s.classList.remove("active"));

        $("#screen-"+name).classList.add("active");

        $$(".tabbar button").forEach(b=>b.classList.remove("active"));

        const btn=document.querySelector(`.tabbar button[data-tab="${name}"]`);

        if(btn) btn.classList.add("active");

        if (S) {

          S.activeTab = name;

        }

        // Refresh saved scripts when entering Import tab while signed in

        if (name === "import" && S?.auth?.passkey?.loggedIn) {

          if (typeof fetchSavedScriptsFromServer === "function") {

            fetchSavedScriptsFromServer().catch(err => console.error("Failed to refresh scripts on import tab:", err));

          }

        }

        if(name==="rehearse"){

          // Route inference on tab enter

          (async () => {

            try{

              const bt = await hasBluetoothInput();

              window.__OB_BT_IN = bt;

              logRouteCheck('tab:rehearse');

              if (window.__OB_MIC_TRACK && _route.isiOS && bt && looksLikeHfp(window.__OB_MIC_TRACK)) {

                _route.warnActive = true;

                maybeShowRouteModal();

              } else {

                showRouteWarn(false);

              }

            }catch{ showRouteWarn(false); }

          })();

          try{ primeReaderFromCacheIfAvailable(); }catch{}

        }else if(name==="record"){

          try{ updateRecordLayout(); }catch{}

          try{ syncGridOverlayVisibility(); }catch{}

          try{ primeReaderFromCacheIfAvailable(); }catch{}

          try{ requestMicPermissionOnce(); }catch{}

          try{ startPreviewIfNeeded(); }catch{}

          try{ setRailStates(); }catch{}

        }else if(name==="gallery"){

          loadTakes().catch(()=>{});

        }else if(name==="settings"){

          setTimeout(() => { try { refreshLinkedDevices(); } catch (e) {} }, 0);

        }

      }

      $$(".tabbar button").forEach(b=>b.addEventListener("click",()=>showScreen(b.dataset.tab)));



      // inner tabs

const tabText=$("#tab-text"), tabPdf=$("#tab-pdf"), panelText=$("#panel-text"), panelPdf=$("#panel-pdf");

      tabText?.addEventListener("click",()=>{ tabText.classList.add("active"); tabPdf.classList.remove("active"); panelText.hidden=false; panelPdf.hidden=true; });

      tabPdf?.addEventListener("click",()=>{ tabPdf.classList.add("active"); tabText.classList.remove("active"); panelPdf.hidden=false; panelText.hidden=true; });

const savedStrip = document.getElementById("savedScriptsStrip");

      if (savedStrip) {

        savedStrip.addEventListener("click", async (evt) => {

          const target = evt.target;

          const card =

            target && typeof target.closest === "function"

              ? target.closest(".saved-script-card")

              : null;

          if (!card) return;



          const id = card.dataset.scriptId;

          const status = document.getElementById("savedScriptsStatus");



          // --- New script card: show hint + SFX ---

          if (id === "__new__") {

            try { UINotes.pingFor(card, "saved-script-new"); } catch {}



            if (status) {

              status.textContent = "New script: use Paste Script Text or Upload PDF below.";

            }

            const textPanelVisible = panelText ? !panelText.hidden : true;

            if (textPanelVisible) {

              document.getElementById("titleText")?.focus();

            } else {

              document.getElementById("titlePdf")?.focus();

            }

            return;

          }



          // --- Existing saved script: load + SFX ---

          try { UINotes.pingFor(card, "saved-script"); } catch {}



          S.script_id = id;

          const meta = S.savedScripts.find((s) => s.id === id) || null;

          if (status) {

            status.textContent = meta

              ? `Loading: ${meta.title}…`

              : "Loading saved script…";

          }

          try {

            await loadScenes();

            if (status) {

              const count =

                meta && typeof meta.sceneCount === "number"

                  ? meta.sceneCount

                  : (S.scenes?.length || 0);

              const countLabel =

                count > 0

                  ? `${count} scene${count === 1 ? "" : "s"}`

                  : "Scenes not loaded";

              status.textContent = meta

                ? `${meta.title} • ${countLabel}`

                : countLabel;

            }

          } catch (_) {

            if (status) status.textContent = "Couldn’t load saved script.";

          }

        });

      document.addEventListener("click",(evt)=>{

        const target = evt.target;

        if(!target || typeof target.closest !== "function") return;

        const chip = target.closest(".import-scene-chip");

        if(!chip) return;

        const idxStr = chip.dataset.sceneIndex;

        if(typeof idxStr !== "string") return;

        const idx = parseInt(idxStr,10);

        if(Number.isNaN(idx)) return;

        if(idx < 0 || idx >= (S.scenes?.length || 0)) return;

        S.currentSceneIndex = idx;

        hydrateImportEditor();

      });

      const saveEditsBtn=document.getElementById("importSaveEdits");

      if(saveEditsBtn){

        saveEditsBtn.addEventListener("click",()=>{ saveImportEdits(); });

      }

      }

      const goAssignBtn=document.getElementById("importGoAssign");

      if(goAssignBtn){

        goAssignBtn.addEventListener("click",()=>{

          if(!S.script_id){

            const status=document.getElementById("savedScriptsStatus");

            if(status){

              status.textContent="Import or select a script first.";

            }

            return;

          }

          showScreen("assign");

        });

      }



      // state

      const S = {

        script_id: "",

        scenes: [],

        role: "",

        voice_map: {},

        editMode: false,

        supportedVoices: OPENAI_VOICES.slice(),

        savedScripts: [],

        currentSceneIndex: 0,

        activeTab: "import",

        auth: null,

        galleryTakes: []

      };

      // savedScripts: { id: string; title: string; sceneCount: number; createdAt: number; updatedAt: number }[]

      if (typeof window !== "undefined") window.currentSceneId = S.script_id || null;



        // Load saved script metadata from this device

        loadSavedScriptsFromStorage();

        renderSavedScriptsStrip();

        updateImportPersistenceDebug();

        // Restore last Assign selection for Record tab Render
        if(!S.script_id || !S.role){
          try{
            const stored = localStorage.getItem("offbook:last_assign");
            if(stored){
              const parsed = JSON.parse(stored);
              if(parsed.script_id && !S.script_id) S.script_id = parsed.script_id;
              if(parsed.role && !S.role) S.role = parsed.role;
            }
          }catch{}
        }



        // Debug + UX: show how many saved scripts we see on this device

        const savedStatus = document.getElementById("savedScriptsStatus");

      if (savedStatus && !savedStatus.textContent) {

        const count = Array.isArray(S.savedScripts) ? S.savedScripts.length : 0;

        if (count > 0) {

          savedStatus.textContent = `This device has ${count} saved script${count === 1 ? "" : "s"}.`;

        } else {

          savedStatus.textContent = "No saved scripts on this device yet.";

        }

      }



        // Then, if possible, refresh from the server (account-level scripts).

        if (typeof fetchSavedScriptsFromServer === "function") {

          try { fetchSavedScriptsFromServer(); } catch (e) { console.warn(e); }

        }



      // On startup, auto-restore the most recently used script (if any)

      (async () => {

        // Only auto-load if we don't already have an active script

        if (!S.script_id && Array.isArray(S.savedScripts) && S.savedScripts.length > 0) {

          const last = S.savedScripts

            .slice()

            .sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0))[0];



          if (last && last.id) {

            S.script_id = last.id;



            const status = document.getElementById("savedScriptsStatus");

            if (status) {

              status.textContent = `Loading: ${last.title || "Sides"}…`;

            }



            try {

              await loadScenes();



              if (status) {

                const count = typeof last.sceneCount === "number"

                  ? last.sceneCount

                  : (S.scenes?.length || 0);

                const label = count > 0

                  ? `${count} scene${count === 1 ? "" : "s"}`

                  : "Scenes not loaded";

                status.textContent = `Loaded: ${last.title || "Sides"} • ${label}`;

              }

            } catch (e) {

              console.warn("Auto-load last saved script failed", e);

              // Fall back to a neutral viewer state

              try { hydrateImportEditor(); } catch {}

            }



            return; // Don’t call hydrateImportEditor() again; loadScenes already did it

          }

        }



        // No saved scripts, or nothing to auto-load → show empty state

        try { hydrateImportEditor(); } catch {}

      })();



      refreshAuthUI();



        // helpers

        const setStatus = msg => $("#status").textContent = msg || "";

        const setStatusPdf = msg => $("#statusPdf").textContent = msg || "";

        function hasDebugPersistFlag() {

          try {

            const params = new URLSearchParams(window.location.search || "");

            return params.has("debug_persist");

          } catch {

            return false;

          }

        }

        const SAVED_SCRIPTS_META_KEY = "offbook_saved_scripts_v1";

        const SAVED_SCRIPTS_KEY = SAVED_SCRIPTS_META_KEY; // backward compat

        const SAVED_SCRIPTS_PAYLOAD_KEY = "offbook_saved_script_payloads_v1";



      function loadSavedScriptsFromStorage() {

        try {

          const raw = localStorage.getItem(SAVED_SCRIPTS_META_KEY);

          if (!raw) {

            S.savedScripts = [];

            return;

          }

          const parsed = JSON.parse(raw);

          if (Array.isArray(parsed)) {

            S.savedScripts = parsed;

          } else {

            S.savedScripts = [];

          }

        } catch (e) {

          S.savedScripts = [];

          try {

            console.warn("Saved scripts unavailable:", e);

          } catch (_) {}

        }

      }



      async function fetchSavedScriptsFromServer() {

        try {

          const res = await fetch(
            "/api/my_scripts",
            withSecretHeaders({
              method: "GET",
              credentials: "include",
              headers: { ...JSON_HDRS },
            })
          );

          if (handleUnauthorized(res)) return;

          if (!res.ok) {

            console.warn("fetchSavedScriptsFromServer: non-OK status", res.status);

            return;

          }



          const data = await res.json();

          const list = Array.isArray(data?.scripts) ? data.scripts : [];



          // If server returns 0 scripts, clear local stale scripts

          if (!list.length) {

            S.savedScripts = [];

            if (typeof saveSavedScriptsToStorage === "function") {

              try {

                saveSavedScriptsToStorage();

              } catch (e) {

                console.warn(e);

              }

            }

            const savedStatus = document.getElementById("savedScriptsStatus");

            if (savedStatus) {

              savedStatus.textContent = "No scripts found for this account.";

            }

            if (typeof renderSavedScriptsStrip === "function") {

              try {

                renderSavedScriptsStrip();

              } catch (e) {

                console.warn(e);

              }

            }

            return;

          }



          // Normalize server rows into a standard meta shape.

          const serverMapped = list.map((row) => {

            const updatedRaw = row.updatedAt || row.updated_at || null;

            const updatedTs = updatedRaw ? Date.parse(updatedRaw) : Date.now();

            return {

              id: row.id,

              title: row.title || "Sides",

              sceneCount:

                typeof row.sceneCount === "number"

                  ? row.sceneCount

                  : typeof row.scene_count === "number"

                  ? row.scene_count

                  : 0,

              createdAt: updatedTs,

              updatedAt: updatedTs,

            };

          });



          const existing = Array.isArray(S.savedScripts) ? S.savedScripts : [];

          const byId = new Map();



          // Only include server scripts (not local-only extras)

          for (const serverMeta of serverMapped) {

            if (!serverMeta || !serverMeta.id) continue;

            byId.set(serverMeta.id, serverMeta);

          }



          // Merge local title edits if available

          for (const localMeta of existing) {

            if (!localMeta || !localMeta.id) continue;

            const serverMeta = byId.get(localMeta.id);

            if (!serverMeta) continue; // Skip local-only scripts



            const localTitle =

              typeof localMeta.title === "string" && localMeta.title.trim()

                ? localMeta.title.trim()

                : "";

            const serverTitle =

              typeof serverMeta.title === "string" && serverMeta.title.trim()

                ? serverMeta.title.trim()

                : "Sides";



            serverMeta.title = localTitle || serverTitle;



            // Keep the freshest updatedAt

            const localUpdated =

              typeof localMeta.updatedAt === "number" ? localMeta.updatedAt : 0;

            const serverUpdated =

              typeof serverMeta.updatedAt === "number" ? serverMeta.updatedAt : 0;

            serverMeta.updatedAt = Math.max(localUpdated, serverUpdated);

          }



          const mergedList = Array.from(byId.values()).sort(

            (a, b) => (b.updatedAt || 0) - (a.updatedAt || 0)

          );



          S.savedScripts = mergedList;



          // Persist merged list as cache.

          if (typeof saveSavedScriptsToStorage === "function") {

            try {

              saveSavedScriptsToStorage();

            } catch (e) {

              console.warn(e);

            }

          }



          if (typeof renderSavedScriptsStrip === "function") {

            try {

              renderSavedScriptsStrip();

            } catch (e) {

              console.warn(e);

            }

          }



          // Update the status line to reflect server-backed scripts.

          const savedStatus = document.getElementById("savedScriptsStatus");

          if (savedStatus) {

            const count = mergedList.length;

            savedStatus.textContent =

              count > 0

                ? `Loaded ${count} script${count === 1 ? "" : "s"} from your account.`

                : savedStatus.textContent || "";

          }

        } catch (e) {

          console.warn("fetchSavedScriptsFromServer: failed", e);

        }

      }



      async function deleteScriptOnServer(id) {

        if (!id) return;

        try {

          const res = await fetch(`/api/scripts/${encodeURIComponent(id)}`, {

            method: "DELETE",

            credentials: "include",

          });

          if (!res.ok) {

            console.warn("deleteScriptOnServer: non-OK status", res.status);

          }

        } catch (e) {

          console.warn("deleteScriptOnServer: failed", e);

        }

      }



      async function saveScriptEditsToServer(scriptId, title, scenes) {

        if (!scriptId) return;

        try {

          const payload = {

            scenes: Array.isArray(scenes) ? scenes : [],

          };

          if (typeof title === "string") {

            const trimmed = title.trim();

            if (trimmed) {

              payload.title = trimmed;

            }

          }



          const res = await fetch(`/api/scripts/${encodeURIComponent(scriptId)}/save`, {

            method: "POST",

            credentials: "include",

            headers: {

              "Content-Type": "application/json",

            },

            body: JSON.stringify(payload),

          });



          if (!res.ok) {

            console.warn("saveScriptEditsToServer: non-OK status", res.status);

          }

        } catch (e) {

          console.warn("saveScriptEditsToServer: failed", e);

        }

      }



        function getSavedScriptPayloadsFromStorage() {

          try {

            const raw = localStorage.getItem(SAVED_SCRIPTS_PAYLOAD_KEY);

            if (!raw) return {};

            const parsed = JSON.parse(raw);

            return parsed && typeof parsed === "object" ? parsed : {};

          } catch (e) {

            console.warn("Failed to read saved script payloads", e);

            return {};

          }

        }



        function updateImportPersistenceDebug() {

          if (!hasDebugPersistFlag()) return;

          const el = document.getElementById("importPersistenceDebug");

          if (!el) return;



          try {

            const meta = Array.isArray(S.savedScripts) ? S.savedScripts : [];

            const payloads = getSavedScriptPayloadsFromStorage();

            const activeId = S.script_id || "(none)";

            const activeMeta = meta.find(m => m.id === S.script_id) || null;

            const activeTitle = activeMeta?.title || "";

            const activeScenes = Array.isArray(S.scenes) ? S.scenes.length : 0;



            const metaCount = meta.length;

            const payloadKeys = payloads ? Object.keys(payloads).length : 0;



            el.textContent =

              `Debug (this device): meta=${metaCount}, payloads=${payloadKeys}, ` +

              `activeId=${activeId}` +

              (activeTitle ? ` ("${activeTitle}")` : "") +

              `, scenes=${activeScenes}`;



            try {

              console.log("[OffBook] persistenceDebug", {

                metaCount,

                payloadKeys,

                activeId,

                activeTitle,

                activeScenes

              });

            } catch {}

          } catch (e) {

            el.textContent = "Debug: error reading persistence.";

          }

        }



        function saveSavedScriptPayloadsToStorage(map) {

          try {

            localStorage.setItem(SAVED_SCRIPTS_PAYLOAD_KEY, JSON.stringify(map || {}));

          } catch (e) {

            console.warn("Failed to persist saved script payloads", e);

        }

      }



      function persistCurrentScriptScenesToStorage() {

        if (!S.script_id || !Array.isArray(S.scenes)) return;



        const payloads = getSavedScriptPayloadsFromStorage() || {};



        // Try to get the best current title for this script

        let title = "";

        const meta = Array.isArray(S.savedScripts)

          ? S.savedScripts.find(s => s.id === S.script_id)

          : null;

        if (meta && typeof meta.title === "string" && meta.title.trim()) {

          title = meta.title.trim();

        } else {

          // Fallback: read from the active Import title input

          const panelText = document.getElementById("panelText");

          const panelPdf = document.getElementById("panelPdf");

          let titleInput = null;

          if (panelText && !panelText.hasAttribute("hidden")) {

            titleInput = document.getElementById("titleText");

          } else if (panelPdf && !panelPdf.hasAttribute("hidden")) {

            titleInput = document.getElementById("titlePdf");

          }

          if (titleInput && typeof titleInput.value === "string" && titleInput.value.trim()) {

            title = titleInput.value.trim();

          }

        }



        const nextPayload = {

          scenes: S.scenes,

          updatedAt: Date.now()

        };

        if (title) {

          nextPayload.title = title;

        }



        payloads[S.script_id] = nextPayload;



        try {

          localStorage.setItem(SAVED_SCRIPTS_PAYLOAD_KEY, JSON.stringify(payloads));

        } catch (_) {

          // best-effort; if storage fails we just don't persist

        }

      }



        function saveSavedScriptsToStorage() {

          try {

            localStorage.setItem(SAVED_SCRIPTS_META_KEY, JSON.stringify(S.savedScripts));

        } catch (e) {

          const status = document.getElementById("savedScriptsStatus");

          if (status) {

            status.textContent = "Could not save scripts (storage full?).";

          }

        }



        // Trim stored payloads to match existing script ids (cap stays in sync)

        const ids = new Set((S.savedScripts || []).map(s => s.id));

        const payloads = getSavedScriptPayloadsFromStorage();

        const nextPayloads = {};

          Object.keys(payloads || {}).forEach(id => {

            if (ids.has(id)) {

              nextPayloads[id] = payloads[id];

            }

          });

          saveSavedScriptPayloadsToStorage(nextPayloads);

          updateImportPersistenceDebug();

        }



        function deleteSavedScriptById(id) {

          if (!id) return;



        const before = Array.isArray(S.savedScripts) ? S.savedScripts : [];

        const after = before.filter(s => s.id !== id);

        S.savedScripts = after;



        try {

          saveSavedScriptsToStorage();

        } catch (e) {

          console.warn("Failed to persist saved scripts after delete", e);

        }



        // Also remove stored scenes for this script

        const payloads = getSavedScriptPayloadsFromStorage();

        if (payloads[id]) {

          delete payloads[id];

          saveSavedScriptPayloadsToStorage(payloads);

        }



        const wasActive = S.script_id === id;

        if (wasActive) {

          S.script_id = null;

          S.scenes = [];

          S.currentSceneIndex = 0;



          if (typeof hydrateImportEditor === "function") {

            try { hydrateImportEditor(); } catch (e) { console.warn(e); }

          }

          if (typeof hydrateAssign === "function") {

            try { hydrateAssign(); } catch (e) { console.warn(e); }

          }

          if (typeof hydrateRehearse === "function") {

            try { hydrateRehearse(); } catch (e) { console.warn(e); }

          }

        }



        if (typeof renderSavedScriptsStrip === "function") {

          try { renderSavedScriptsStrip(); } catch (e) { console.warn(e); }

        }



        deleteScriptOnServer(id);

      }



      function showSavedScriptDeleteConfirm(id, title) {

        if (!id) return;



        // Clear any focused/active element so its visual highlight doesn't "stick"

        const active = document.activeElement;

        if (active && typeof active.blur === "function") {

          try { active.blur(); } catch (e) { /* ignore */ }

        }



        const existing = document.getElementById("savedScriptDeleteConfirm");

        if (existing) existing.remove();



        const overlay = document.createElement("div");

        overlay.id = "savedScriptDeleteConfirm";

        overlay.className = "saved-script-confirm-overlay";



        const dialog = document.createElement("div");

        dialog.className = "saved-script-confirm-dialog";



        const heading = document.createElement("div");

        heading.className = "saved-script-confirm-title";

        heading.textContent = "Delete script?";



        const message = document.createElement("div");

        message.className = "saved-script-confirm-text";

        message.textContent = title

          ? `Remove "${title}" from this device?`

          : "Remove this script from this device?";



        const buttons = document.createElement("div");

        buttons.className = "saved-script-confirm-buttons";



        const deleteBtn = document.createElement("button");

        deleteBtn.type = "button";

        deleteBtn.className = "btn danger sm";

        deleteBtn.textContent = "Delete";



        const cancelBtn = document.createElement("button");

        cancelBtn.type = "button";

        cancelBtn.className = "btn ghost sm";

        cancelBtn.textContent = "Cancel";



        deleteBtn.addEventListener("click", (ev) => {

          ev.stopPropagation();

          deleteSavedScriptById(id);

          overlay.remove();

        });



        cancelBtn.addEventListener("click", (ev) => {

          ev.stopPropagation();

          overlay.remove();

        });



        buttons.appendChild(deleteBtn);

        buttons.appendChild(cancelBtn);

        dialog.appendChild(heading);

        dialog.appendChild(message);

        dialog.appendChild(buttons);

        overlay.appendChild(dialog);



        overlay.addEventListener("click", (ev) => {

          if (ev.target === overlay) {

            overlay.remove();

          }

        });



        document.body.appendChild(overlay);

      }



      function upsertSavedScriptMeta(scriptId, title, sceneCount) {

        const now = Date.now();

        let existing = S.savedScripts.find(s => s.id === scriptId);

        if (existing) {

          existing.title = title || existing.title;

          if (typeof sceneCount === "number") {

            existing.sceneCount = sceneCount;

          }

          existing.updatedAt = now;

        } else {

          const meta = {

            id: scriptId,

            title: title || "Sides",

            sceneCount: typeof sceneCount === "number" ? sceneCount : 0,

            createdAt: now,

            updatedAt: now

          };

          S.savedScripts.push(meta);

          if (S.savedScripts.length > 10) {

            S.savedScripts.sort((a, b) => a.createdAt - b.createdAt);

            S.savedScripts = S.savedScripts.slice(-10);

          }

        }

        saveSavedScriptsToStorage();

        renderSavedScriptsStrip();

        hydrateImportEditor();

      }



      function renderSavedScriptsStrip() {

        const strip = document.getElementById("savedScriptsStrip");

        if (!strip) return;



        strip.innerHTML = "";



        const status = document.getElementById("savedScriptsStatus");



        const newCard = document.createElement("div");

        newCard.className = "saved-script-card saved-script-new";

        newCard.dataset.scriptId = "__new__";

        newCard.textContent = "+ New Script";

        newCard.addEventListener("click", (ev) => {

          ev.preventDefault();

          ev.stopPropagation();



          // 🔊 Play normal click SFX for "+ New Script"

          try { UINotes.pingFor(newCard, "click"); } catch {}



          // Reset current script state

          S.script_id = null;

          S.scenes = [];

          S.currentSceneIndex = 0;



          // Clear import fields

          const titleText = document.getElementById("titleText");

          const scriptText = document.getElementById("scriptText");

          const titlePdf = document.getElementById("titlePdf");

          const pdfInput = document.getElementById("pdfFile");



          if (titleText) titleText.value = "";

          if (scriptText) scriptText.value = "";

          if (titlePdf) titlePdf.value = "";

          if (pdfInput) pdfInput.value = "";



          // Status nudge

          if (status) {

            status.textContent = "New script: use Paste Script Text or Upload PDF below.";

          }



          // Rehydrate views

          if (typeof hydrateImportEditor === "function") {

            try { hydrateImportEditor(); } catch (e) { console.warn(e); }

          }

          if (typeof hydrateAssign === "function") {

            try { hydrateAssign(); } catch (e) { console.warn(e); }

          }

          if (typeof hydrateRehearse === "function") {

            try { hydrateRehearse(); } catch (e) { console.warn(e); }

          }



          // Focus current tab title input

          const textPanelVisible = panelText ? !panelText.hidden : true;

          if (textPanelVisible) {

            document.getElementById("titleText")?.focus();

          } else {

            document.getElementById("titlePdf")?.focus();

          }

        });

        strip.appendChild(newCard);



        S.savedScripts

          .slice()

          .sort((a, b) => b.updatedAt - a.updatedAt)

          .forEach(meta => {

            const card = document.createElement("div");

            card.className = "saved-script-card";

            card.dataset.scriptId = meta.id;



            const title = document.createElement("div");

            title.className = "script-title";

            title.textContent = meta.title || "Sides";



            const metaLine = document.createElement("div");

            metaLine.className = "script-meta";

            const count = typeof meta.sceneCount === "number" ? meta.sceneCount : 0;

            metaLine.textContent = count > 0 ? `${count} scene${count === 1 ? "" : "s"}` : "Scenes not loaded";



            card.appendChild(title);

            card.appendChild(metaLine);



            let longPressTimer = null;

            let longPressTriggered = false;

            const holdMs = 700;



            card.addEventListener("pointerdown", () => {

              longPressTriggered = false;

              if (longPressTimer) {

                clearTimeout(longPressTimer);

                longPressTimer = null;

              }

              longPressTimer = window.setTimeout(() => {

                longPressTriggered = true;

                longPressTimer = null;

                showSavedScriptDeleteConfirm(meta.id, meta.title);

              }, holdMs);

            });



            ["pointerup", "pointerleave", "pointercancel"].forEach(eventName => {

              card.addEventListener(eventName, () => {

                if (longPressTimer) {

                  clearTimeout(longPressTimer);

                  longPressTimer = null;

                }

              });

            });



            card.addEventListener("click", async (ev) => {

              if (longPressTriggered) {

                ev.preventDefault();

                return;

              }



              try { UINotes.pingFor(card, "saved-script"); } catch {}



              S.script_id = meta.id;

              const metaRef = S.savedScripts.find(s => s.id === meta.id) || null;

              if (status) {

                status.textContent = metaRef ? `Loading: ${metaRef.title}...` : "Loading saved script...";

              }

              try {

                await loadScenes();

                if (status) {

                  const countVal = metaRef && typeof metaRef.sceneCount === "number" ? metaRef.sceneCount : (S.scenes?.length || 0);

                  const countLabel = countVal > 0 ? `${countVal} scene${countVal === 1 ? "" : "s"}` : "Scenes not loaded";

                  status.textContent = metaRef ? `Loaded: ${metaRef.title} - ${countLabel}` : `Loaded saved script - ${countLabel}`;

                }

              } catch (e) {

                if (status) {

                  status.textContent = "Could not load scenes for this script. You can still re-import it from Import.";

                }

              }

            });



            strip.appendChild(card);

          });

      }



      // --- Route/Ringer Inference (iOS + BT + HFP narrowband) ---------------------

      const _route = {

        isiOS: /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,

        hasBluetooth: false,

        checkedBluetooth: false,

        warnActive: false,

        lastWarn: null

      };



      async function hasBluetoothInput(force = false) {

        if (!force && _route.checkedBluetooth) return !!_route.hasBluetooth;

        try {

          const devs = await navigator.mediaDevices.enumerateDevices();

          const found = devs.some(d => {

            if (d.kind !== "audioinput") return false;

            const label = (d.label || "").toLowerCase();

            return /(bluetooth|airpod|pods|beats|earbud|headset|hands[- ]?free|bose|sony)/.test(label);

          });

          _route.hasBluetooth = found;

          _route.checkedBluetooth = true;

          if(typeof window !== "undefined") window.__OB_BT_IN = found;

          return found;

        } catch {

          const fallback = force ? false : !!_route.hasBluetooth;

          if(typeof window !== "undefined") window.__OB_BT_IN = fallback;

          return fallback;

        }

      }



      function looksLikeHfp(track) {

        try {

          const st = track?.getSettings?.() || {};

          const label = (track?.label || "").toLowerCase();

          const sr = Number(st.sampleRate) || 0;

          const ch = Number(st.channelCount) || 0;

          if (sr && sr <= 16000) return true;

          if (sr && sr <= 24000 && /(bluetooth|airpod|beats|headset|hands[- ]?free|earbud|bose|sony|pods)/.test(label)) return true;

          if (!sr && /(sco|hfp|hands[- ]?free|headset)/.test(label)) return true;

          return false;

        } catch { return false; }

      }



      // Passive playback-energy probe to detect "audio routed but inaudible" during SR

      function makeEnergyProbe(audioCtx) {

        const analyser = audioCtx.createAnalyser();

        analyser.fftSize = 512;

        const data = new Uint8Array(analyser.frequencyBinCount);

        let lastRms = 0;

        function rms() {

          analyser.getByteTimeDomainData(data);

          let sum = 0;

          for (let i = 0; i < data.length; i++) { const v = (data[i] - 128) / 128; sum += v * v; }

          return Math.sqrt(sum / data.length);

        }

        return { analyser, sample: () => (lastRms = rms()), last: () => lastRms };

      }



      function showRouteWarn(on) {

        logRouteCheck(on ? "show:on" : "show:off");

        ["routeWarn", "routeWarnRecord"].forEach(id => {

          const el = document.getElementById(id);

          if (!el) return;

          el.classList.toggle("hidden", !on);

        });

        _route.warnActive = !!on;

      }



      function logRouteCheck(src){

        try{

          const track = typeof window !== "undefined" ? window.__OB_MIC_TRACK : null;

          const settings = track?.getSettings?.() || {};

          const payload = {

            isiOS: _route.isiOS,

            bt: typeof window !== "undefined" ? window.__OB_BT_IN : undefined,

            hfp: track ? looksLikeHfp(track) : false,

            sampleRate: settings.sampleRate,

            ch: settings.channelCount

          };

          if(src) payload.src = src;

          console.debug('[RouteCheck]', payload);

        }catch{}

      }



      function maybeShowRouteModal(){

        if(typeof RouteModal === "undefined" || !RouteModal) return;

        if(typeof window !== "undefined" && window.isRecording){

          document.addEventListener('ob:recording:stopped', () => {

            if (!RouteModal.inCooldown()) RouteModal.open();

          }, { once: true });

        }else{

          if (!RouteModal.inCooldown()) RouteModal.open();

        }

      }



      function getRouteProbe(audioCtx){

        if(typeof window === "undefined") return null;

        const existing = window.__OB_AP;

        if(existing && existing.analyser && existing.analyser.context === audioCtx) return existing;

        const probe = makeEnergyProbe(audioCtx);

        window.__OB_AP = probe;

        return probe;

      }



      function tapReaderNode(node){

        if(!node || typeof node.connect !== "function") return;

        if(node.__obProbeConnected) return;

        try{

          const ctx = node.context;

          if(!ctx) return;

          const probe = getRouteProbe(ctx);

          if(probe && probe.analyser){

            try{ node.connect(probe.analyser); node.__obProbeConnected = true; }catch{}

          }

        }catch{}

      }



      let srEnergyTimer = null;



      function stopRouteEnergyPolling(){ if(srEnergyTimer){ clearInterval(srEnergyTimer); srEnergyTimer = null; } }



      function startRouteEnergyPolling(){

        if(typeof window === "undefined") return;

        try{ tapReaderNode(R?.readerGain); }catch{}

        const probe = window.__OB_AP;

        if(!probe || typeof probe.sample !== "function") return;

        let ticks = 0;

        stopRouteEnergyPolling();

        srEnergyTimer = setInterval(()=>{

          ticks++;

          try{

            const e = probe.sample();

            logRouteCheck(`energyPoll:${ticks}`);

            // very low RMS while "playing" suggests wrong route

            if (_route?.isiOS && (window.__OB_BT_IN || false) && (looksLikeHfp(window.__OB_MIC_TRACK) || (window.__OB_AP?.last?.() ?? 0) < 0.01)) {

              _route.warnActive = true;

              if (!RouteModal.inCooldown()) RouteModal.open();

            }

          }catch{}

          if(ticks >= 3) stopRouteEnergyPolling();

        }, 300);

      }



      async function inferRouteWarning({ track, phase } = {}) {

        if (!_route.isiOS) {

          if (_route.warnActive) showRouteWarn(false);

          return false;

        }



        if (!_route.checkedBluetooth) {

          try {

            const hasBt = await hasBluetoothInput();

            if (hasBt) _route.hasBluetooth = true;

          } catch {}

        }



        if (!track) {

          if (!_route.warnActive) showRouteWarn(false);

          return _route.warnActive;

        }



        const settings = track.getSettings ? track.getSettings() : {};

        const sampleRate = Number(settings.sampleRate) || 0;

        const channelCount = Number(settings.channelCount) || 0;

        const label = (track.label || "").toLowerCase();

        if (label && /(bluetooth|airpod|pods|beats|earbud|headset|hands[- ]?free|bose|sony)/.test(label)) {

          _route.hasBluetooth = true;

          _route.checkedBluetooth = true;

        }



        const probableHfp = looksLikeHfp(track);

        logRouteCheck('inferRouteWarning');

        if (probableHfp) {

          _route.lastWarn = { phase: phase || "", sampleRate, channelCount, label };

          _route.warnActive = true;

          maybeShowRouteModal();

          return true;

        }



        if (sampleRate && sampleRate >= 22050) {

          _route.lastWarn = null;

          showRouteWarn(false);

          return false;

        }



        if (!_route.warnActive) showRouteWarn(false);

        return false;

      }



      // --- Global audio stop (kills any lingering playback/SR) ---

      function resetReaderActiveSources(){

        try{

          if(R && R.readerActiveSources instanceof Set){

            R.readerActiveSources.forEach(src=>{ try{ if(src && typeof src.stop === "function") src.stop(0); }catch{} });

            R.readerActiveSources.clear();

          }

          if(R && !(R.readerActiveSources instanceof Set)) R.readerActiveSources = new Set();

        }catch{}

      }



      function stopAllAudioHard() {

        try { E?.rehearseAudio?.pause(); E.rehearseAudio.currentTime = 0; } catch {}

        try { R?.audio?.pause(); R.audio.currentTime = 0; } catch {}

        resetReaderActiveSources();

        try { sr?.stop(); } catch {}

        try { clearMy?.(); } catch {}

        try { playing = false; } catch {}

        stopRouteEnergyPolling();

      }



      // Persist cached reader clips across tabs (and reloads)

      const ReaderCache = {

        get() {

          try {

            const raw = sessionStorage.getItem("rr_map_v1");

            if (!raw) return new Map();

            const arr = JSON.parse(raw);

            return new Map(arr);

          } catch { return new Map(); }

        },

        set(map) {

          try {

            const arr = Array.from(map.entries());

            sessionStorage.setItem("rr_map_v1", JSON.stringify(arr));

          } catch {}

        }

      };



      async function safeJson(r){ const t=await r.text(); try{return JSON.parse(t)}catch{return {raw:t}} }

      function handleUnauthorized(r){

        if(r && r.status === 401){

          showLocked();

          return true;

        }

        return false;

      }



      async function loadSupportedVoices(){

        try{

          const r = await fetch("/debug/voices_probe", withSecretHeaders({ headers: { ...JSON_HDRS } }));

          if(handleUnauthorized(r)) return;

          const j = await safeJson(r);

          if(r.ok && Array.isArray(j.voices) && j.voices.length){ S.supportedVoices=j.voices; }

        }catch(e){ /* keep default */ }

      }



      async function loadScenes(){

        try{

          const r=await fetch("/debug/scenes?script_id="+encodeURIComponent(S.script_id),withSecretHeaders({headers:{...JSON_HDRS}}));

          if(handleUnauthorized(r)) return;

          const j=await safeJson(r); if(!r.ok) return;

          S.scenes=j.scenes||[];

          S.currentSceneIndex = 0;



          // Override with locally-edited scenes if present

          if (S.script_id) {

            const payloads = getSavedScriptPayloadsFromStorage();

            const local = payloads[S.script_id];

            if (local && Array.isArray(local.scenes)) {

              S.scenes = local.scenes;

            }



            // If the payload also has a better title, sync it back into savedScripts

            if (local && typeof local.title === "string" && local.title.trim()) {

              const meta = Array.isArray(S.savedScripts)

                ? S.savedScripts.find(s => s.id === S.script_id)

                : null;

              if (meta) {

                meta.title = local.title.trim();

                try {

                  if (typeof saveSavedScriptsToStorage === "function") {

                    saveSavedScriptsToStorage();

                  }

                } catch (_) {}

                try {

                  if (typeof renderSavedScriptsStrip === "function") {

                    renderSavedScriptsStrip();

                  }

                } catch (_) {}

              }

            }

          }



          if(typeof window !== "undefined") window.currentSceneId = S.script_id || null;

          await loadSupportedVoices();

          hydrateAssign(); hydrateRehearse(); applyEditModeUI(); hydrateImportEditor();

        }catch(e){ showErr("Init warning: couldn't load scenes. You can still re-import."); }

      }



      function sanitizeScriptText(raw){

        const lines = String(raw||"").split(/\r?\n/);

        const drop=[/sides\s+by\s+breakdown\s+services/i,/actors\s+access/i,/do\s+not\s+share/i,/copyright/i,/^page\s+\d+(\s*of\s*\d+)?$/i,/^https?:\/\/\S+/i,/^\s*(INT\.|EXT\.|SCENE)\b/i,/^[A-Z0-9 .,'&/()-]{6,}\s*$/];

        const kept=[]; for(const ln of lines){ const t=ln.trim(); if(!t){ kept.push(""); continue; } if(drop.some(rx=>rx.test(t))) continue; if(/^\(.*\)$/.test(t)) continue; kept.push(ln); } return kept.join("\n");

      }



      // Import: text

      $("#btnTextUpload")?.addEventListener("click", async ()=>{

        const title=$("#titleText").value||"Sides";

        const text=sanitizeScriptText($("#scriptText").value||"");

        setStatus("Uploading text…");

        try{

          const r=await fetch("/debug/upload_script_text", withSecretHeaders({method:"POST",headers:{...JSON_HDRS},body:JSON.stringify({title,text})}));

          if(handleUnauthorized(r)){ setStatus("Locked."); return; }

        const j=await safeJson(r);

        if(!r.ok){ setStatus("Error "+r.status+": "+JSON.stringify(j)); return; }

        const scriptId=j.script_id;

        const sceneCount=typeof j.scene_count==="number"?j.scene_count:0;

        setStatus(`OK scenes=${j.scene_count} speakers=${(j.speakers||[]).join(", ")}`);

        S.script_id=scriptId;

        upsertSavedScriptMeta(scriptId, title, sceneCount);

        await loadScenes();

        }catch(e){ setStatus("Network error: "+e); }

      });

      $("#btnTextClear")?.addEventListener("click",()=>{ $("#titleText").value=""; $("#scriptText").value=""; setStatus(""); });



      // Import: PDF

      $("#btnPdfUpload")?.addEventListener("click", async ()=>{

        const titleInput=$("#titlePdf");

        const title=titleInput?.value||"PDF Sides";

        const statusPdf=$("#statusPdf");

        const pdfInput=$("#pdfFile");

        const f=pdfInput?.files?.[0];

        if(!f){ if(statusPdf) statusPdf.textContent="No file selected"; return; }

        const fd=new FormData();

        fd.append("title",title);

        fd.append("pdf",f,f.name); // enforce field name

        if(statusPdf) statusPdf.textContent="Uploading PDF…";

        try{

          const r=await fetch("/debug/upload_script_upload",withSecretHeaders({method:"POST",body:fd}));

          if(handleUnauthorized(r)){ if(statusPdf) statusPdf.textContent="Locked."; return; }

        const j=await safeJson(r);

        if(!r.ok){ if(statusPdf) statusPdf.textContent=j?.error||`Error ${r.status}: ${JSON.stringify(j)}`; return; }

        const sp=(j.speakers||[]).join(", "); const note=j.note?(" note="+j.note):"";

        if(statusPdf) statusPdf.textContent=`OK scenes=${j.scene_count} speakers=${sp||"(none)"} textLen=${j.textLen||0}${note}`;

        if(j.note==="image-only"||j.note==="parse-error"){ $("#btnPdfOcr").disabled=false; $("#btnPdfOcr").focus(); return; }

        const scriptId=j.script_id;

        const sceneCount=typeof j.scene_count==="number"?j.scene_count:0;

        S.script_id=scriptId;

        upsertSavedScriptMeta(scriptId, title, sceneCount);

        await loadScenes();

        }catch(e){ if(statusPdf) statusPdf.textContent="Network error: "+e; }

      });



      // Assign

      function uniqueRoles(){ const names=new Set(); for(const sc of (S.scenes||[])) for(const ln of (sc.lines||[])) names.add(ln.speaker); return Array.from(names).filter(n=>n&&n!=="SYSTEM"&&n!=="NARRATOR"); }

      function hydrateAssign(){

        $("#pillScript").textContent="script: "+(S.script_id||"-");

        $("#pillScenes").textContent="scenes: "+(S.scenes?.length||0);

        const roles=uniqueRoles(); const sel=$("#selectRole");

        sel.innerHTML=roles.map(r=>`<option value="${r}">${r}</option>`).join("");

        if(!S.role&&roles.length) S.role=roles[0];

        sel.value=S.role||"";

        sel.onchange=()=>{
          S.role=sel.value;
          buildVoicePickers();
          hydrateRehearse();
          applyEditModeUI();
          // Persist Assign selection for Record tab Render
          if(S.script_id && S.role){
            try{
              localStorage.setItem("offbook:last_assign", JSON.stringify({
                script_id: S.script_id,
                scene_id: S.script_id,
                role: S.role
              }));
            }catch{}
          }
        };

        buildVoicePickers();

      }

      let voicePreviewAudio = null;

      async function previewVoiceSample(voice, btn){

        const fallbackVoice = OPENAI_VOICES[0] || "alloy";

        const chosenVoice = voice || fallbackVoice;

        const sampleText = "Hi, would you be interested in me being your scene partner? Do you like the sound of my voice?";



        // Try to reuse the same model selector Rehearse uses, fallback to tts-1

        const modelSel = document.getElementById("selTtsModel");

        const model = (modelSel && modelSel.value) || "tts-1";



        let originalLabel = btn && btn.textContent;



        try {

          if (!voicePreviewAudio) {

            const a = document.createElement("audio");

            a.preload = "auto";

            a.setAttribute("playsinline", "");

            a.style.display = "none";

            document.body.appendChild(a);

            voicePreviewAudio = a;

          }



          // Stop any prior preview

          try {

            voicePreviewAudio.pause();

            voicePreviewAudio.currentTime = 0;

          } catch {}



          // Simple loading cue on the button

          if (btn) {

            btn.disabled = true;

            btn.textContent = "Loading…";

          }



          // Ask server for a single TTS line (same route Rehearse uses)

          const r = await fetch("/debug/tts_line", withSecretHeaders({

            method: "POST",

            headers: { ...JSON_HDRS, "Accept": "application/json" },

            body: JSON.stringify({

              voice: chosenVoice,

              model,

              text: sampleText

            })

          }));



          if (!r.ok) return;



          const txt = await r.text();

          let j = {};

          try { j = JSON.parse(txt); } catch { /* non-JSON body */ }



          if (!j || !j.url) return;



          // Fetch the actual audio and play it in the preview <audio>

          const audioResp = await fetch(j.url, { cache: "no-store" });

          if (!audioResp.ok) return;



          const blob = await audioResp.blob();

          const url = URL.createObjectURL(blob);

          voicePreviewAudio.src = url;

          await voicePreviewAudio.play();

        } catch (err) {

          console.error("[Assign] previewVoiceSample error:", err);

        } finally {

          if (btn) {

            btn.disabled = false;

            btn.textContent = originalLabel || "Test";

          }

        }

      }

      function buildVoicePickers(){

        const box=$("#voicePickers"); box.innerHTML="";

        const partners=uniqueRoles().filter(n=>n!==S.role);

        const defaultVoice = OPENAI_VOICES[0] || "alloy";

        partners.forEach(roleName=>{

          const wrap=document.createElement("div");

          wrap.className="card"; wrap.style.marginTop="8px";

          wrap.innerHTML = `<div style="display:flex;align-items:center;justify-content:space-between;gap:10px">

        <strong>${roleName}</strong>

        <div style="display:flex;align-items:center;gap:8px">

          <button type="button" class="btn ghost sm assign-voice-test" data-name="${roleName}">Test</button>

          <select class="assign-voice-select" data-name="${roleName}">

            ${S.supportedVoices.map(v=>`<option value="${v}" ${((S.voice_map[roleName]||S.supportedVoices[0])===v)?"selected":""}>${v}</option>`).join("")}

          </select>

        </div>

      </div>`;

          const sel = wrap.querySelector(`select[data-name="${roleName}"]`);

          if(sel){

            const currentVoice = sel.value || defaultVoice;

            S.voice_map[roleName] = OPENAI_VOICES.includes(currentVoice) ? currentVoice : defaultVoice;

          }

          box.appendChild(wrap);

        });

        box.querySelectorAll("select").forEach(el=>el.addEventListener("change",(e)=>{

          const sel = e.target; S.voice_map[sel.getAttribute("data-name")] = sel.value;

        }));

        box.querySelectorAll(".assign-voice-test").forEach(btn => {

          btn.addEventListener("click", async () => {

            const roleName = btn.getAttribute("data-name");

            const sel = box.querySelector(`select[data-name="${roleName}"]`);

            const voice = (sel && sel.value) || (roleName && S.voice_map[roleName]) || (S.supportedVoices[0] || "alloy");

            await previewVoiceSample(voice, btn);

          });

        });

      }

      $("#btnSaveAssign")?.addEventListener("click", async ()=>{

        if(!S.script_id) return;

        const voiceMap = {};

        const defaultVoice = OPENAI_VOICES[0] || "alloy";

        document.querySelectorAll(".assign-voice-select").forEach(sel=>{

          const role  = sel.getAttribute("data-name") || sel.dataset.name;

          const voice = sel.value || defaultVoice;

          if(role) voiceMap[role] = voice;

        });

        const roles=uniqueRoles().filter(r=>r!==S.role);

        for(const r of roles){

          if(!voiceMap[r]) voiceMap[r]=defaultVoice;

        }

        S.voice_map = voiceMap;

        try{

          const r=await fetch("/debug/set_voice", withSecretHeaders({

            method: "POST",

            headers: { ...JSON_HDRS },

            body: JSON.stringify({ script_id:S.script_id, voice_map:voiceMap })

          }));

          if(handleUnauthorized(r)) return;

        }catch{}

        showScreen("rehearse");

      });



      /* ------- rehearse listening/respond flow (UNCHANGED) ------- */

      const E={

        linesWrap:$("#lines"), btnPlay:$("#btnPlay"), btnPrev:$("#btnPrev"), btnNext:$("#btnNext"), btnTop:$("#btnTop"),

        selPace:"#selPace", btnMic:$("#btnMic"), micBadge:$("#micBadge"),

        btnToggleEditMode:$("#btnToggleEditMode"), editModeState:$("#editModeState"),

        inlineForm:null, currentSlotPlace:null,

        rehearseAudio:(()=>{

          const a=document.createElement("audio");

          a.preload="auto";

          a.setAttribute("playsinline","");

          a.style.display="none";

          document.body.appendChild(a);

          if(typeof window !== "undefined" && !window.__OB_READER_EL){ window.__OB_READER_EL = a; }

          return a;

        })()

      };

      let idx=0, playing=false;



      const isParenOnly=t=>/^\(.*\)$/.test((t||"").trim());

      const isBoilerplate=t=>{ const s=(t||"").trim().toLowerCase(); if(!s) return true; if(/^[-–—]+$/.test(s)) return true; if(/^\d{1,4}$/.test(s)) return true; if(/^page\s*\d+(\s*of\s*\d+)?$/i.test(s)) return true; if((/^cont'?d\.?$/i.test(s)||/^continued$/i.test(s))&&s.length<=10) return true; if(/^https?:\/\/\S+/i.test(s)) return true; return (s.includes("sides by breakdown services")||s.includes("actors access")||s.includes("do not share")||s.includes("copyright")) && s.length<=80; };



      function buildFiltered(scene){ const out=[]; for(let i=0;i<(scene?.lines?.length||0);i++){ const ln=scene.lines[i]; if(!ln) continue; if(ln.speaker==="NARRATOR") continue; if(isParenOnly(ln.text)) continue; if(isBoilerplate(ln.text)) continue; out.push({orig:i,speaker:ln.speaker,text:ln.text}); } return out; }

      function getScene(){ return S.scenes[0]; }

      function myName(){ return S.role||uniqueRoles()[0]||""; }



      function inlineSlot(place){ return `<div class="inline-slot" data-place="${place}"><div class="ghostline"><button class="btn ghost sm" data-add-button>+ Add here</button></div></div>`; }



      function hydrateRehearse(){

        const scene=getScene(); const list=buildFiltered(scene);

        if(!list.length){ $("#lines").innerHTML="<p class='hint'>Import a script first.</p>"; return; }

        let html=inlineSlot(0);

        list.forEach((ln,i)=>{ const me=ln.speaker===myName(); html+=`<div class="line ${me?"me":""}" data-i="${i}" data-orig="${ln.orig}"><div class="editbar" style="display:${S.editMode?'flex':'none'}"><span class="chip" data-act="edit" data-i="${i}">Edit</span><span class="chip danger" data-act="del" data-i="${i}">Delete</span></div><div class="who">${ln.speaker}</div><div class="text" data-i="${i}" contenteditable="false">${ln.text}</div></div>`; html+=inlineSlot(ln.orig+1); });

        $("#lines").innerHTML=html; idx=Math.max(0,Math.min(idx,list.length-1)); wireEditTools(); wireSlots(); highlightCurrent(); applyEditModeUI();

      }

      function wireEditTools(){ $$(".chip",$("#lines")).forEach(ch=>ch.onclick=(ev)=>{ ev.stopPropagation(); const act=ch.getAttribute("data-act"); const iF=+ch.getAttribute("data-i"); const sc=getScene(); if(!sc) return; const node=document.querySelector(`.line[data-i="${iF}"]`); const orig=+node.getAttribute("data-orig"); if(Number.isNaN(orig)) return; if(act==="edit"){ if(!S.editMode) return; const t=document.querySelector(`.text[data-i="${iF}"]`); const editing=t.getAttribute("contenteditable")==="true"; if(editing){ t.setAttribute("contenteditable","false"); sc.lines[orig].text=t.innerText.trim(); hydrateRehearse(); } else { t.setAttribute("contenteditable","true"); t.focus(); const r=document.createRange(); r.selectNodeContents(t); r.collapse(false); const s=window.getSelection(); s.removeAllRanges(); s.addRange(r); } } else if(act==="del"){ if(!S.editMode) return; sc.lines.splice(orig,1); hydrateRehearse(); } }); }

      function wireSlots(){ $$('[data-add-button]',$("#lines")).forEach(btn=>btn.onclick=(ev)=>{ if(!S.editMode) return; ev.stopPropagation(); const slot=btn.closest('.inline-slot'); openInlineForm(slot, Number(slot.getAttribute("data-place"))); }); }

      function highlightCurrent(){ $$(".line",$("#lines")).forEach(el=>el.classList.remove("playing")); const cur=document.querySelector(`.line[data-i="${idx}"]`); if(cur){ cur.classList.add("playing"); cur.scrollIntoView({block:"center",behavior:(!S.editMode?"smooth":"auto")}); } }



      /* Speech Rec (unchanged timings) */

      const SR=window.SpeechRecognition||window.webkitSpeechRecognition;

      const sr=SR?new SR():null;

      let srToggleOn=false, srPermGranted=false, srActive=false;

  let myLineStartMs=0, firstEnergyAt=0, advanceLock=false;

  let lastAdvanceAt=0;

      let latestTranscript="", silenceTimer=null, lastResultAt=0;



      // energy monitor

      let micStream=null, audioCtx=null, analyser=null, energy=0, speaking=false, lastEnergyAt=0;

  const ENERGY_SILENCE_THRESH=0.020;



      function rms(buf){ let sum=0; for(let i=0;i<buf.length;i++){ const v=buf[i]/128-1; sum+=v*v; } return Math.sqrt(sum/buf.length); }

      async function startMicMonitor(){

        if(micStream) return;

        try{

          const stream = await navigator.mediaDevices.getUserMedia({audio:true});

          // after getUserMedia:

          micStream=stream;

          window.__OB_MIC_STREAM = stream;

          const track = (typeof stream?.getAudioTracks === "function") ? stream.getAudioTracks()[0] : null;

          window.__OB_MIC_TRACK = track || null;

          logRouteCheck('startMicMonitor');

          // When STT2 is enabled, keep a small rolling recorder on the mic stream

          // so we can send recent audio chunks to the server for debug-only STT.

          if (STT2_ENABLED && window.MediaRecorder && !stt2Recorder) {

            try {

              let mime = "";

              if (typeof MediaRecorder.isTypeSupported === "function") {

                if (MediaRecorder.isTypeSupported("audio/webm;codecs=opus")) {

                  mime = "audio/webm;codecs=opus";

                } else if (MediaRecorder.isTypeSupported("audio/webm")) {

                  mime = "audio/webm";

                }

              }



              const rec = mime ? new MediaRecorder(stream, { mimeType: mime }) : new MediaRecorder(stream);

              stt2Recorder = rec;

              window.__OB_STT2_RECORDER = rec;



              // Reset rolling buffer whenever we (re)start the recorder.

              stt2HeaderChunk = null;

              stt2BodyChunks = [];

              stt2Mime = mime || "";



              rec.ondataavailable = (e) => {

                if (!e.data || e.data.size === 0) return;



                // First non-empty chunk: treat as the WebM header and keep it forever.

                if (!stt2HeaderChunk) {

                  stt2HeaderChunk = e.data;

                  return;

                }



                // Subsequent chunks are "body" audio. We keep a small rolling window.

                stt2BodyChunks.push(e.data);



                // Optional safety: keep at most ~10s of recent audio body (~2-3 chunks).

                const maxBodyChunks = 3;

                if (stt2BodyChunks.length > maxBodyChunks) {

                  stt2BodyChunks.splice(0, stt2BodyChunks.length - maxBodyChunks);

                }

              };



              // Use a small timeslice so we always have recent audio.

              try {

                rec.start(4000); // ~4s rolling window

              } catch (err) {

                console.warn("[stt2] recorder start failed", err);

              }

            } catch (err) {

              console.warn("[stt2] recorder init failed", err);

            }

          }

          try{

            const bt = window.__OB_BT_IN || await hasBluetoothInput();

            window.__OB_BT_IN = bt;

            if (_route?.isiOS && (window.__OB_BT_IN || false) && (looksLikeHfp(window.__OB_MIC_TRACK) || (window.__OB_AP?.last?.() ?? 0) < 0.01)) {

              _route.warnActive = true;

              if (!RouteModal.inCooldown()) RouteModal.open();

            } else {

              showRouteWarn(false);

            }

          }catch{ showRouteWarn(false); }

          audioCtx=new (window.AudioContext||window.webkitAudioContext)();

          const src=audioCtx.createMediaStreamSource(stream);

          analyser=audioCtx.createAnalyser(); analyser.fftSize=2048;

          src.connect(analyser);

          const data=new Uint8Array(analyser.fftSize);

          const energyWindow=[];

          const tick=()=>{

            if(!analyser) return;

            analyser.getByteTimeDomainData(data);

            const v=rms(data);

            energy = energy*0.85 + v*0.15;

            const now=performance.now();

            energyWindow.push(energy);

            if(energyWindow.length>12) energyWindow.shift();

            const talking = isSpeaking(energyWindow);

            if(talking){ if(!speaking){ firstEnergyAt=now; } speaking=true; lastEnergyAt=now; }

            else if(energy<ENERGY_SILENCE_THRESH){ if(now-(lastEnergyAt||now)>140){ speaking=false; } }

            requestAnimationFrame(tick);

          };

          tick();

        }catch{ logRouteCheck('startMicMonitor:error'); showRouteWarn(false); }

      }

      function stopMicMonitor(){

        try{ micStream?.getTracks().forEach(t=>t.stop()); }catch{};

        micStream=null;

        window.__OB_MIC_STREAM = null;

        window.__OB_MIC_TRACK = null;

        showRouteWarn(false);

        try{ audioCtx?.close(); }catch{};

        audioCtx=null; analyser=null; energy=0; speaking=false;

      }



      // devicechange: re-evaluate when route flips

      try {

        navigator.mediaDevices.addEventListener("devicechange", async () => {

          try{

            const bt = await hasBluetoothInput(true);

            window.__OB_BT_IN = bt;

            logRouteCheck('mediaDeviceChange');

            if (_route?.isiOS && (window.__OB_BT_IN || false) && (looksLikeHfp(window.__OB_MIC_TRACK) || (window.__OB_AP?.last?.() ?? 0) < 0.01)) {

              _route.warnActive = true;

              if (!RouteModal.inCooldown()) RouteModal.open();

            } else {

              showRouteWarn(false);

            }

          }catch{ showRouteWarn(false); }

        });

      } catch {}



      function minElapsedFor(text){

        const base = expectedMinMsFor(text || "");

        // Rehearse is the timing source of truth; use the same minima in both tabs.

        return Math.round(base * 0.98);

      }



      function silenceDebounceFor(text){

        const base = expectedMinMsFor(text || "");

        // Medium setting: a bit more patient than the original,

        // but not as slow as the last pass so lines don't feel ignored.

        const scaled = Math.round(base * 0.65);

        // Slightly lower floor so short lines can advance,

        // but still enough to avoid micro-pause jumps.

        return Math.min(Math.max(180, scaled), 1100);

      }





      function filtered(){ return buildFiltered(getScene()); }

      function current(){ return filtered()[idx]; }

      function onMyLine(){ const ln=current(); return !!ln && ln.speaker===myName(); }

      function sceneHasDashyUserLine(){

        const list = filtered();

        const me = myName();

        if(!list.length || !me) return false;

        return list.some(ln => ln && ln.speaker === me && endsWithDashy(ln.text || ""));

      }

      function maybeSetMyLineStart(){

        if(onMyLine() && !myLineStartMs){

          myLineStartMs=performance.now();

          if (speakerFallbackActive()) {

            (async () => {

              try { await routeReaderToSpeaker(window.__OB_READER_EL); } catch {}

            })();

          }

        }

      }

      function clearMy(){

        myLineStartMs=0;

        firstEnergyAt=0;

        advanceLock=false;

        latestTranscript="";

        lastResultAt=0;

        stopRouteEnergyPolling();

        if(silenceTimer){

          clearTimeout(silenceTimer);

          silenceTimer=null;

        }

        if (speakerFallbackActive()) {

          (async () => {

            try { await routeReaderToDefault(window.__OB_READER_EL); } catch {}

          })();

        }

      }



  // ------- Reader Recovery Layer (iOS PWA resilience) -------------------------

      window.__OB_PRECACHE = window.__OB_PRECACHE || new Set();



      function ensurePredecodeAudio(){

        try{

          if(window.__OB_PREBUFFER_EL && document.body.contains(window.__OB_PREBUFFER_EL)) return window.__OB_PREBUFFER_EL;

          const pre = document.createElement('audio');

          pre.preload = 'auto';

          pre.setAttribute('playsinline','');

          pre.style.display = 'none';

          pre.muted = true;

          pre.setAttribute('data-reader','prebuffer');

          document.body.appendChild(pre);

          window.__OB_PREBUFFER_EL = pre;

          return pre;

        }catch{return null;}

      }



      function showToastOnce(msg) {

        if (document.getElementById('ob_toast')) return;

        const el = document.createElement('div');

        el.id = 'ob_toast';

        el.textContent = msg;

        el.style.cssText = 'position:fixed;left:50%;bottom:14px;transform:translateX(-50%);background:#222;color:#fff;padding:10px 14px;border-radius:12px;z-index:9999;font-size:13px;opacity:.96';

        document.body.appendChild(el);

        setTimeout(()=>{ try{ el.remove(); }catch{}; }, 2200);

      }



      async function predecode(unit) {

        if(!unit) return;

        try{

          window.__OB_PRECACHE = window.__OB_PRECACHE || new Set();

          if(window.__OB_PRECACHE.has(unit)) return;

          const pre = ensurePredecodeAudio();

          if(!pre) return;

          if(pre.dataset.unit === unit) return;

          pre.dataset.unit = unit;

          pre.src = unit;

          try{ pre.load(); }catch{}

          window.__OB_PRECACHE.add(unit);

        }catch{}

      }



      function firstPartnerIndex(from = 0){

        try{

          const list = filtered();

          const me = myName();

          if(!list.length) return 0;

          const start = Math.max(0, from || 0);

          for(let i=start;i<list.length;i++){

            const ln = list[i];

            if(ln && ln.speaker !== me) return i;

          }

          return start;

        }catch{ return 0; }

      }



      async function rehydrateAudioAndRoute({ from } = {}) {

        try {

          const ctx = await ensureAudioContext();

          try { await window.__OB_READER_EL?.setSinkId?.('default'); } catch {}

          if (_route?.isiOS && (window.__OB_BT_IN || false) && looksLikeHfp?.(window.__OB_MIC_TRACK)) {

            if (!RouteModal.inCooldown()) RouteModal.open();

          }

          if (window.RR?.map) {

            const startIdx = typeof firstPartnerIndex === 'function' ? firstPartnerIndex(idx || 0) : (idx || 0);

            const u0 = window.RR.map.get(startIdx);

            const u1 = window.RR.map.get(startIdx + 1);

            if (u0) await predecode(u0);

            if (u1) await predecode(u1);

            try { highlightCurrent(); } catch {}

          }

          if (ctx?.state !== 'running') showToastOnce('Audio paused by iOS — tap Play to continue');

          console.debug('[recovery] rehydrate done', { from, ctx: ctx?.state, idx });

        } catch (e) { console.warn('[recovery] rehydrate failed', e); }

      }



      window.addEventListener('pagehide', () => {

        // hint: iOS may suspend/close audioCtx after this

      });



      const SKEY = 'ob.rehearse.state.v1';

      function saveRehearseState() {

        try {

          const st = { sceneId: window.currentSceneId, idx: window.idx || 0, rid: window.RR?.id || null };

          sessionStorage.setItem(SKEY, JSON.stringify(st));

        } catch {}

      }

      function loadRehearseState() {

        try { return JSON.parse(sessionStorage.getItem(SKEY) || 'null'); } catch { return null; }

      }



      document.addEventListener('visibilitychange', () => {

        if (document.visibilityState === 'hidden') {

          saveRehearseState();

          try { window.bufferCache && window.bufferCache.clear && window.bufferCache.clear(); } catch {}

        }

      });

      window.addEventListener('pagehide', saveRehearseState);



      async function rehydrateOnReturn(from) {

        const ctx = await ensureAudioContext();

        try { await window.__OB_READER_EL?.setSinkId?.('default'); } catch {}



        const st = loadRehearseState();

        if (st) {

          try { window.currentSceneId = st.sceneId; window.idx = st.idx|0; } catch {}

        }

        if (window.RR?.map && typeof predecode === 'function') {

          const start = (typeof firstPartnerIndex === 'function') ? firstPartnerIndex(window.idx||0) : (window.idx||0);

          try {

            const u0 = window.RR.map.get(start);

            const u1 = window.RR.map.get(start+1);

            if (u0) predecode(u0);

            if (u1) predecode(u1);

            if (typeof highlightCurrent === 'function') highlightCurrent();

          } catch {}

        }

        if (ctx?.state !== 'running') console.debug('[rehydrate] ctx=', ctx?.state, 'tap Play to resume');

      }



      window.addEventListener('pageshow', () => rehydrateOnReturn('pageshow'));

      window.addEventListener('pageshow', () => {

        try { if (primeReaderFromCacheIfAvailable()) preloadReaderBuffers(); } catch {}

      });

      document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible') rehydrateOnReturn('visible'); });



      try {

        navigator.mediaDevices.addEventListener('devicechange', async () => {

          await ensureAudioContext();

          try { await window.__OB_READER_EL?.setSinkId?.('default'); } catch {}

          if (window.RR?.map && typeof predecode==='function') {

            const start = (typeof firstPartnerIndex==='function') ? firstPartnerIndex(window.idx||0) : (window.idx||0);

            const u0 = window.RR.map.get(start), u1 = window.RR.map.get(start+1);

            if (u0) predecode(u0);

            if (u1) predecode(u1);

          }

          if (typeof RouteModal!=='undefined' && typeof looksLikeHfp==='function' && window.__OB_MIC_TRACK) {

            if (_route?.isiOS && (window.__OB_BT_IN || false) && looksLikeHfp(window.__OB_MIC_TRACK) && !RouteModal.inCooldown()) {

              RouteModal.open();

            }

          }

        });

      } catch {}



      async function hardResumeOnGesture() {

        // Resume both contexts under a user gesture

        const ctx = await ensureAudioContext();

        if (ctx?.state !== 'running') { try { await ctx.resume(); } catch {} }



        try {

          if (typeof hasR === 'function' && hasR()) {

            try { await ensureReaderCtx(); } catch {}

            if (R.readerCtx?.state === 'suspended') { try { await R.readerCtx.resume(); } catch {} }

            if (R.readerCtx && R.readerGain && !R.readerDirectConnected) {

              try { restoreReaderDirectMonitor(); } catch {}

            }

          }

        } catch {}



        try { await window.__OB_READER_EL?.setSinkId?.('default'); } catch {}

      }



      function updateMicBadge(){

        const srAvailable = !!sr;

        let label, cls;

        if(!srAvailable){ label = srToggleOn ? "energy only" : "off"; cls = srToggleOn ? "ok" : "warn"; }

        else{ label = !srToggleOn ? "off" : (srActive ? "listening…" : (srPermGranted ? "ready" : "needs permission"));

              cls = !srToggleOn ? "warn" : (srActive ? "ok" : (srPermGranted ? "warn" : "err")); }

        $("#micBadge").textContent = label;

        $("#micBadge").className = "badge " + cls;

        $("#btnMic").textContent = srToggleOn ? "Mic: On" : "Mic: Off";

        $("#btnMic").setAttribute("aria-pressed", srToggleOn ? "true" : "false");

      }



      async function requestMicPermissionOnce(){

        if(srPermGranted) return true;

        try{

          const s = await navigator.mediaDevices.getUserMedia({audio:true});

          // after getUserMedia:

          const track = (typeof s?.getAudioTracks === "function") ? s.getAudioTracks()[0] : null;

          window.__OB_MIC_STREAM = s;

          window.__OB_MIC_TRACK = track || null;

          logRouteCheck('requestMicPermissionOnce');

          try{

            const bt = window.__OB_BT_IN || await hasBluetoothInput();

            window.__OB_BT_IN = bt;

            if (_route?.isiOS && (window.__OB_BT_IN || false) && (looksLikeHfp(window.__OB_MIC_TRACK) || (window.__OB_AP?.last?.() ?? 0) < 0.01)) {

              _route.warnActive = true;

              if (!RouteModal.inCooldown()) RouteModal.open();

            } else {

              showRouteWarn(false);

            }

          }catch{ showRouteWarn(false); }

          s.getTracks().forEach(t=>t.stop());

          srPermGranted=true;

          return true;

        }catch{

          logRouteCheck('requestMicPermissionOnce:error');

          srPermGranted=false;

          return false;

        } finally{ updateMicBadge(); }

      }



      function advanceFromMyLine(){

        const now = performance.now();

        // Rehearse is the timing source of truth; use the same cooldown in all tabs.

        const cooldown = AFTER_ADV_COOLDOWN_MS;

        if (advanceLock || (now - lastAdvanceAt) < cooldown) return;

        if (!onMyLine()) return;

        const ln = current();

        if (!ln) return;

        const elapsed = now - (myLineStartMs || now);

        if (elapsed < minElapsedFor(ln.text || "")) return;



        advanceLock = true;

        const list = filtered();

        if (!list.length) { advanceLock = false; return; }



        idx = Math.min(idx + 1, list.length - 1);

        highlightCurrent();

        clearMy();

        lastAdvanceAt = now;



        try { sr?.stop(); } catch {}



        // If we are on the Record tab and have a recorder, start capturing this segment.

        if (R?.rec && typeof R.rec.state === "string" && R.rec.state === "inactive") {

          try {

            R.rec.start();

            R.recording = true;

            setRailStates();

          } catch {}

        }



        const next = current();

        if (next && next.speaker === myName()) {

          // Next line is yours: re-arm speech recognition if enabled.

          if (srToggleOn && srPermGranted) {

            setTimeout(() => {

              if (sr && !srActive) {

                try { sr.start(); } catch {}

              }

            }, 80);

          }

        } else if (next) {

          // Partner line: keep the reader moving.

          playing = true;

          Promise.resolve(step(true, { immediate: true })).catch(() => {});

        }



        advanceLock = false;

      }

      function armSilenceDebounce(){

        if (silenceTimer) clearTimeout(silenceTimer);

        const ln = current();

        if (!ln) return;

        const need = silenceDebounceFor(ln.text || "");

        silenceTimer = setTimeout(()=>{

          if (!onMyLine()) return;

          const now = performance.now();

          const elapsed = now - (myLineStartMs || now);

          if (!firstEnergyAt || elapsed < 60) return;

          // Safety net: if we've been on this line for a long time after

          // hearing speech, force an advance so the reader never "vanishes"

          // permanently on tricky lines (especially in Record).

          if (elapsed >= MAX_MY_LINE_MS) {

            silenceTimer = null;

            advanceFromMyLine();

            return;

          }



          const shouldAdvance = readyForAdvance({

            text: ln.text,

            interim: latestTranscript,

            isSilentNow: !speaking,

            elapsedMs: elapsed,

            lastAdvanceAt,

            dashyMode: endsWithDashy(ln.text)

          });



          const timeSinceEnergy = now - (lastEnergyAt || now);

          const enoughSilence = timeSinceEnergy >= Math.min(

            900,

            Math.max(140, silenceDebounceFor(ln.text))

          );

          const enoughElapsed = elapsed >= minElapsedFor(ln.text);

          const dashy = endsWithDashy(ln.text);



          // Let the timing / silence model decide, same as the older behavior,

          // but shared for Rehearse and Record.

          if (

            (dashy && shouldAdvance && enoughElapsed) ||

            (!dashy && shouldAdvance && enoughSilence && enoughElapsed)

          ){

            silenceTimer = null;

            advanceFromMyLine();

          }

        }, need);

      }



      // Normalize a string into lowercased word tokens with punctuation stripped.

      function normalizeWords(str){

        return (str || "")

          .toLowerCase()

          .replace(/[\u2014\u2013]/g, " ")      // em/en dash → space

          .replace(/[^a-z0-9\s']/gi, " ")      // strip punctuation, keep letters/numbers/apostrophes

          .split(/\s+/)

          .filter(Boolean);

      }



      // Check if the last N words of the current line match the last N words

      // that STT heard from the user. This is our "did they really finish the line?"

      function hasEndingWordMatch(lineText, transcript, count = 2){

        const lineWords = normalizeWords(lineText);

        const heardWords = normalizeWords(transcript);



        if (!lineWords.length || !heardWords.length) return false;



        const n = Math.min(count, lineWords.length, heardWords.length);



        for (let i = 0; i < n; i++){

          const lw = lineWords[lineWords.length - n + i];

          const hw = heardWords[heardWords.length - n + i];

          if (lw !== hw) return false;

        }

        return true;

      }



      if(sr){

      // If STT2 flag is present, show a debug overlay immediately

      if (STT2_ENABLED) {

        updateSttOverlay(

          [

            "STT2 flag ON",

            `SpeechRecognition: ${(window.SpeechRecognition || window.webkitSpeechRecognition) ? "available" : "NOT available"}`,

            "Waiting for first final transcript…",

            "",

            "Steps to trigger:",

            "1) Go to Rehearse or Record.",

            "2) Turn Mic: On.",

            "3) Speak one of your lines until STT produces a final result."

          ].join("\n")

        );

      }



        sr.continuous=false; sr.interimResults=true; sr.lang="en-US";

        sr.onstart=()=>{

          srActive=true;

          updateMicBadge();

          if(onMyLine()){

            startRouteEnergyPolling();

          }

        };

        sr.onend=()=>{

          srActive=false;

          stopRouteEnergyPolling();

          updateMicBadge();

          if(srToggleOn && srPermGranted && onMyLine() && !(E.inlineForm&&E.inlineForm.isConnected)){

            try{ sr.start(); }catch{}

          }

        };

        sr.onerror=()=>{

          srActive=false;

          stopRouteEnergyPolling();

          updateMicBadge();

        };

        sr.onresult=(ev)=>{

          if (!(onMyLine() && srToggleOn && srPermGranted)) return;

          maybeSetMyLineStart();

          const now = performance.now();

          const ln = current(); if (!ln) return;



          const last = ev.results?.[ev.results.length - 1];

          const alt = last?.[0];

          const isFinal = !!last?.isFinal;

          latestTranscript = (alt?.transcript || "").trim();

          lastResultAt = now;



          const ratio = progressRatio(ln.text, latestTranscript);

          const sttConfident = ratio >= 0.92; // high-confidence transcript match



          const elapsed = now - (myLineStartMs || now);

          // When STT2 is enabled, mirror final transcripts + recent audio to the server.

          // This does NOT change cue timing; it's purely for debugging the pipeline.

          if (STT2_ENABLED && isFinal) {

            try {

              const activeMode = (S && S.activeTab) ? S.activeTab : "";

              // Only care in Rehearse / Record where listen/respond matters.

              if (activeMode === "rehearse" || activeMode === "record") {

                const safeScriptId = (S && S.script_id) ? S.script_id : null;

                const safeSceneId =

                  typeof window.currentSceneId !== "undefined"

                    ? window.currentSceneId

                    : null;

                const safeLineId =

                  ln && typeof ln.id === "string"

                    ? ln.id

                    : `${safeSceneId || "scene"}:${idx}`;



                const textForServer = (latestTranscript || "").trim();



                // Build a merged Blob from our rolling chunks, if we have any.

                // We always try to prepend the original header chunk so the file

                // is a valid WebM for Whisper and media players.

                let audioBlob = null;

                const header = stt2HeaderChunk;

                const body = stt2BodyChunks;



                if (header || (Array.isArray(body) && body.length > 0)) {

                  const parts = [];

                  if (header) parts.push(header);

                  if (Array.isArray(body)) parts.push(...body);



                  const type =

                    stt2Mime ||

                    (header && header.type) ||

                    (body && body[0] && body[0].type) ||

                    "audio/webm";



                  audioBlob = new Blob(parts, { type });

                }



                // If we somehow have no text, nothing useful to send or show.

                if (!textForServer) {

                  return;

                }



                // If STT2 is on but we never captured audio, surface that explicitly.

                // This is what we expect on iPhone Safari where MediaRecorder audio

                // support is limited.

                if (!audioBlob) {

                  updateSttOverlay(

                    [

                      "STT2 (client) no-audio",

                      `line: ${ln?.speaker || "?"}`,

                      `local: ${textForServer}`,

                      "note: no audio blob — MediaRecorder/audio capture not available in this browser"

                    ].join("\n")

                  );

                  // Still do normal local cueing; this is debug-only.

                  return;

                }



                // Normal server path when we *do* have audio.

                (async () => {

                  const startedAt = performance.now();

                  const resp = await sendSttChunkToServer({

                    audioBlob,

                    scriptId: safeScriptId || undefined,

                    sceneId: safeSceneId || undefined,

                    lineId: safeLineId || undefined

                  });

                  const dur = Math.round(performance.now() - startedAt);



                  if (!resp || resp.ok !== true) {

                    const errCode = resp && typeof resp.error === "string" ? resp.error : "unknown";

                    const msg =

                      resp && typeof resp.message === "string"

                        ? resp.message

                        : "";

                    updateSttOverlay(

                      [

                        "STT2 (server) error",

                        `line: ${ln?.speaker || "?"}`,

                        `local: ${textForServer}`,

                        `error: ${errCode}`,

                        msg ? `message: ${msg.slice(0, 160)}` : "",

                        `latency: ${dur} ms`,

                      ].filter(Boolean).join("\n")

                    );

                    return;

                  }



                  const remoteText = String(resp.text || resp.transcript || "").trim();

                  updateSttOverlay(

                    [

                      "STT2 (server) OK",

                      `line: ${ln?.speaker || "?"}`,

                      `local: ${textForServer}`,

                      `server: ${remoteText || "(empty)"}`,

                      `latency: ${dur} ms`,

                    ].join("\n")

                  );

                })();

              }

            } catch (err) {

              console.error("[stt2] mirror error", err);

            }

          }



          const dashy = endsWithDashy(ln.text); // only end-dash matters

          const shouldAdvance = readyForAdvance({

            text: ln.text,

            interim: latestTranscript,

            isSilentNow: !speaking,

            elapsedMs: elapsed,

            lastAdvanceAt,

            dashyMode: dashy

          });

          const enoughElapsed = elapsed >= minElapsedFor(ln.text);

          const timeSinceEnergy = now - (lastEnergyAt || now);

          const enoughSilence = timeSinceEnergy >= Math.min(

            1100,

            Math.max(180, silenceDebounceFor(ln.text))

          );



          // Treat long / multi-sentence lines more cautiously so they don't

          // advance as soon as the first short phrase ("Yeah. Me too.") gets

          // a final STT result.

          const text = (ln.text || "");

          const words = text.split(/\s+/).filter(Boolean);

          const sentenceCount = text.split(/[.?!]/).filter(s => s.trim().length > 0).length;

          const isLongOrMultiSentence = (words.length >= 10) || (sentenceCount >= 2);



          // For long/multi-sentence lines, ignore bare "isFinal" unless we either

          // have strong coverage (sttConfident) or a real silence gap.

          let allowFinal = isFinal;

          if (isLongOrMultiSentence && !sttConfident && !enoughSilence) {

            allowFinal = false;

          }



          // Line length buckets

          const isShortLine = words.length <= 3;

          const goodCoverage = ratio >= 0.72; // enough of the line has been spoken



          // On-result auto-advance now applies to *all* user lines (dash or not).

          if (isShortLine) {

            // Very short lines stay snappy but don't require the exact last word.

            if (

              shouldAdvance &&

              enoughElapsed &&

              (allowFinal || enoughSilence || sttConfident)

            ) {

              return advanceFromMyLine();

            }

          } else {

            // Longer lines: need decent coverage and either a real silence gap

            // or a high-confidence STT match, but no strict last-word match.

            if (

              shouldAdvance &&

              enoughElapsed &&

              goodCoverage &&

              (allowFinal || enoughSilence || sttConfident)

            ) {

              return advanceFromMyLine();

            }

          }



          // Always arm the silence debounce as a safety net.

          armSilenceDebounce();

        };

      }



      setInterval(()=>{

        if(!(sr && srToggleOn && srPermGranted)) return;

        if(!(onMyLine()) || (E.inlineForm&&E.inlineForm.isConnected)) return;

        if(!srActive){ try{ sr.start(); }catch{} }

      }, 300);

  

        $("#btnMic")?.addEventListener("click", async ()=>{

          const srAvailable = !!sr;

          if(!srAvailable){

            if(!srToggleOn){

            try{ await navigator.mediaDevices.getUserMedia({audio:true}); await startMicMonitor(); srPermGranted = true; srToggleOn = true; }

            catch{ srToggleOn = false; }

          }else{ srToggleOn = false; stopMicMonitor(); }

          updateMicBadge(); return;

        }

        if(!srToggleOn){

          const ok=await requestMicPermissionOnce();

          srToggleOn=ok;

          if(ok){ await startMicMonitor(); await (onMyLine()?maybeSetMyLineStart():Promise.resolve()); }

        }else{

          srToggleOn=false;

          try{ sr.stop(); }catch{}

          clearMy(); stopMicMonitor();

        }

        updateMicBadge();

      });



      // OpenAI pre-render (status shows actual error text)

      const RR = { map: new Map(), failures: 0, rendering: false, dotsTimer: null, dotsState: [0,0,0] };



      function primeReaderFromCacheIfAvailable(){

        try{

          if(RR.map && RR.map.size){

            if(hasR()){

              try{ preloadReaderBuffers(); }catch{}

            }

            return true;

          }

          const cached = ReaderCache.get();

          if(cached && typeof cached.size === "number" && cached.size){

            if(hasR()){

              R.readerBuffers = new Map();

              R.readerLoading = false;

            }

            resetReaderActiveSources();

            RR.map = new Map(cached);

            if(hasR()){

              try{ preloadReaderBuffers(); }catch{}

            }

            return true;

          }

        }catch{}

        return false;

      }



      primeReaderFromCacheIfAvailable();

      function setRehearseRenderStatus(msg, cls){

        const el = $("#rehearseRenderStatus");

        el.innerHTML = "";

        if(!msg){ el.textContent = " "; }

        else{

          const span = document.createElement("span");

          if(cls) span.style.color = (cls==="ok"? "var(--ok)" : cls==="err" ? "var(--danger)" : cls==="warn" ? "var(--warn)" : "var(--muted)");

          span.textContent = msg + " ";

          el.appendChild(span);

        }



        if(hasR() && R.btnRender){

          const btn = R.btnRender;

          const base = btn.dataset.defaultLabel || "Render";

          if(!btn.dataset.defaultLabel) btn.dataset.defaultLabel = base;

          if(RR.rendering){

            btn.disabled = true;

            btn.classList.add("progressing");

            btn.textContent = "Rendering…";

          } else {

            btn.disabled = false;

            btn.classList.remove("progressing");

            btn.textContent = base;

          }

        }

      }



      function startDots(){

        stopDots();

        RR.dotsState = [0,0,0];

        RR.dotsTimer = setInterval(()=>{

          if(RR.dotsState.join("")==="000"){ RR.dotsState=[1,0,0]; }

          else if(RR.dotsState[0]){ RR.dotsState=[0,1,0]; }

          else if(RR.dotsState[1]){ RR.dotsState=[0,0,1]; }

          else { RR.dotsState=[0,0,0]; }

          setRehearseRenderStatus("Preparing voices…"," ");

        }, 320);

      }



      function stopDots(){

        if(RR.dotsTimer){

          clearInterval(RR.dotsTimer);

          RR.dotsTimer=null;

          RR.dotsState=[0,0,0];

        }

      }



      async function renderRehearseVoices(){

        if(RR.rendering) return;

        const scene = getScene();

        const list  = buildFiltered(scene);

        if(!list.length){ setRehearseRenderStatus("No lines to render.","err"); return; }



  RR.rendering = true; RR.failures = 0; RR.map.clear();

        if(hasR()){ R.readerBuffers = new Map(); R.readerLoading = false; }

        resetReaderActiveSources();

        startDots();

        setRehearseRenderStatus("Preparing voices…"," ");



        const voiceFor = (name)=> (S.voice_map[name] || S.supportedVoices[0] || "alloy");

        const model    = ($("#selTtsModel")).value || "tts-1";



        const CONCURRENCY = 2;       // keep bursts gentle across all devices

        const MAX_ATTEMPTS = 3;

        const TIMEOUT_MS   = 45000;  // occasional cold starts or queueing



        let i = 0, done = 0, firstErr = null;

        const run = async () => {

          for(;;){

            const myIndex = i++;

            if (myIndex >= list.length) return;



            const ln = list[myIndex];

            if (ln.speaker === myName()){ done++; setRehearseRenderStatus(`Preparing voices… ${done}/${list.length}`," "); continue; }



            let countedByAttempt = false;

            const attempt = async (n) => {

              const ctrl = new AbortController();

              const to   = setTimeout(()=>ctrl.abort(), TIMEOUT_MS);

              try {

                // normalize & guard input

                const cleanText = (ln.text || "").replace(/\s+/g, " ").trim();

                if (!cleanText) {

                  countedByAttempt = true;

                  done++;

                  setRehearseRenderStatus(`Preparing voices… ${done}/${list.length}`, "");

                  return;

                }



                // On final attempt, force a safe fallback voice

                const useFallbackVoice = (n === MAX_ATTEMPTS);

                const voiceName = useFallbackVoice ? "alloy" : voiceFor(ln.speaker);



                const r = await fetch("/debug/tts_line", withSecretHeaders({

                  method: "POST",

                  headers: { ...JSON_HDRS, "Accept": "application/json" },

                  body: JSON.stringify({ voice: voiceName, model, text: cleanText }),

                  signal: ctrl.signal

                }));

                if(handleUnauthorized(r)){

                  setRehearseRenderStatus("Locked.","err");

                  const err = new Error("unauthorized");

                  err.code = 401;

                  err.retry = false;

                  throw err;

                }

                const txt = await r.text();

                let j = {};

                try { j = JSON.parse(txt); } catch { /* non-JSON body */ }



                if (r.ok && j && j.url) return j.url;



                // If OpenAI says quota exceeded (HTTP 429), don't retry — surface a clear error.

                if (r.status === 429) {

                  const msg = (j?.error?.message || j?.message || txt || "quota exceeded").toString().slice(0, 240);

                  const err = new Error("quota-exceeded: " + msg);

                  err.code = 429;

                  err.retry = false;

                  throw err;

                }



                // Map common upstream failures to a retryable bucket

                if ([408, 409, 425, 500, 502, 503, 504].includes(r.status)) {

                  const err = new Error("retryable " + r.status + (j?.error ? ` ${j.error}` : ""));

                  err.code = r.status;

                  err.retry = true;

                  throw err;

                }



                // surface a shorter, cleaner message

                const snippet = (txt || "").toString().slice(0, 120).replace(/\s+/g, " ");

                throw new Error(`bad ${r.status} ${snippet}`);

              } catch (e) {

                if (e?.code === 429) throw e; // do not retry quota errors

                if (e?.retry === false) throw e;

                if (n < MAX_ATTEMPTS) {

                  const backoff = 400 * Math.pow(2, n) + Math.random()*150;

                  await new Promise(res => setTimeout(res, backoff));

                  return attempt(n+1);

                }

                throw e;

              } finally { clearTimeout(to); }

            };



            let url;

            try {

              url = await attempt(0);

              if (url) RR.map.set(myIndex, url);

            } catch(e) {

              RR.failures++; if(!firstErr) firstErr = String(e||"error");

            } finally {

              if (!countedByAttempt) {

                done++;

                if (done % 2 === 0) setRehearseRenderStatus(`Preparing voices… ${done}/${list.length}`, "");

              }

            }

          }

        };



        await Promise.all(Array.from({length:CONCURRENCY}, run));

        RR.rendering = false; stopDots();
        ReaderCache.set(RR.map);
        // Count rehearse render once completed successfully
        try {
          // Only count if we actually rendered without failures
          if ((RR.failures || 0) === 0 && RR.map && RR.map.size) {
            const idempotencyKey = crypto.randomUUID();
            const resp = await fetch("/auth/billing/note_render_complete", withSecretHeaders({
              method: "POST",
              headers: { ...JSON_HDRS, "Accept": "application/json" },
              body: JSON.stringify({ source: "rehearse", idempotencyKey }),
            }));
            if (resp.ok && typeof refreshAuthUI === "function") {
              await refreshAuthUI();
            }
          }
        } catch (e) {
          console.warn("note_render_complete failed", e);
        }



        const okCount = RR.map.size;

        const errText = String(firstErr || "");

        if (!okCount && /quota-exceeded|exceeded your current quota|HTTP 429/i.test(errText)) {

          setRehearseRenderStatus(

            "OpenAI quota exceeded — add credits or raise your limit, then try again.",

            "err"

          );

        } else {

          setRehearseRenderStatus(

            okCount

              ? `Voices ready: ${okCount} lines${RR.failures ? ` (fallback on ${RR.failures})`:""}`

              : `No OpenAI clips prepared${firstErr ? ` — error: ${errText.slice(0,160)}` : ""}`,

            okCount ? (RR.failures ? "warn":"ok") : "err"

          );

        }

        try{ preloadReaderBuffers(); }catch{}

      }

  function clearRehearseRender(){

    RR.map.clear();

    RR.failures=0;

    stopDots();

    R.readerBuffers = new Map();

    resetReaderActiveSources();

    R.readerLoading=false;

    try{ if(E?.rehearseAudio){ E.rehearseAudio.pause(); E.rehearseAudio.removeAttribute("src"); E.rehearseAudio.load(); } }catch{}

    try{ window.__OB_LAST_READER_URL = null; }catch{}

    setRehearseRenderStatus("Cleared pre-render.","warn");

  }

      $("#btnRehearseRender")?.addEventListener("click", renderRehearseVoices);

      $("#btnRehearseClear")?.addEventListener("click", clearRehearseRender);



      async function playOpenAiIfCached(i){

        const buf = R.readerBuffers.get(i);

        if(buf){

          await ensureReaderCtx();

          if(!R.readerCtx || !R.readerGain) return false;

          const ctx = R.readerCtx;

          const lookahead = 0.05;

          const startAt = Math.max((ctx.currentTime||0) + lookahead, 0);

          const src = ctx.createBufferSource();

          src.buffer = buf;

          const g = ctx.createGain();

          const fadeInEnd = startAt + 0.03;

          const fadeOutStart = Math.max(startAt, startAt + buf.duration - 0.02);

          g.gain.setValueAtTime(0.0001, startAt);

          g.gain.linearRampToValueAtTime(1.0, fadeInEnd);

          g.gain.setValueAtTime(1.0, fadeOutStart);

          g.gain.linearRampToValueAtTime(0.0001, startAt + buf.duration);

          src.connect(g);

          g.connect(R.readerGain);

          if(R.readerActiveSources) R.readerActiveSources.add(src);

          const done = new Promise(res=>{ src.onended=()=>res(null); src.onerror=()=>res(null); });

          src.start(startAt);

          try{

            await done;

          } finally {

            try{ R.readerActiveSources?.delete(src); }catch{}

            try{ src.disconnect(); g.disconnect(); }catch{}

          }

          return true;

        }



        const url = RR.map.get(i);

        if(!url) return false;

        try{

          const bustedUrl = url + (url.includes("?") ? "&" : "?") + "t=" + Date.now();

          E.rehearseAudio.src = bustedUrl;

          rememberReaderUrl(bustedUrl);

          await E.rehearseAudio.play();

          await new Promise(res=>{ E.rehearseAudio.onended=()=>res(null); E.rehearseAudio.onerror=()=>res(null); });

          return true;

        }catch{}

        finally{

          E.rehearseAudio.onended = null;

          E.rehearseAudio.onerror = null;

        }

        return false;

      }



      async function playPartnerLine(index, { immediate = false } = {}){

        const list = filtered();

        if(!list.length) return false;

        const ln = list[index];

        if(!ln || ln.speaker === myName()) return false;

        const paceSelect = document.getElementById("selPace");

        let pace = Number((paceSelect && paceSelect.value) || 0);

        if(Number.isNaN(pace)) pace = 0;

        if(tightMode() || immediate) pace = 0;

        const usedOpenAi = await playOpenAiIfCached(index);

        if(usedOpenAi){

          if(pace > 0){ await new Promise(r=>setTimeout(r, pace)); }

          return true;

        }



        const readerUrl = (E.rehearseAudio?.src || "").trim() || (window.__OB_LAST_READER_URL || "").trim() || (hasR() ? (R.download_url || "").trim() : "");

        if(!readerUrl){

          alert('Please tap "Render for rehearsal (OpenAI)" first to generate the reader audio.');

          playing = false;

          $("#btnPlay").textContent = "Play";

          return false;

        }



        const audio = E.rehearseAudio || getReaderEl();

        try{

          if(audio){

            if(audio.src !== readerUrl){

              audio.src = readerUrl;

              rememberReaderUrl(readerUrl);

              try{ audio.load(); }catch{}

            }

            await new Promise(res=>{

              const done = ()=>{ audio.onended=null; audio.onerror=null; res(null); };

              audio.onended = done;

              audio.onerror = done;

              try{ audio.play(); }catch{ done(); }

            });

          }

        }catch(e){

          console.error("Rehearse reader playback failed", e);

        }

        playing = false;

        $("#btnPlay").textContent = "Play";

        return true;

      }



        async function step(playMode, opts = {}){

          const list=filtered(); if(!list.length) return;

          const immediate = !!opts.immediate;

          const ln=current(); if(!ln){ playing=false; $("#btnPlay").textContent="Play"; return; }

          // keep bubble synced even if audio fails

          highlightCurrent();



          if(ln.speaker===myName()){

            if(sr && srToggleOn && srPermGranted){ advanceLock=false; maybeSetMyLineStart(); return; }

            if(playMode){ playing=false; $("#btnPlay").textContent="Play"; }

          }else{

            const i = idx;

            await playPartnerLine(i, { immediate });

            if(playing){ idx=Math.min(idx+1,list.length-1); step(true); }

          }

        }



        async function rehearseCountInIfNeeded(){

          const sel = document.getElementById("selRehearseCountIn");

          const secs = Number(sel?.value || 0);

          if(!secs || secs <= 0) return;



          const overlay = document.getElementById("countdown");

          const num = document.getElementById("countNum");



          // Use the shared audioCtx used elsewhere in the app

          await ensureAudioContext();

          const ctx = window.audioCtx;

          if(!ctx) return;

          if(ctx.state !== 'running'){

            try{ await ctx.resume(); }catch{}

          }



          if(overlay){

            overlay.style.display = "flex";

            overlay.setAttribute("aria-hidden","false");

          }



          const N = Math.min(10, Math.max(1, secs));



          const playBeep = (freq, durSec = 0.28) => new Promise(res => {

            try{

              const o = ctx.createOscillator();

              const g = ctx.createGain();

              o.type = 'sine';

              o.frequency.value = freq;

              g.gain.value = 0.0001;

              const now = ctx.currentTime;

              g.gain.setValueAtTime(0.0001, now);

              g.gain.exponentialRampToValueAtTime(0.6, now + 0.01);

              g.gain.exponentialRampToValueAtTime(0.0001, now + durSec);

              o.connect(g).connect(ctx.destination);

              o.start(now);

              o.stop(now + durSec);

              o.onended = () => {

                try{ o.disconnect(); g.disconnect(); }catch{}

                res();

              };

            }catch{ res(); }

          });



          for(let i = N; i >= 1; i--){

            if(!playing) break; // allow user to cancel during countdown

            if(num) num.textContent = String(i);

            await playBeep(i === 1 ? 660 : 880, 0.28);

            await new Promise(r => setTimeout(r, 720));

          }



          if(overlay){

            overlay.style.display = "none";

            overlay.setAttribute("aria-hidden","true");

          }

        }



    $("#btnPlay")?.addEventListener("click",async ()=>{

      await ensureAudioContext();

      try { await window.__OB_READER_EL?.setSinkId?.('default'); } catch {}

      try{ hardResumeOnGesture().catch(()=>{}); }catch{};

      const btnPlayEl = $("#btnPlay");

      const wantsPlay = !playing;



      if(wantsPlay){

        const hasPerLineClips = (RR?.map && RR.map.size > 0) || (hasR() && R.readerBuffers && R.readerBuffers.size > 0);

        const knownUrl = (E.rehearseAudio?.src || "").trim() || (window.__OB_LAST_READER_URL || "").trim() || (hasR() ? (R.download_url || "").trim() : "");

        if(!hasPerLineClips && !knownUrl){

          playing = false;

          if(btnPlayEl){ btnPlayEl.textContent = "Play"; }

          alert('Please tap "Render for rehearsal (OpenAI)" first to generate the reader audio.');

          return;

        }

        if(!hasPerLineClips && knownUrl && E.rehearseAudio && !E.rehearseAudio.src){

          E.rehearseAudio.src = knownUrl;

          rememberReaderUrl(knownUrl);

          try{ E.rehearseAudio.load(); }catch{}

        }

      }



      playing = wantsPlay;

      if(btnPlayEl) btnPlayEl.textContent = playing ? "Pause" : "Play";



      if(playing){

        // Optional count-in for Rehearse (0 / 3 / 5 / 10 seconds)

        await rehearseCountInIfNeeded();

        // User may have tapped Play again during the countdown

        if(!playing){

          if(btnPlayEl) btnPlayEl.textContent = "Play";

          return;

        }



        const reader = getReaderEl();

        if (window.__OB_NEEDS_UNLOCK && getReaderEl() && window.__OB_LAST_READER_URL) {

          await restoreAudioRoute('play');

          const _el = getReaderEl();

          if (_el) {

            try {

              await _el.play();

              window.__OB_NEEDS_UNLOCK = false;

              if (btnEnableAudio) btnEnableAudio.style.display = 'none';

            } catch (err) {

              console.debug('[AUDIO] play blocked; prompting unlock', err);

              window.__OB_NEEDS_UNLOCK = true;

              if (btnEnableAudio) btnEnableAudio.style.display = '';

            }

          }

        }



        try{

          const cur = current();

          const micOn = !!(srToggleOn && srPermGranted);

          // If the mic is OFF, keep legacy behavior and skip ahead to the first partner line.

          // If the mic is ON, stay on my line so the app can listen and advance from my cue.

          if(cur && cur.speaker === myName() && !micOn){

            const list = filtered();

            for(let i = idx; i < list.length; i++){

              if(list[i] && list[i].speaker !== myName()){ idx = i; break; }

            }

            highlightCurrent();

          }

        }catch{}



        step(true);

      }

      else { try{ E.rehearseAudio?.pause(); }catch{}; try{ sr?.stop(); }catch{}; clearMy(); }

    });

      $("#btnPrev")?.addEventListener("click",()=>{ const list=filtered(); if(!list.length) return; try{ sr?.stop(); }catch{}; clearMy(); idx=Math.max(0,idx-1); highlightCurrent(); if(playing) step(true); else maybeSetMyLineStart(); });

  $("#btnNext")?.addEventListener("click",async ()=>{

        await ensureAudioContext();

        try { await window.__OB_READER_EL?.setSinkId?.('default'); } catch {}

        try{ hardResumeOnGesture().catch(()=>{}); }catch{};

        const list=filtered();

        if(!list.length) return;

        try{ sr?.stop(); }catch{};

        clearMy();

        const reader = getReaderEl();

        if (window.__OB_NEEDS_UNLOCK && getReaderEl() && window.__OB_LAST_READER_URL) {

          await restoreAudioRoute('play');

          const _el = getReaderEl();

          if (_el) {

            try {

              await _el.play();

              window.__OB_NEEDS_UNLOCK = false;

              if (btnEnableAudio) btnEnableAudio.style.display = 'none';

            } catch (err) {

              console.debug('[AUDIO] play blocked; prompting unlock', err);

              window.__OB_NEEDS_UNLOCK = true;

              if (btnEnableAudio) btnEnableAudio.style.display = '';

            }

          }

        }

        idx=Math.min(list.length-1,idx+1);

        highlightCurrent();

        if(playing) step(true);

        else maybeSetMyLineStart();

      });

      $("#btnTop")?.addEventListener("click",()=>{ try{ sr?.stop(); }catch{}; clearMy(); idx=0; highlightCurrent(); if(playing) step(true); else maybeSetMyLineStart(); });



      const ROUTE_WARN_ALERT = 'If the reader audio disappears during your line:\n' +

        '1) Flip the iPhone ringer switch ON (side of the phone).\n' +

        '2) Settings → Bluetooth → your headphones → prefer media audio.\n' +

        '3) Try wired earbuds or toggle Mic Off for a pass.';



      document.getElementById('routeWarnMore')?.addEventListener('click', ()=>{ alert(ROUTE_WARN_ALERT); });

      document.getElementById('routeWarnMoreRecord')?.addEventListener('click', ()=>{ alert(ROUTE_WARN_ALERT); });



      $("#btnToggleEditMode")?.addEventListener("click",()=>{ S.editMode=!S.editMode; applyEditModeUI(); });

      function applyEditModeUI() {

        const btn = $("#btnToggleEditMode");

        const stateEl = $("#editModeState");

        const linesRoot = $("#lines");



        if (btn) {

          btn.setAttribute("aria-pressed", S.editMode ? "true" : "false");

        }

        if (stateEl) {

          stateEl.textContent = S.editMode ? "On" : "Off";

        }



        if (linesRoot) {

          try {

            $$(".editbar", linesRoot).forEach(el => {

              el.style.display = S.editMode ? "flex" : "none";

            });

            $$(".inline-slot", linesRoot).forEach(el => {

              el.style.display = S.editMode ? "flex" : "none";

            });

          } catch (_) {

            // ignore

          }

        }



        if (E.inlineForm && E.inlineForm.isConnected) {

          try {

            E.inlineForm.remove();

          } catch (_) {}

          E.currentSlotPlace = null;

        }

      }



      // === UI NOTE WIRING ===========================================================

      // Guard against double-binding across hot reloads

      if (!window.__OB_UI_NOTES_WIRED__) {

        window.__OB_UI_NOTES_WIRED__ = true;



        // 1) Any button click anywhere (including tabbar, rail, inner-tabs, gallery)

        document.addEventListener('click', (ev) => {

          const btn = ev.target && (ev.target.closest('button') || ev.target.closest('[role="button"]'));

          if (!btn) return;

          // If audio is locked, kick the shared unlock helper; it will decide whether

          // to clear __OB_NEEDS_UNLOCK and hide the Enable Audio button.

          if (window.__OB_NEEDS_UNLOCK && typeof tryUnlockAudio === 'function') {

            try { tryUnlockAudio('ui-click').catch(() => {}); } catch {}

          }

          try { UINotes.pingFor(btn, 'click'); } catch {}

        }, { passive: true });



        // 2) Important non-button controls

        //    - file chooser changes

        document.addEventListener('change', (ev) => {

          const input = ev.target && ev.target.closest('input[type="file"]');

          if (input) { try { UINotes.pingFor(input, 'change:file'); } catch {} }

        }, { passive: true });



        //    - selects (role, pacing, etc.)

        document.addEventListener('change', (ev) => {

          const sel = ev.target && ev.target.closest('select');

          if (sel) { try { UINotes.pingFor(sel, 'change:select'); } catch {} }

        }, { passive: true });



        //    - tab switches via nav (dataset.tab)

        document.querySelectorAll('.tabbar [data-tab]').forEach(btn => {

          btn.addEventListener('click', () => { try { UINotes.pingFor(btn, 'tab'); } catch {} }, { passive: true });

        });



        //    - inner Import tabs

        ['#tab-text', '#tab-pdf'].forEach(q => {

          const el = document.querySelector(q);

          if (el) el.addEventListener('click', () => { try { UINotes.pingFor(el, 'inner-tab'); } catch {} }, { passive: true });

        });



        //    - Gallery card actions (play / download / delete)

        document.addEventListener('click', (ev) => {

          const actBtn = ev.target && ev.target.closest('.take-card [data-act]');

          if (actBtn) { try { UINotes.pingFor(actBtn, 'gallery'); } catch {} }

        }, { passive: true });

      }



      /* ----------------- RECORD TAB (updated for 16x9 + right rail) ----------------- */



      /* --- Orientation-aware preview aspect --- */

      function applyPreviewAspect(portrait = isPortrait()){

        const aspectRatio = portrait ? "9/16" : "16/9";

        const logicalAspect = portrait ? "9:16" : "16:9";

        const previewEl = (typeof R !== "undefined" && hasR() && R?.preview) || document.getElementById("preview");

        if(previewEl){

          previewEl.style.aspectRatio = aspectRatio;

        }

        try{ document.documentElement?.style.setProperty("--preview-ar", aspectRatio); }catch{}

        if(hasR()){ R.currentAspect = logicalAspect; }

      }



      function updateRecordLayout(){

        try{ applyPreviewAspect(isPortrait()); }catch{}

        try{ syncGridOverlayVisibility(); }catch{}

      }



  window.addEventListener("resize", ()=>{ updateRecordLayout(); try{ syncGridOverlayVisibility(); }catch{} });

  window.addEventListener("orientationchange", ()=>{ updateRecordLayout(); try{ syncGridOverlayVisibility(); }catch{} });



      R = {

        btnRender: $("#btnRender"),

        btnRec: $("#btnRec"),

        btnGrid: $("#btnGrid"),

        btnCamera: $("#btnCamera"),

        btnCountIn: $("#btnCountIn"),

        btnHeadphones: $("#btnHeadphones"),

        audio: $("#readerAudio"),

        preview: $("#preview"),

        countdown: null,

        chunks: [],

        rec: null,

        stream: null,

    render_id: "",

    download_url: "",

    cameraOn: false,

    countInOn: false,

    headphonesOn: true,

    recording: false,

        prevSrToggle: null,

        facing: "user",               // or "environment"

        mixCtx: null,

        mixDest: null,

        mixGainReader: null,

        mixGainMic: null,

        micHPF: null,

        micCompressor: null,

        readerCtx: null,

        readerGain: null,

        readerBuffers: new Map(),

        readerLoading: false,

        readerDirectConnected: false,

        readerBridge: null,

        readerBridgeSource: null,

        readerRecordGain: null,

        readerActiveSources: new Set(),

        duckHintShown: false,

    currentAspect: isPortrait() ? "9:16" : "16:9",

    forcePerLine: false,

    gridOn: false,

    countInSecs: 3,

      };

      // Restore render_id from localStorage for Room export
      if (!R.render_id) {
        try {
          R.render_id = localStorage.getItem("offbook:last_render_id") || "";
        } catch (e) {
          console.warn("[offbook] Failed to restore render_id:", e);
        }
      }

      if(R.btnRender && !R.btnRender.dataset.defaultLabel){

        R.btnRender.dataset.defaultLabel = R.btnRender.textContent || "Render";

      }

      R.audio?.setAttribute("playsinline","");

      if(typeof window !== "undefined" && R.audio){ window.__OB_READER_EL = R.audio; }



      function setStatusRec(t){

        const btn = R.btnRender;

        if(!btn) return;

  const base = btn.dataset.defaultLabel || "Render";

  if(!btn.dataset.defaultLabel) btn.dataset.defaultLabel = base;

        const text = (t && String(t).trim()) ? t : base;

        btn.classList.remove("progressing");

        btn.textContent = text;

      }



      function restoreReaderDirectMonitor(){

        if(R.readerCtx && R.readerGain){

          try{ R.readerGain.disconnect(); }catch{}

          try{ R.readerGain.__obProbeConnected = false; }catch{}

          try{ tapReaderNode(R.readerGain); R.readerGain.connect(R.readerCtx.destination); R.readerDirectConnected = true; }

          catch{}

        }

        R.readerBridge = null;

        R.readerBridgeSource = null;

        R.readerRecordGain = null;

      }



      async function preloadReaderBuffers(){

        if(!RR.map || !RR.map.size || (hasR() && R.readerLoading)) return;

        if(!hasR()) return;

        R.readerLoading = true;

        try{

          await ensureReaderCtx();

          const entries = Array.from(RR.map.entries());

          let idx = 0;

          const workers = Math.min(3, entries.length);

          async function worker(){

            for(;;){

              const current = idx++;

              if(current >= entries.length) break;

              const [i, url] = entries[current];

              if(R.readerBuffers.has(i)) continue;

              try{

                const suffix = url.includes("?") ? "&" : "?";

                const resp = await fetch(url + suffix + "t=" + Date.now());

                if(!resp.ok) continue;

                const buf = await resp.arrayBuffer();

                const ctx = R.readerCtx;

                if(!ctx) continue;

                const audio = await new Promise((resolve,reject)=>{

                  try{

                    const maybe = ctx.decodeAudioData(buf, resolve, reject);

                    if(maybe && typeof maybe.then === "function") maybe.then(resolve).catch(reject);

                  }catch(e){ reject(e); }

                });

                if(audio) R.readerBuffers.set(i, audio);

              }catch{}

            }

          }

          await Promise.all(Array.from({length:workers}, ()=>worker()));

        }catch{}

        finally{ if(hasR()) R.readerLoading = false; }

      }



      function micConstraints(recordingPhase){

        if(recordingPhase){

          return {

            echoCancellation: false,

            noiseSuppression: false,

            autoGainControl: false,

            channelCount: 1,

            sampleRate: 48000,

            sampleSize: 16,

            advanced: [

              { echoCancellation:false },

              { noiseSuppression:false },

              { autoGainControl:false },

              { googEchoCancellation:false },

              { googAutoGainControl:false },

              { googNoiseSuppression:false }

            ]

          };

        }

        return {

          echoCancellation: true,

          noiseSuppression: true,

          autoGainControl: false,

          channelCount: 1

        };

      }



      async function ensureReaderCtx(){

        if(R.readerCtx && R.readerCtx.state === "closed"){ R.readerCtx = null; R.readerGain = null; R.readerDirectConnected = false; }

        if(!R.readerCtx){

          R.readerCtx = new (window.AudioContext||window.webkitAudioContext)();

          if(R.readerCtx?.state === "suspended"){ try{ await R.readerCtx.resume(); }catch{} }

          R.readerGain = R.readerCtx.createGain();

          R.readerGain.gain.value = 1.0;

          try{ R.readerGain.__obProbeConnected = false; }catch{}

          tapReaderNode(R.readerGain);

          try{ R.readerGain.connect(R.readerCtx.destination); R.readerDirectConnected = true; }

          catch{}

          R.readerActiveSources = new Set();

        }else if(R.readerCtx?.state === "suspended"){

          try{ await R.readerCtx.resume(); }catch{}

        }

        return R.readerCtx;

      }



      function restoreReaderDirectMonitor(){

        if(R.readerCtx && R.readerGain){

          try{ R.readerGain.disconnect(); }catch{}

          try{ R.readerGain.__obProbeConnected = false; }catch{}

          try{ tapReaderNode(R.readerGain); R.readerGain.connect(R.readerCtx.destination); R.readerDirectConnected = true; }

          catch{}

        }

        R.readerBridge = null;

        R.readerBridgeSource = null;

        R.readerRecordGain = null;

      }



      function setRailStates(){

        R.btnCamera.setAttribute("aria-pressed", R.cameraOn ? "true":"false");

        R.btnCamera.textContent = "Camera: " + (R.cameraOn ? "On" : "Off");

        if(R.btnCountIn){

          R.btnCountIn.setAttribute("aria-pressed", R.countInOn ? "true":"false");

          const countLabel = R.countInOn

            ? `Count-in: On (${Number(R.countInSecs) || 3}s)`

            : "Count-in: Off";

          R.btnCountIn.textContent = countLabel;

        }

        R.btnHeadphones.setAttribute("aria-pressed", R.headphonesOn ? "true":"false");

        R.btnHeadphones.textContent = "Headphones: " + (R.headphonesOn ? "On" : "Off");

        if(R.btnGrid){

          R.btnGrid.setAttribute("aria-pressed", R.gridOn ? "true" : "false");

          R.btnGrid.textContent = "Grid: " + (R.gridOn ? "On" : "Off");

        }

        if(R.recording){ R.btnRec.classList.add("recording"); R.btnRec.textContent = "STOP"; }

        else { R.btnRec.classList.remove("recording"); R.btnRec.textContent = "REC"; }

      }



      function syncGridOverlayVisibility(){

        const ov = document.getElementById("gridOverlay");

        if(!ov) return;

        const show = !!(hasR() && R.gridOn && !isPortrait());

        ov.style.display = show ? "block" : "none";

      }



      syncGridOverlayVisibility();



      function pickMime(video){

        const vids = ["video/mp4;codecs=avc1.42E01E,mp4a.40.2","video/mp4","video/webm;codecs=vp8,opus","video/webm"];

        const auds = ["audio/mp4","audio/webm;codecs=opus","audio/webm"];

        const list = video ? vids : auds;

        for(const m of list){ if(window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)) return m; }

        return "";

      }



      function cleanupStream(){

        try{ R.stream?.getTracks().forEach(t=>t.stop()); }catch{}

        R.stream = null;

        if(R.preview) R.preview.srcObject = null;

      }



      function resetMicAfterRecording(){

        if(R.prevSrToggle === null){ updateMicBadge(); return; }

        const prev = R.prevSrToggle;

        R.prevSrToggle = null;

        if(prev){

          srToggleOn = true;

          startMicMonitor().catch(()=>{});

        }else{

          srToggleOn = false;

          stopMicMonitor();

        }

        updateMicBadge();

      }



      async function buildMixedStreamIfPossible(rawStream){

        if(!rawStream) return rawStream;

        try{

          R.mixCtx = new (window.AudioContext||window.webkitAudioContext)();

          if(R.mixCtx?.state === "suspended"){ try{ await R.mixCtx.resume(); }catch{} }

          const speakers = R.mixCtx.destination;

          R.mixDest = R.mixCtx.createMediaStreamDestination();

          // Create separate destinations for stems (mic-only and reader-only)
          R.micOnlyDest = R.mixCtx.createMediaStreamDestination();
          R.readerOnlyDest = R.mixCtx.createMediaStreamDestination();

          const micNode = R.mixCtx.createMediaStreamSource(rawStream);



          R.micHPF = R.mixCtx.createBiquadFilter();

          R.micHPF.type = "highpass";

          R.micHPF.frequency.value = 120;

          R.micHPF.Q.value = 0.707;



          R.micCompressor = R.mixCtx.createDynamicsCompressor();

          R.micCompressor.threshold.value = -28;

          R.micCompressor.knee.value = 24;

          R.micCompressor.ratio.value = 3;

          R.micCompressor.attack.value = 0.005;

          R.micCompressor.release.value = 0.12;



          R.mixGainMic = R.mixCtx.createGain();

          R.mixGainMic.gain.value = 1.0;



          micNode.connect(R.micHPF);

          R.micHPF.connect(R.micCompressor);

          R.micCompressor.connect(R.mixGainMic);

          R.mixGainMic.connect(R.mixDest);
          R.mixGainMic.connect(R.micOnlyDest);  // Stem: mic-only audio



          R.mixGainReader = R.mixCtx.createGain();

          R.mixGainReader.gain.value = R.headphonesOn ? 1.0 : 0.0;

          const readerRecordGain = R.mixCtx.createGain();

          readerRecordGain.gain.value = 1.0;



          if(R.readerCtx && R.readerGain){

            try{ R.readerGain.disconnect(); R.readerDirectConnected = false; }catch{}

            try{ R.readerGain.__obProbeConnected = false; }catch{}

            try{

              R.readerBridge = R.readerCtx.createMediaStreamDestination();

              R.readerGain.connect(R.readerBridge);

              tapReaderNode(R.readerGain);

              R.readerDirectConnected = false;

              const bridgeSource = R.mixCtx.createMediaStreamSource(R.readerBridge.stream);

              R.readerBridgeSource = bridgeSource;

              bridgeSource.connect(R.mixGainReader);

              bridgeSource.connect(readerRecordGain);

            }catch{}

          }



          const readerEl = (RR.map && RR.map.size>0)

            ? E?.rehearseAudio

            : (R.forcePerLine ? null : R.audio);

          if(readerEl){

            try{

              const src = R.mixCtx.createMediaElementSource(readerEl);

              src.connect(R.mixGainReader);

              src.connect(readerRecordGain);

            }catch(e){

              if(typeof readerEl.captureStream === "function"){

                try{

                  const rs = readerEl.captureStream();

                  const s2 = R.mixCtx.createMediaStreamSource(rs);

                  s2.connect(R.mixGainReader);

                  s2.connect(readerRecordGain);

                }catch{}

              }

            }

          }



          R.mixGainReader.connect(speakers);

          readerRecordGain.connect(R.mixDest);
          readerRecordGain.connect(R.readerOnlyDest);  // Stem: reader-only audio

          R.readerRecordGain = readerRecordGain;



          const tracks = [];

          if(R.cameraOn){

            try{ rawStream.getVideoTracks().forEach(t=>tracks.push(t)); }catch{}

          }

          try{ R.mixDest.stream.getAudioTracks().forEach(t=>tracks.push(t)); }catch{}

          if(tracks.length) return new MediaStream(tracks);

        }catch(e){

          try{ R.mixCtx?.close(); }catch{}

          restoreReaderDirectMonitor();

        }

        R.mixCtx = null;

        R.mixDest = null;

        R.mixGainReader = null;

        R.mixGainMic = null;

        R.micHPF = null;

        R.micCompressor = null;

        R.readerRecordGain = null;

        R.readerBridge = null;

        R.readerBridgeSource = null;

        R.micOnlyDest = null;

        R.readerOnlyDest = null;

        return rawStream;

      }



      /* --- Render reader (animated dots in status) --- */

      async function prepareReader(){

        // Get script_id, scene_id, role with fallback to localStorage
        let script_id = S.script_id;
        let scene_id = S.script_id; // scene_id = script_id in this app
        let role = S.role;

        if(!script_id || !role){
          try{
            const stored = localStorage.getItem("offbook:last_assign");
            if(stored){
              const parsed = JSON.parse(stored);
              if(!script_id && parsed.script_id) script_id = parsed.script_id;
              if(!scene_id && parsed.scene_id) scene_id = parsed.scene_id;
              if(!role && parsed.role) role = parsed.role;
            }
          }catch{}
        }

        if(!script_id || !scene_id || !role){
          setStatusRec("Pick a role in Assign first.");
          return;
        }

        let dots = 0;

        let dotsTimer = setInterval(()=>{

          dots = (dots+1)%4;

          setStatusRec("Preparing reader track" + ".".repeat(dots));

          R.btnRender?.classList.add("progressing");

        }, 320);

        setStatusRec("Preparing reader track.");

        if(R.btnRender){

          R.btnRender.disabled = true;

          R.btnRender.classList.add("progressing");

        }

        try{

          const r = await fetch("/debug/render", withSecretHeaders({ method:"POST", headers:{...JSON_HDRS}, body:JSON.stringify({ script_id, scene_id, role: role.toUpperCase(), pace_ms:0 }) }));

          if(handleUnauthorized(r)){ clearInterval(dotsTimer); setStatusRec("Locked."); R.btnRender.disabled=false; return; }

          const j = await safeJson(r);

          if(!r.ok){ clearInterval(dotsTimer); setStatusRec("Render error "+r.status+": "+JSON.stringify(j)); R.btnRender.disabled=false; return; }

          R.render_id = j.render_id;

          // Persist render_id for Room export
          try {
            localStorage.setItem("offbook:last_render_id", R.render_id);
          } catch (e) {
            console.warn("[offbook] Failed to persist render_id:", e);
          }

          const poll = async ()=>{

            const s = await fetch(`/debug/render_status?render_id=${encodeURIComponent(R.render_id)}`, withSecretHeaders({ headers:{...JSON_HDRS} }));

            if(handleUnauthorized(s)){ clearInterval(dotsTimer); setStatusRec("Locked."); R.btnRender.disabled=false; return; }

            const js = await safeJson(s);

            if(js.status==="complete" && js.download_url){

              R.download_url = js.download_url + "?t=" + Date.now();

              R.audio.src = R.download_url;

              rememberReaderUrl(R.download_url);

              R.audio.load();

              clearInterval(dotsTimer);

              setStatusRec("Reader ready.");

              R.btnRender.disabled = false;

              // After a successful render, refresh entitlement snapshot so the counter updates

              try {

                if (typeof refreshAuthUI === "function") {

                  await refreshAuthUI();

                }

              } catch {

                // best-effort only; don't break playback if this fails

              }

            }else if(js.status==="error"){

              clearInterval(dotsTimer);

              setStatusRec("Render failed: "+(js.error||"unknown")); R.btnRender.disabled=false;

            }else{ setTimeout(poll, 500); }

          };

          setTimeout(poll, 500);

        }catch(e){

          clearInterval(dotsTimer);

          setStatusRec("Network error: "+e); R.btnRender.disabled=false;

        }

      }



      /* --- Count-in: configurable visible countdown --- */

      async function doBeepsAndCountdown(){

        if(!R.countInOn) return;

        const N = Math.min(10, Math.max(3, Number(R.countInSecs) || 3));



        await ensureReaderCtx();

        const ctx = R.readerCtx;

        if(!ctx){ return; }



        if(ctx.state !== 'running'){ try{ await ctx.resume(); }catch{} }



        const overlay = $("#countdown"), num = $("#countNum");

        if(overlay){ overlay.style.display = "flex"; }



        const playBeep = (freq, dur = 0.28) => new Promise(res => {

          try{

            const o = ctx.createOscillator();

            const g = ctx.createGain();

            o.type = 'sine';

            o.frequency.value = freq;

            g.gain.value = 0.18;

            o.connect(g);

            g.connect(ctx.destination);

            o.start();

            setTimeout(()=>{ try{ o.stop(); }catch{}; try{ o.disconnect(); g.disconnect(); }catch{}; res(); }, dur*1000);

          }catch{ res(); }

        });



        for(let i = N; i >= 1; i--){

          if(num) num.textContent = String(i);

          await playBeep(i === 1 ? 660 : 880, 0.28);

          await new Promise(r => setTimeout(r, 720));

        }



        if(overlay){ overlay.style.display = "none"; }

      }



      /* --- Recording flow --- */

      async function startPreviewIfNeeded(forceRestart=false){

        if(!R.cameraOn){

          try{ cleanupStream(); }catch{}

          if(R.preview) R.preview.srcObject=null;

          try{ updateRecordLayout(); }catch{}

          return;

        }

        try{

          if(forceRestart && R.stream){ cleanupStream(); }

          if(!R.stream){

            R.stream = await navigator.mediaDevices.getUserMedia({

              video: { facingMode: R.facing },

              audio: micConstraints(false)

            });

          }

          // after getUserMedia:

          const at = R.stream?.getAudioTracks?.()[0];

          window.__OB_MIC_STREAM = R.stream;

          window.__OB_MIC_TRACK = at || null;

          logRouteCheck('startPreviewIfNeeded');

          if(at){

            const settings = at.getSettings ? at.getSettings() : {};

            console.log("[offbook] mic settings (preview)", settings);

            try{

              const bt = window.__OB_BT_IN || await hasBluetoothInput();

              if (_route.isiOS && (bt || false) && looksLikeHfp(at)) {

                _route.warnActive = true;

                maybeShowRouteModal();

              } else {

                showRouteWarn(false);

              }

            }catch{ showRouteWarn(false); }

            if(!R.duckHintShown && (settings.echoCancellation === true || settings.noiseSuppression === true)){

              setStatusRec("Note: Your device may still apply echo/ducking. Use wired/Bluetooth headphones for best results.");

              R.duckHintShown = true;

            }

          }else{

            logRouteCheck('startPreviewIfNeeded:noTrack');

            showRouteWarn(false);

          }

          if(R.preview){

            try{ R.preview.muted = true; }catch{}

            R.preview.srcObject = R.stream;

            if(typeof R.preview.play === "function"){

              R.preview.play().catch(()=>{});

            }

            try{ updateRecordLayout(); }catch{}

          }

  }catch(e){ logRouteCheck('startPreviewIfNeeded:error'); setStatusRec("Camera/mic permission denied: "+e); }

      }



      let useBackCamera = false;

      async function applyCameraFacing(){

        R.facing = useBackCamera ? "environment" : "user";

        if(!R.cameraOn) return;

        try{

          await startPreviewIfNeeded(true);

          updateRecordLayout();

        }

        catch(e){ setStatusRec("Camera switch error: "+e); }

      }



      async function startRecording(){

        // Guard: prevent concurrent starts or starting during finalize
        if (R._recStarting || R._finalizingTake || R.recording) return;
        R._recStarting = true;

        try {

        // Guard: Ensure render_id exists for Room export
        if (!R.render_id && !localStorage.getItem("offbook:last_render_id")) {
          setStatusRec("Room needs a reader render. Go to Rehearse and tap Render before recording.");
          return;
        }

        await hardResumeOnGesture();

        try { await ensureReaderCtx(); } catch {}

        try { await window.__OB_READER_EL?.setSinkId?.('default'); } catch {}

        await (window.audioCtx?.resume?.() || Promise.resolve());

        await _diagAudioCtx('before-beeps');

        console.debug('[AUDIO] readerEl=', !!window.__OB_READER_EL, 'canPlay=', window.__OB_READER_EL?.readyState);

  primeReaderFromCacheIfAvailable();

  const dashyScene = sceneHasDashyUserLine();

  const hasClipMap = !!(RR.map && RR.map.size > 0);

  const hasSingleTrack = !!R.download_url;

  const usePerLinePlayback = dashyScene || hasClipMap;

  const useSingleTrackPlayback = !usePerLinePlayback && hasSingleTrack;

  const prepped = usePerLinePlayback || hasSingleTrack;

  if(!prepped){ setStatusRec("Render first."); return; }



  R.forcePerLine = dashyScene;



  const useCachedReader = usePerLinePlayback;



        stopAllAudioHard();

        try{ sr?.stop(); }catch{}

        try{ clearMy(); }catch{}



        cleanupStream();

  try{ R.mixCtx?.close(); }catch{}

  R.mixCtx = null; R.mixDest = null; R.mixGainReader = null; R.mixGainMic = null; R.micHPF = null; R.micCompressor = null; R.micOnlyDest = null; R.readerOnlyDest = null;



        let userStream;

        try{

          const needVideo = !!R.cameraOn;

          userStream = await navigator.mediaDevices.getUserMedia({

            audio: micConstraints(true),

            video: needVideo ? { facingMode: R.facing } : false

          });

        }catch(e){ setStatusRec("Permission error: "+e); return; }

        R.stream = userStream;

        // after getUserMedia:

        const track = R.stream?.getAudioTracks?.()[0];

        window.__OB_MIC_STREAM = R.stream;

        window.__OB_MIC_TRACK = track || null;

        logRouteCheck('startRecording');

        if(track){

          const settings = track.getSettings ? track.getSettings() : {};

          console.log("[offbook] mic settings (record)", settings);

          try{

            const bt = window.__OB_BT_IN || await hasBluetoothInput();

            if (_route.isiOS && (bt || false) && looksLikeHfp(track)) {

              _route.warnActive = true;

              maybeShowRouteModal();

            } else {

              showRouteWarn(false);

            }

          }catch{ showRouteWarn(false); }

          if(!R.duckHintShown && (settings.echoCancellation === true || settings.noiseSuppression === true)){

            setStatusRec("Note: Your device may still apply echo/ducking. Use wired/Bluetooth headphones for best results.");

            R.duckHintShown = true;

          }

        }else{

          logRouteCheck('startRecording:noTrack');

          showRouteWarn(false);

        }

        if(R.cameraOn && R.preview){

          R.preview.srcObject = R.stream;

          if(typeof R.preview.play === "function"){ R.preview.play().catch(()=>{}); }

        }



        await doBeepsAndCountdown();



        if(useCachedReader){ try{ await ensureReaderCtx(); }catch{} }

        const finalStream = await buildMixedStreamIfPossible(R.stream);



        R.prevSrToggle = srToggleOn;

        try{

          await requestMicPermissionOnce();

          srToggleOn = true;

          await startMicMonitor();

        }catch{}

        updateMicBadge();



        try{ idx = 0; }catch{}

        try{ highlightCurrent?.(); }catch{}

        try{ clearMy(); }catch{}



        R.chunks = [];

        const mime = pickMime(!!R.cameraOn);

        try{ R.rec = mime ? new MediaRecorder(finalStream, { mimeType: mime }) : new MediaRecorder(finalStream); }

        catch{ R.rec = new MediaRecorder(finalStream); }

        // Create stem recorders (audio-only for mic and reader)
        R.micChunks = [];
        R.readerChunks = [];
        const stemMime = pickMime(false);  // Audio-only mime

        if (R.micOnlyDest && R.readerOnlyDest) {
          try {
            R.recMic = stemMime ? new MediaRecorder(R.micOnlyDest.stream, { mimeType: stemMime }) : new MediaRecorder(R.micOnlyDest.stream);
            R.recMic.ondataavailable = (e) => { if (e.data && e.data.size > 0) R.micChunks.push(e.data); };
          } catch (e) {
            console.warn("[offbook] Failed to create mic stem recorder:", e);
            R.recMic = null;
          }

          try {
            R.recReader = stemMime ? new MediaRecorder(R.readerOnlyDest.stream, { mimeType: stemMime }) : new MediaRecorder(R.readerOnlyDest.stream);
            R.recReader.ondataavailable = (e) => { if (e.data && e.data.size > 0) R.readerChunks.push(e.data); };
          } catch (e) {
            console.warn("[offbook] Failed to create reader stem recorder:", e);
            R.recReader = null;
          }

          // Create stop-promises to ensure stems flush before finalizeTake
          R._micStoppedP = R.recMic ? new Promise(resolve => {
            const prev = R.recMic.onstop;
            R.recMic.onstop = (...args) => { try{ prev && prev.apply(R.recMic,args);}catch{}; resolve(true); };
          }) : Promise.resolve(true);

          R._readerStoppedP = R.recReader ? new Promise(resolve => {
            const prev = R.recReader.onstop;
            R.recReader.onstop = (...args) => { try{ prev && prev.apply(R.recReader,args);}catch{}; resolve(true); };
          }) : Promise.resolve(true);
        }

        R.rec.ondataavailable = (e)=>{ if(e.data && e.data.size>0) R.chunks.push(e.data); };

        R.rec.onstop = async ()=>{

          // Guard: prevent double-execution of onstop handler
          if (R._stopHandled) return;
          R._stopHandled = true;

          try {

          setStatus("Recorder stopped; length (ms) = " + (Date.now() - (R.recordStartMs || Date.now())));

          if(typeof window !== "undefined"){

            window.isRecording = false;

            try{ document.dispatchEvent(new CustomEvent('ob:recording:stopped')); }catch{}

          }

          stopAllAudioHard();

          resetMicAfterRecording();

          try{ R.mixCtx?.close(); }catch{}

          R.mixCtx = null; R.mixDest = null; R.mixGainReader = null; R.mixGainMic = null; R.micHPF = null; R.micCompressor = null;

          R.readerRecordGain = null; R.readerBridge = null; R.readerBridgeSource = null;

          restoreReaderDirectMonitor();

          // iOS-safe delay to let final stem dataavailable events fire
          await new Promise(r => setTimeout(r, 450));

          try{ await finalizeTake(); }

          catch(e){ console.error("[offbook] finalizeTake error", e); setStatusRec("Save failed. Download immediately to keep the take."); }

          cleanupStream();

          if(R.cameraOn){ try{ startPreviewIfNeeded(); }catch{} }

          R.recording=false;

          R.forcePerLine = false;

          setRailStates();

          } finally {
            // Clear transition flags after finalize completes
            R._recStopping = false;
            R._finalizingTake = false;
            R._stopHandled = false;
          }

        };



        R.recording = true;

        if(typeof window !== "undefined") window.isRecording = true;

        setRailStates();

        // Re-arm SR immediately for your first line in Record

        try{

          if(sr && srToggleOn && srPermGranted && onMyLine()){

            try{ sr.stop(); }catch{}

            setTimeout(()=>{ try{ sr.start(); }catch{} }, 50);

          }

        }catch{}



        R.recordStartMs = Date.now();

        // Reset stop handler for new recording session
        R._stopHandled = false;

        try{
          R.rec.start();

          // Successfully started - clear starting flag
          R._recStarting = false;

          // Start stem recorders at the same moment as the main recorder (Room stems)
          // Use timeslice to force chunk emission on iOS
          try {
            if (R.recMic && R.recMic.state === "inactive") {
              try {
                R.recMic.start(750);
              } catch {
                try {
                  R.recMic.start();
                } catch (e) {
                  console.warn("[offbook] recMic.start failed", e);
                }
              }
            }
          } catch (e) {
            console.warn("[offbook] recMic.start failed", e);
          }
          try {
            if (R.recReader && R.recReader.state === "inactive") {
              try {
                R.recReader.start(750);
              } catch {
                try {
                  R.recReader.start();
                } catch (e) {
                  console.warn("[offbook] recReader.start failed", e);
                }
              }
            }
          } catch (e) {
            console.warn("[offbook] recReader.start failed", e);
          }
        } catch(err){
          console.error(err);
          const msg = (err && err.message) ? err.message : String(err);
          const eb = document.getElementById('errbar');
          if (eb) { eb.textContent = msg; eb.style.display = 'block'; }

          setStatus("Record error: " + err);

          R.recording = false;

          if(typeof window !== "undefined"){

            window.isRecording = false;

            try{ document.dispatchEvent(new CustomEvent('ob:recording:stopped')); }catch{}

          }

          setRailStates();

          setStatusRec("Recorder error: "+err);

          stopAllAudioHard();

          resetMicAfterRecording();

          try{ R.mixCtx?.close(); }catch{}

          R.mixCtx = null; R.mixDest = null; R.mixGainReader = null; R.mixGainMic = null; R.micHPF = null; R.micCompressor = null; R.readerRecordGain = null; R.readerBridge = null; R.readerBridgeSource = null;

          restoreReaderDirectMonitor();

          cleanupStream();

          if(R.cameraOn){ try{ startPreviewIfNeeded(); }catch{} }

          return;

        }



    setStatusRec("Recording…");



        await new Promise(r=>setTimeout(r,220));



        if(useCachedReader){

          try{

            playing = true;

            Promise.resolve(step(true, { immediate: dashyScene })).catch(()=>{});

            const endWatch = setInterval(()=>{

              if(!R.recording) return clearInterval(endWatch);

              if(!playing){

                try{ R.rec?.stop(); }catch{}

                clearInterval(endWatch);

              }

            }, 300);

          }catch{}

        }



        if(R.audio){

          if(useSingleTrackPlayback){

            try{ R.audio.currentTime = 0; await R.audio.play(); }catch{}

            R.audio.onended = ()=>{ setTimeout(()=>{ try{ R.rec?.stop(); }catch{} }, 120); };

          }else{

            try{ R.audio.pause(); R.audio.currentTime = 0; }catch{}

            R.audio.onended = null;

          }

        }

        } finally {
          // Ensure _recStarting is cleared if recording didn't start
          if (!R.recording) R._recStarting = false;
        }

      }



      function stopRecording(){

        // Guard: prevent concurrent stops or stopping during finalize
        if (R._recStopping || R._finalizingTake) return;

        if(!R.recording){

          stopAllAudioHard();

          cleanupStream();

          restoreReaderDirectMonitor();

          // Reset flags when not actually recording
          R._recStopping = false;
          R._finalizingTake = false;

          return;

        }

        // Initiate stopping and finalize flags
        R._recStopping = true;
        R._finalizingTake = true;

        // Flush final chunks from stem recorders before stopping
        try { R.recMic?.requestData?.(); } catch {}
        try { R.recReader?.requestData?.(); } catch {}

        try{ R.rec?.stop(); }catch(e){ setStatus("Record error: " + e); }

        // Stop stem recorders
        if (R.recMic) { try { R.recMic.stop(); } catch (e) { console.warn("[offbook] Failed to stop mic stem recorder:", e); } }
        if (R.recReader) { try { R.recReader.stop(); } catch (e) { console.warn("[offbook] Failed to stop reader stem recorder:", e); } }

        R.recording = false;

        R.forcePerLine = false;

        setRailStates();

        setStatusRec("Stopping…");

      }



      async function finalizeTake(){

        const isVid = !!R.cameraOn;

        const blob = new Blob(R.chunks, { type: (R.rec && R.rec.mimeType) ? R.rec.mimeType : (isVid ? "video/mp4" : "audio/mp4") });

        if(!blob || !blob.size){ setStatusRec("No data captured."); return; }

        const aspect = R.currentAspect || (isPortrait() ? "9:16" : "16:9");

        // Assemble stem blobs from captured chunks (after delay has allowed final chunks to arrive)
        const micBlob = (R.micChunks && R.micChunks.length) ? new Blob(R.micChunks, { type: (R.recMic?.mimeType || "audio/m4a") }) : null;
        const readerBlob = (R.readerChunks && R.readerChunks.length) ? new Blob(R.readerChunks, { type: (R.recReader?.mimeType || "audio/m4a") }) : null;

        if (micBlob && readerBlob) {
          console.log("[offbook] Assembled stems:", { micSize: micBlob.size, readerSize: readerBlob.size });
        }

        let savedTake = null;

        try{

          savedTake = await saveTakeToDB({ blob, isVid, aspect, renderId: R.render_id, micBlob, readerBlob });

          setStatusRec("Saved to Gallery.");

        }catch(err){

          console.error("[offbook] take save error", err);

          setStatusRec("Saved (temp), DB error");

        }finally{

          try{ await loadTakes(); }catch{}

          if (savedTake) {

            uploadTakeToServer(savedTake).then(async () => {

              // After successful take upload, upload stems if available and non-empty
              if (micBlob && readerBlob && micBlob.size > 2048 && readerBlob.size > 2048) {
                try {
                  await uploadStemsToServer(savedTake.serverId || savedTake.id, micBlob, readerBlob);
                } catch (err) {
                  console.warn("[offbook] Stem upload failed:", err);
                  alert(`Stem upload failed: ${err?.message || String(err)}. Room will be unavailable for this take.`);
                }
              } else {
                // iPhone-visible debug without console
                alert(`Stems not captured (mic=${micBlob?micBlob.size:0} bytes, reader=${readerBlob?readerBlob.size:0} bytes). Room will be unavailable.`);
              }

            }).catch(err => {

              console.warn("Failed to upload take to server", err);

            });

          }

        }

      }



      /* -------- IndexedDB small wrapper -------- */

      const GalleryDB = (() => {

        const DB_NAME = "gallery-db-v1";

        const STORE = "takes";

        let db = null;

        function open(){

          if(!("indexedDB" in window)) return Promise.reject(new Error("indexeddb-unavailable"));

          return new Promise((res, rej)=>{

            const req = indexedDB.open(DB_NAME, 1);

            req.onupgradeneeded = () => {

              const d = req.result;

              if(!d.objectStoreNames.contains(STORE)){

                const os = d.createObjectStore(STORE, { keyPath:"id" });

                os.createIndex("created", "created");

              }

            };

            req.onsuccess = () => { db = req.result; res(db); };

            req.onerror = () => rej(req.error);

          });

        }

        async function ready(){ return db || open(); }

        async function put(rec){

          await ready();

          return new Promise((res, rej)=>{

            const tx = db.transaction(STORE, "readwrite");

            tx.objectStore(STORE).put(rec);

            tx.oncomplete = () => res();

            tx.onerror = () => rej(tx.error);

          });

        }

        async function getAll(){

          await ready();

          return new Promise((res, rej)=>{

            const tx = db.transaction(STORE, "readonly");

            const req = tx.objectStore(STORE).getAll();

            req.onsuccess = () => res(req.result || []);

            req.onerror = () => rej(req.error);

          });

        }

        async function get(id){

          await ready();

          return new Promise((res, rej)=>{

            const tx = db.transaction(STORE, "readonly");

            const req = tx.objectStore(STORE).get(id);

            req.onsuccess = () => res(req.result || null);

            req.onerror = () => rej(req.error);

          });

        }

        async function del(id){

          await ready();

          return new Promise((res, rej)=>{

            const tx = db.transaction(STORE, "readwrite");

            tx.objectStore(STORE).delete(id);

            tx.oncomplete = () => res();

            tx.onerror = () => rej(tx.error);

          });

        }

        return { put, getAll, get, del };

      })();



      /* ---- Helpers for short labels + pruning ---- */

      const G = { filter:"all", urls:new Map() };



      function currentUserKey() {

        const auth = (window.S && S.auth) ? S.auth : null;



        // If we have a real signed-in user, prefer a stable key based on userId

        if (auth && auth.loggedIn && auth.userId) {

          return `user:${auth.userId}`;

        }



        // Dev / anonymous fallback: stable per-device id stored in localStorage

        try {

          const LS_KEY = "offbook_dev_user_key";

          let devKey = window.localStorage.getItem(LS_KEY);

          if (!devKey) {

            const base =

              (window.crypto && typeof crypto.randomUUID === "function")

                ? crypto.randomUUID()

                : `dev-${Date.now()}-${Math.random().toString(16).slice(2)}`;

            devKey = `dev:${base}`;

            window.localStorage.setItem(LS_KEY, devKey);

          }

          return devKey;

        } catch (e) {

          // If localStorage is blocked for some reason, fall back to a simple anon key

          return "user:anon";

        }

      }



      function shortLabel(n){

        const num = Math.max(1, n);

        return "TK" + String(num).padStart(2, "0");

      }



      async function pruneTakes(){

        const MAX_ITEMS = 10;

        const MAX_AGE_MS = 14*24*3600*1000;

        const userKey = getSignedInUserKey();

        const list = (await GalleryDB.getAll())

          .filter(t => {

            if (userKey) return !t.userKey || t.userKey === userKey;

            return !t.userKey;

          })

          .sort((a,b)=>(b.created||0)-(a.created||0));

        const now = Date.now();

        const recent = [];

        for(const t of list){

          const created = t.created || 0;

          if(now - created > MAX_AGE_MS){ await GalleryDB.del(t.id); continue; }

          recent.push(t);

        }

        if(recent.length > MAX_ITEMS){

          for(const t of recent.slice(MAX_ITEMS)){ await GalleryDB.del(t.id); }

        }

      }



      async function saveTakeToDB({ blob, isVid, aspect, renderId, micBlob, readerBlob }){

        if(!("indexedDB" in window)) throw new Error("indexeddb-unavailable");

        const id = (crypto && typeof crypto.randomUUID === "function") ? crypto.randomUUID() : `take-${Date.now()}-${Math.random().toString(16).slice(2)}`;

        const created = Date.now();

        const type = blob.type || (isVid ? "video/mp4" : "audio/mp4");

        const size = blob.size || 0;

        const userKey = getSignedInUserKey();

        const existing = (await GalleryDB.getAll()).length;

        const short = shortLabel(existing + 1);

        const ext = type.includes("webm") ? "webm" : (isVid ? "mp4" : "m4a");

        const stamp = new Date(created).toISOString().replace(/[:.]/g,"-");

        const name = `${isVid?"take-video":"take-audio"}-${stamp}.${ext}`;

        const safeAspect = typeof aspect === "string" ? aspect : "16:9";

        const take = {

          id,

          created,

          name,

          short,

          type,

          size,

          aspect: safeAspect,

          blob,

          note:"",

          notes:"",

          readerRenderId: typeof renderId === "string" ? renderId : (typeof R?.render_id === "string" ? R.render_id : (localStorage.getItem("offbook:last_render_id") || "")),

          userKey,

          micBlob: micBlob || null,

          readerBlob: readerBlob || null

        };

        await GalleryDB.put(take);

        await pruneTakes();

        return take;

      }



      /* ---- Gallery rendering with filters + actions ---- */

      async function loadTakes() {

        try {

          const userKey = getSignedInUserKey();



          // If nobody is signed in, we don't show any takes.

          if (!userKey) {

            S.galleryTakes = [];

            renderGallery();

            return;

          }



          // 1) Load all local takes from IndexedDB

          let allLocal = [];

          try {

            try { await pruneTakes(); } catch {}

            allLocal = await GalleryDB.getAll();

          } catch (e) {

            console.warn("Failed to load local gallery items", e);

            allLocal = [];

          }



          // Auto-migrate legacy items (no userKey) to the current signed-in user on this device.

          const legacy = allLocal.filter(t => !t.userKey);

          for (const t of legacy) {

            t.userKey = userKey;

            try {

              await GalleryDB.put(t);

            } catch (e) {

              console.warn("Failed to migrate legacy gallery item", t.id, e);

            }

          }



          const localAfterMigration =

            legacy.length > 0 ? await GalleryDB.getAll() : allLocal;



          const localMine = localAfterMigration

            .filter(t => t.userKey === userKey)

            .map(t => {

              const noteVal = typeof t.notes === "string" ? t.notes : (t.note || "");

              const renderVal =

                typeof t.readerRenderId === "string"

                  ? t.readerRenderId

                  : typeof t.renderId === "string"

                  ? t.renderId

                  : "";

              return {

                ...t,

                note: typeof t.note === "string" ? t.note : noteVal,

                notes: noteVal,

                readerRenderId: renderVal

              };

            });



          // 2) Load server-side items for this user (metadata only)

          let remoteItems = [];

          try {

            const resp = await fetch("/api/gallery", { credentials: "include" });

            if (resp.ok) {

              const data = await resp.json();

              if (data && Array.isArray(data.items)) {

                remoteItems = data.items.map(row => ({

                  id: row.id,

                  created: Number(row.created_at) || 0,

                  name: row.name || row.id || "Take",

                  short: row.name || row.id || "Take",

                  type: row.mime_type || "video/webm",

                  size: Number(row.size) || 0,

                  note: (typeof row.notes === "string" && row.notes.length ? row.notes : (row.note || "")),

                  notes: (typeof row.notes === "string" ? row.notes : (row.note || "")),

                  readerRenderId: typeof row.reader_render_id === "string" ? row.reader_render_id : "",

                  userKey,

                  fromServer: true,

                  serverId: row.id

                }));

              }

            }

          } catch (err) {

            console.warn("Failed to load server gallery items", err);

          }



          // 3) Merge local + remote by id (local wins if both exist)

          const byId = new Map();



          for (const t of localMine) {

            if (t && t.id) {

              byId.set(t.id, t);

            }

          }



          for (const r of remoteItems) {

            if (!r || !r.id) continue;

            if (!byId.has(r.id)) {

              byId.set(r.id, r);

            }

          }



          const merged = Array.from(byId.values());

          merged.sort((a, b) => (b.created || 0) - (a.created || 0));



          S.galleryTakes = merged;

          renderGallery();

        } catch (err) {

          console.warn("[offbook] gallery load error", err);

          const wrap = $("#takes");

          if (wrap) {

            wrap.innerHTML = `<p class="hint">Gallery storage unavailable on this device.</p>`;

          }

        }

      }



      async function uploadTakeToServer(take) {

        try {

          const userKey = getSignedInUserKey();

          if (!userKey) return; // not signed in, skip



          if (!take || !take.blob) return;



          const form = new FormData();

          const blob = take.blob;

          const mime = take.type || blob.type || "video/webm";



          const idPart = take.id || "take";

          const isMp4 = mime && mime.toLowerCase().includes("mp4");

          const ext = isMp4 ? ".mp4" : ".webm";

          const filename = idPart + ext;



          form.append("file", blob, filename);

          if (take.id) form.append("id", take.id);



          // Prefer the friendly TK label on the server, fall back to whatever we have

          const friendlyName =

            (take.short && String(take.short).trim()) ||

            (take.name && String(take.name).trim()) ||

            filename;

          form.append("name", friendlyName);



          if (take.scriptId) form.append("script_id", take.scriptId);

          if (take.sceneId) form.append("scene_id", take.sceneId);



          // Persist the note so it survives on new devices

          const noteForServer =

            typeof take.notes === "string"

              ? take.notes

              : typeof take.note === "string"

              ? take.note

              : null;

          if (typeof noteForServer === "string") {

            form.append("note", noteForServer);

            form.append("notes", noteForServer);

          }



          const renderIdForServer =

            (typeof take.readerRenderId === "string" && take.readerRenderId) ||

            (typeof take.renderId === "string" && take.renderId) ||

            (typeof take.render_id === "string" && take.render_id) ||

            (typeof R?.render_id === "string" && R.render_id) ||

            null;

          if (renderIdForServer) {

            form.append("render_id", renderIdForServer);

          }



          form.append("mime_type", mime);

          form.append("size", String(take.size || blob.size || 0));

          form.append("created_at", String(take.created || Date.now()));



          console.log(

            "[offbook] uploading take to server",

            take.id || "(no id yet)"

          );



          const resp = await fetch("/api/gallery/upload", withSecretHeaders({

            method: "POST",

            body: form,

            credentials: "include"

          }));



          if (!resp.ok) {

            const txt = await resp.text().catch(() => "");

            console.warn("uploadTakeToServer failed", resp.status, txt);

            // Surface this on device since there is no console

            alert(

              "Gallery upload failed (" +

                resp.status +

                ").\n\n" +

                (txt || "").slice(0, 200)

            );

            return;

          }



          const data = await resp.json().catch(() => null);

          if (data && data.id) {

            take.serverId = data.id;

            console.log("[offbook] gallery upload ok, server id:", data.id);

            // Persist serverId to localStorage
            try {
              await GalleryDB.put(take);
            } catch (e) {
              console.warn("[offbook] Failed to persist serverId:", e);
            }

          }

        } catch (err) {

          console.warn("uploadTakeToServer error", err);

          alert("Gallery upload error. Please try again and mention this to Rodrigo.");

        }

      }



      async function uploadStemsToServer(takeId, micBlob, readerBlob) {
        try {
          // Don't gate stems upload on localStorage userKey.
          // If auth is missing, the server will reject and we'll see it.

          if (!takeId || !micBlob || !readerBlob) {
            console.warn("[offbook] uploadStemsToServer: missing data", { takeId, micBlob, readerBlob });
            return;
          }

          const form = new FormData();
          form.append("id", takeId);

          const micMime = micBlob.type || "audio/webm";
          const readerMime = readerBlob.type || "audio/webm";

          const micExt = micMime.includes("mp4") || micMime.includes("m4a") ? ".m4a" : ".webm";
          const readerExt = readerMime.includes("mp4") || readerMime.includes("m4a") ? ".m4a" : ".webm";

          form.append("mic", micBlob, `${takeId}-mic${micExt}`);
          form.append("reader", readerBlob, `${takeId}-reader${readerExt}`);

          console.log("[offbook] Uploading stems for takeId:", takeId);

          const resp = await fetch("/api/gallery/upload_stems", withSecretHeaders({
            method: "POST",
            body: form,
            credentials: "include"
          }));

          if (!resp.ok) {
            const txt = await resp.text().catch(() => "");
            console.warn("uploadStemsToServer failed", resp.status, txt);
            throw new Error(`HTTP ${resp.status}: ${txt.slice(0, 200)}`);
          }

          const data = await resp.json().catch(() => null);
          console.log("[offbook] Stems upload successful:", data);

        } catch (err) {
          console.error("uploadStemsToServer error", err);
          throw err;
        }
      }



      async function saveNotesOnServer(takeId, notes){

        if(!takeId) return;

        try{

          const resp = await fetch("/api/gallery/notes", withSecretHeaders({

            method: "POST",

            headers: { "Content-Type": "application/json" },

            body: JSON.stringify({ take_id: takeId, notes }),

            credentials: "include"

          }));

          if(!resp.ok){

            console.warn("saveNotesOnServer failed", resp.status);

          }

        }catch(err){

          console.warn("saveNotesOnServer error", err);

        }

      }



      async function deleteTakeOnServer(takeId) {

        if(!takeId) return;

        try{

          const resp = await fetch("/api/gallery/delete", withSecretHeaders({

            method: "POST",

            headers: { "Content-Type": "application/json" },

            body: JSON.stringify({ take_id: takeId }),

            credentials: "include"

          }));

          if(!resp.ok){

            console.warn("deleteTakeOnServer failed", resp.status);

            // Show error to user on iPhone (no console access)
            try{
              const errorText = await resp.text();
              const truncated = errorText.slice(0, 200);
              alert(`Delete failed (${resp.status}): ${truncated}`);
            }catch{
              alert(`Delete failed (${resp.status})`);
            }

          }

        }catch(err){

          console.warn("deleteTakeOnServer error", err);

        }

      }



      function fmtMB(n){

        if(!n || !isFinite(n)) return "0 MB";

        return Math.max(1, Math.round(n / 1048576)) + " MB";

      }



      function kindFrom(type=""){

        if(type.startsWith("video/")) return "MP4";

        if(type.includes("webm")) return "WEBM";

        return "M4A";

      }



      const escapeHtml = (value)=>String(value ?? "").replace(/[&<>"']/g, ch=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[ch]||ch));



      function resetGalleryUrls(){

        G.urls.forEach(url=>{ try{ URL.revokeObjectURL(url); }catch{} });

        G.urls.clear();

      }



      async function renderGallery(){

        const wrap = $("#takes");

        if(!wrap) return;

        resetGalleryUrls();

        const userKey = getSignedInUserKey();



        if (!userKey) {

          wrap.innerHTML = `

            <div class="ob-empty">

              <h3>Sign in to see your takes</h3>

              <p>Takes are stored per account on this device. Sign in to view your gallery.</p>

            </div>

          `;

          return;

        }



        const takes = S.galleryTakes || [];

        const list = takes.filter(t => G.filter === "all" ? true : (t.aspect === G.filter));



        const filters = `

          <div style="margin-bottom:8px">

            <span class="chip-filter ${G.filter==='all'?'active':''}" data-filt="all">All</span>

            <span class="chip-filter ${G.filter==='16:9'?'active':''}" data-filt="16:9">16:9</span>

            <span class="chip-filter ${G.filter==='9:16'?'active':''}" data-filt="9:16">9:16</span>

          </div>`;



        if(!list.length){

          wrap.innerHTML = filters + `

            <div class="ob-empty">

              <h3>No takes yet</h3>

              <p>Record a scene to see it appear in your gallery.</p>

            </div>

          `;

          bindGalleryFilters(wrap);

          return;

        }



        const cardMap = new Map();

        const cardsHtml = list.map(t=>{

          let src = "";

          if (t.blob) {

            try {

              src = URL.createObjectURL(t.blob);

              G.urls.set(t.id, src);

            } catch (e) {

              console.warn("Failed to create object URL for take blob", e);

            }

          }



          if (!src && (t.serverId || t.id)) {

            const id = encodeURIComponent(t.serverId || t.id);

            src = `/api/gallery/${id}/file`;

          }



          cardMap.set(t.id, { t, url: src });

          const meta = `${escapeHtml(t.aspect || '—')} • ${escapeHtml(fmtMB(t.size))} • ${escapeHtml(kindFrom(t.type))}`;

          const shortName = escapeHtml(t.short || t.name || "Take");

          const noteSafe = escapeHtml(t.notes ?? t.note ?? "");

          return `

            <div class="take-card" data-id="${escapeHtml(t.id)}">

              <video class="take-thumb" data-src="${escapeHtml(src)}" playsinline preload="none"></video>

              <div class="take-row" style="justify-content:space-between;align-items:center;">

                <div>

                  <div style="font-weight:700">${shortName}</div>

                  <div class="take-meta">${meta}</div>

                </div>

                <div class="take-actions">

                  <button type="button" class="btn sm secondary" data-act="play">Play</button>

                  <button type="button" class="btn sm secondary" data-act="dl">Raw</button>

                  <button type="button" class="btn sm" data-act="room">Download</button>

                  <button type="button" class="btn sm secondary" data-act="del">Delete</button>

                </div>

              </div>

              <div class="take-err" style="margin-top:8px;color:#ffb4b4;font-size:12px;"></div>

              <textarea class="take-note" placeholder="Add a note…">${noteSafe}</textarea>

            </div>`;

        }).join("");



        wrap.innerHTML = filters + cardsHtml;

        bindGalleryFilters(wrap);

        bindGalleryCards(wrap, cardMap);

      }



      function bindGalleryFilters(root){

        $$(".chip-filter", root).forEach(el=>{

          el.onclick = ()=>{

            const sel = el.getAttribute("data-filt") || "all";

            if(G.filter !== sel){ G.filter = sel; renderGallery().catch(()=>{}); }

          };

        });

      }



      function autoSizeImportTextareas() {

        document.querySelectorAll(".import-line-textarea").forEach(ta => {

          ta.style.height = "auto";

          ta.style.height = ta.scrollHeight + "px";

        });

      }



      function markImportEdited() {

        const metaEl = document.getElementById("importEditorMeta");

        if (!metaEl) return;

        const base = metaEl.textContent || "";

        metaEl.textContent = base.replace(/ • Local changes applied$/, "") + " • Local changes applied";

      }



      function hydrateImportEditor() {

        const container = document.getElementById("importEditorContainer");

        const metaEl = document.getElementById("importEditorMeta");

        const sceneSelector = document.getElementById("importSceneSelector");

        const linesList = document.getElementById("importLinesList");

        if (!container || !metaEl || !sceneSelector || !linesList) return;



        if (!S.script_id || !Array.isArray(S.scenes) || S.scenes.length === 0) {

          metaEl.textContent = "No script loaded yet.";

          sceneSelector.innerHTML = "";

          linesList.innerHTML = "";

          const empty = document.createElement("div");

          empty.className = "import-editor-empty";

          empty.textContent = "Import or select a script to preview its scenes here.";

          linesList.appendChild(empty);

          return;

        }



        if (S.currentSceneIndex < 0 || S.currentSceneIndex >= S.scenes.length) {

          S.currentSceneIndex = 0;

        }



        const scenes = S.scenes;

        const activeScene = scenes[S.currentSceneIndex] || null;

        const meta = S.savedScripts.find(s => s.id === S.script_id) || null;

        const title = meta?.title || "Sides";

        const countLabel = `${scenes.length} scene${scenes.length === 1 ? "" : "s"}`;

        metaEl.textContent = `${title} • ${countLabel}`;



        sceneSelector.innerHTML = "";

        scenes.forEach((scene, idx) => {

          const chip = document.createElement("button");

          chip.type = "button";

          chip.className = "import-scene-chip" + (idx === S.currentSceneIndex ? " active" : "");

          const label = scene?.title || `Scene ${idx + 1}`;

          chip.textContent = label;

          chip.dataset.sceneIndex = String(idx);

          sceneSelector.appendChild(chip);

        });



        const filteredLines = activeScene ? buildFiltered(activeScene) : [];

        linesList.innerHTML = "";

        if (!filteredLines.length) {

          const emptyLine = document.createElement("div");

          emptyLine.className = "import-editor-empty";

          emptyLine.textContent = "No dialogue lines found for this scene.";

          linesList.appendChild(emptyLine);

        } else {

          filteredLines.forEach((ln, idx) => {

            const row = document.createElement("div");

            row.className = "line";

            row.dataset.orig = String(ln.orig ?? idx);



            const speakerEl = document.createElement("div");

            speakerEl.className = "who";

            speakerEl.textContent = ln?.speaker || "";



            const textArea = document.createElement("textarea");

            textArea.className = "import-line-textarea text";

            textArea.value = ln?.text || "";

            textArea.dataset.orig = String(ln.orig ?? idx);

            textArea.addEventListener("input", () => {

              textArea.style.height = "auto";

              textArea.style.height = textArea.scrollHeight + "px";

            });



            const deleteBtn = document.createElement("button");

            deleteBtn.type = "button";

            deleteBtn.className = "btn sm secondary import-line-delete";

            deleteBtn.textContent = "Delete";

            deleteBtn.addEventListener("click", () => {

              const scene = S.scenes[S.currentSceneIndex];

              if (!scene || !Array.isArray(scene.lines)) return;

              const origStr = row.dataset.orig;

              const origIdx = origStr ? Number(origStr) : NaN;

              if (Number.isNaN(origIdx)) return;

              if (!scene.lines[origIdx]) return;

              scene.lines.splice(origIdx, 1);

              hydrateImportEditor();

              markImportEdited();

            });



            row.appendChild(speakerEl);

            row.appendChild(textArea);

            row.appendChild(deleteBtn);

            linesList.appendChild(row);

          });



          // Add line control at the bottom

          const addRow = document.createElement("div");

          addRow.className = "import-editor-add-row";



          const addBtn = document.createElement("button");

          addBtn.type = "button";

          addBtn.className = "btn ghost sm import-line-add";

          addBtn.textContent = "+ Add line";

          addBtn.addEventListener("click", () => {

            const scene = S.scenes[S.currentSceneIndex];

            if (!scene || !Array.isArray(scene.lines)) return;



            // Default speaker: reuse last non-empty speaker from this scene, if any

            let speaker = "";

            for (let i = scene.lines.length - 1; i >= 0; i--) {

              const ln = scene.lines[i];

              if (ln && typeof ln.speaker === "string" && ln.speaker.trim()) {

                speaker = ln.speaker;

                break;

              }

            }



            scene.lines.push({ speaker, text: "[New line]" });

            hydrateImportEditor();

            markImportEdited();

          });



            addRow.appendChild(addBtn);

            linesList.appendChild(addRow);

          }

          autoSizeImportTextareas();

          updateImportPersistenceDebug();

        }

        function saveImportEdits() {

          if (!S.scenes || !Array.isArray(S.scenes) || S.scenes.length === 0) return;

          if (S.currentSceneIndex < 0 || S.currentSceneIndex >= S.scenes.length) return;



        let titleInput = null;

        const panelText = document.getElementById("panel-text");

        const panelPdf = document.getElementById("panel-pdf");

        if (panelText && !panelText.hasAttribute("hidden")) {

          titleInput = document.getElementById("titleText");

        } else if (panelPdf && !panelPdf.hasAttribute("hidden")) {

          titleInput = document.getElementById("titlePdf");

        }



        if (titleInput && typeof titleInput.value === "string") {

          const newTitle = titleInput.value.trim();

          const meta = S.savedScripts && S.script_id

            ? S.savedScripts.find(s => s.id === S.script_id)

            : null;

          if (meta && newTitle) {

            meta.title = newTitle;

            saveSavedScriptsToStorage();

            renderSavedScriptsStrip();

          }

        }



        const scene = S.scenes[S.currentSceneIndex];

        if (!scene || !Array.isArray(scene.lines)) return;



        const linesList = document.getElementById("importLinesList");

        if (!linesList) return;



        const textareas = linesList.querySelectorAll(".import-line-textarea");

        textareas.forEach(ta => {

          const origStr = ta.dataset.orig;

          const origIdx = origStr ? Number(origStr) : NaN;

          if (Number.isNaN(origIdx)) return;

          if (!scene.lines[origIdx]) return;

          scene.lines[origIdx].text = ta.value || "";

        });



        hydrateImportEditor();

        if (typeof hydrateRehearse === "function") {

          try {

            hydrateRehearse();

          } catch (e) {

            console.warn("hydrateRehearse failed after Import save", e);

          }

        }

        // Persist full scenes for this script to localStorage

        persistCurrentScriptScenesToStorage();

        const scriptId = S.script_id;

        let titleForSave = null;

        if (titleInput && typeof titleInput.value === "string") {

          titleForSave = titleInput.value;

        } else if (Array.isArray(S.savedScripts)) {

          const metaForTitle = S.savedScripts.find(s => s.id === scriptId) || null;

          titleForSave = metaForTitle?.title || null;

        }

        if (scriptId) {

          saveScriptEditsToServer(scriptId, titleForSave, S.scenes);

        }

        markImportEdited();

      }



      function bindGalleryCards(root, map){

        $$(".take-card", root).forEach(card=>{

          const id = card.getAttribute("data-id");

          const rec = id ? map.get(id) : null;

          if(!rec) return;

          const take = rec.t || rec;

          const video = card.querySelector("video");

          const btnPlay = card.querySelector('[data-act="play"]');

          const btnDl = card.querySelector('[data-act="dl"]');

          const btnRoom = card.querySelector('[data-act="room"]');

          const btnDel = card.querySelector('[data-act="del"]');

          const noteEl = card.querySelector('.take-note');



          btnPlay?.addEventListener("click", async ()=>{

            if(!video) return;

            if(video.paused){

              // If video.src is empty, set it from data-src first
              if (!video.src || video.src === "") {
                const dataSrc = video.getAttribute("data-src");
                if (dataSrc) {
                  video.src = dataSrc;
                  video.load();
                }
              }

              // Attempt to play with fallback logic
              try {
                video.currentTime = 0;
                await video.play();
                if(btnPlay) btnPlay.textContent = "Pause";
              } catch (playErr) {
                console.warn("[offbook] Initial play failed, attempting fallback fetch", playErr);

                // Fallback: fetch video file from server
                try {
                  const takeId = take.serverId || take.id;
                  if (!takeId) throw new Error("No takeId available for playback");

                  const url = `/api/gallery/${encodeURIComponent(takeId)}/file`;
                  const resp = await fetch(url, withSecretHeaders({
                    method: "GET",
                    credentials: "include",
                  }));

                  if (!resp.ok) {
                    const errorText = await resp.text().catch(() => "");
                    throw new Error(`Playback fetch failed (${resp.status}): ${errorText || resp.statusText}`);
                  }

                  const blob = await resp.blob();
                  const objectUrl = URL.createObjectURL(blob);

                  // Replace video source and try playing again
                  video.src = objectUrl;
                  video.load();
                  video.currentTime = 0;
                  await video.play();

                  if(btnPlay) btnPlay.textContent = "Pause";

                  // Cleanup object URL after video ends
                  video.addEventListener("ended", () => {
                    URL.revokeObjectURL(objectUrl);
                  }, { once: true });

                } catch (fallbackErr) {
                  console.error("[offbook] Playback fallback failed", fallbackErr);
                  showToastOnce("Playback failed: " + (fallbackErr?.message || String(fallbackErr)), 3500);
                }
              }

            }else{

              video.pause();

              if(btnPlay) btnPlay.textContent = "Play";

            }

          });

          video?.addEventListener("ended", ()=>{ if(btnPlay) btnPlay.textContent = "Play"; });

          video?.addEventListener("pause", ()=>{ if(btnPlay && !video.error) btnPlay.textContent = "Play"; });

          video?.addEventListener("error", (e)=>{
            console.error("[offbook] Video playback error", video?.error);
            if(btnPlay) btnPlay.textContent = "Play";

            const errorCode = video?.error?.code || "?";

            // Find or create error message div
            let errDiv = card.querySelector(".take-err");
            if (!errDiv) {
              errDiv = document.createElement("div");
              errDiv.className = "take-err";
              errDiv.style.cssText = "margin-top:8px;color:#ffb4b4;font-size:12px;";
              const rowDiv = card.querySelector(".take-row");
              if (rowDiv) {
                rowDiv.parentNode.insertBefore(errDiv, rowDiv.nextSibling);
              }
            }

            errDiv.textContent = `Playback failed (code ${errorCode}). This take may be corrupt or missing. Try Delete.`;

            // Reset the video element so it doesn't poison other cards
            video.pause();
            video.removeAttribute("src");
            video.load();
          });


          btnDl?.addEventListener("click", async ()=>{
            const btn = btnDl;
            if(!btn) return;

            const prevLabel = btn.textContent || "Raw";
            btn.textContent = "Preparing…";
            btn.disabled = true;

            try{
              const cleanName = (s) => String(s||"")
                .replace(/[^\w\s-]/g, "")
                .trim()
                .replace(/\s+/g, "-")
                .slice(0, 60) || "offbook-take";

              const id = take.serverId || take.id;
              let blob = null;

              if (take.blob instanceof Blob) {
                blob = take.blob;
              } else {
                if (!id) throw new Error("No file available for this take.");

                const url = `/api/gallery/${encodeURIComponent(id)}/file`;
                const resp = await fetch(url, withSecretHeaders({
                  method: "GET",
                  credentials: "include",
                  cache: "no-store"
                }));

                if (!resp.ok) {
                  throw new Error(`Download failed (${resp.status})`);
                }

                blob = await resp.blob();
              }

              const mime = blob.type || "video/mp4";
              const filenameBase = cleanName(take.label || take.name || "offbook-take");
              const filename = `${filenameBase}.mp4`;

              try{
                const file = new File([blob], filename, { type: mime });
                const canShareFiles =
                  !!navigator.share &&
                  (!navigator.canShare || navigator.canShare({ files: [file] }));

                if (canShareFiles) {
                  await navigator.share({ files: [file], title: filename });
                  return;
                }
              } catch (shareErr) {
                console.warn("[offbook] share failed, falling back", shareErr);
              }

              const objUrl = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = objUrl;
              a.download = filename;
              a.rel = "noopener";
              document.body.appendChild(a);
              a.click();
              a.remove();
              setTimeout(()=>URL.revokeObjectURL(objUrl), 20000);

            } catch(err){
              console.warn("[offbook] raw download failed", err);
              alert("Raw download failed: " + (err?.message || String(err)));
            } finally {
              btn.disabled = false;
              btn.textContent = prevLabel;
            }
          });


          btnRoom?.addEventListener("click", async ()=>{
            const btn = btnRoom;
            if(!btn) return;

            const prevLabel = btn.textContent || "Download";
            btn.textContent = "Mixing…";
            btn.disabled = true;
            showBusy("Mixing take…");

            try{
              const cleanName = (s) => String(s||"")
                .replace(/[^\w\s-]/g, "")
                .trim()
                .replace(/\s+/g, "-")
                .slice(0, 60) || "offbook-take";

              let id = take.serverId || take.id;

              // Guard against legacy TK-style IDs
              if (id && /^TK\d+/.test(id)) {
                alert("This is an old take saved with a legacy ID. Please record a new take to use Room.");
                return;
              }

              // If no serverId, upload to get one
              if (!take.serverId) {
                await uploadTakeToServer(take);
                id = take.serverId || take.id;
              }

              if (!id) throw new Error("No file available for this take.");

              // Default: allow cache hits (much faster, avoids timeouts)
              // If you ever need to force rebuild, add ?mixforce=1 to the app URL.
              const sp = new URLSearchParams();
              sp.set("dl","1");
              sp.set("mode","room");
              if (new URLSearchParams(location.search).get("mixforce") === "1") sp.set("force","1");
              const url = `/api/gallery/${encodeURIComponent(id)}/mixed_file?${sp.toString()}`;

              const filenameBase = cleanName(take.label || take.name || "offbook-take");
              const filename = `${filenameBase}-room.mp4`;

              // Fetch the Room mix
              let resp = await fetch(url, withSecretHeaders({
                method: "GET",
                credentials: "include",
              }));

              // Handle missing data errors with self-heal from IndexedDB
              if (!resp.ok) {
                if (resp.status === 404) {
                  // Parse error to determine what's missing
                  const j = await resp.json().catch(() => null);
                  const errCode = j?.error || j?.errorCode || "";

                  if (errCode === "stems_missing" || errCode === "not_found") {
                    // Self-heal: re-upload from IndexedDB
                    console.log(`[offbook] Server missing data (${errCode}), attempting repair from IndexedDB...`);

                    // Load full record from IndexedDB
                    const full = await GalleryDB.get(take.id);

                    if (!full) {
                      alert("Room repair failed: take not found on device.");
                      return;
                    }

                    // Show visible status to user
                    showBusy("Repairing…");
                    btn.textContent = "Repairing…";

                    try {
                      // If take itself is missing (not_found), re-upload it
                      if (errCode === "not_found") {
                        if (full.blob) {
                          console.log("[offbook] Re-uploading take to server...");
                          await uploadTakeToServer(full);
                        }
                      }

                      // If stems are missing, re-upload them
                      if (full.micBlob && full.readerBlob) {
                        console.log("[offbook] Re-uploading stems to server...");
                        await uploadStemsToServer(id, full.micBlob, full.readerBlob);
                      }

                      // Retry the mixed_file fetch once
                      showBusy("Mixing take…");
                      resp = await fetch(url, withSecretHeaders({
                        method: "GET",
                        credentials: "include",
                      }));

                      if (!resp.ok) {
                        const retryBody = await resp.text().catch(() => "");
                        throw new Error(`Room mix failed after repair (${resp.status}): ${retryBody.slice(0, 200)}`);
                      }
                    } catch (repairErr) {
                      throw repairErr;
                    }
                  } else {
                    throw new Error(`Room mix failed (${resp.status})`);
                  }
                } else {
                  throw new Error(`Room mix failed (${resp.status})`);
                }
              }

              const blob = await resp.blob();

              // Create File object and cache it
              const file = new File([blob], filename, { type: "video/mp4" });
              roomFileCache.set(id, {
                file,
                filename,
                timestamp: Date.now()
              });

              // Hide busy overlay before showing modal
              hideBusy();

              // Reset button state before showing modal
              btn.disabled = false;
              btn.textContent = prevLabel;

              // Show Mix Ready modal and wait for user action
              const result = await showMixReadyModal(id);

              if (result.action === "expired") {
                alert("Mix file expired. Please tap Room again.");
              } else if (result.action === "error") {
                alert("Failed to save mix: " + (result.message || "Unknown error"));
              }
              // On success (shared/downloaded), modal already handled everything

            } catch(err){
              console.warn("[offbook] room download failed", err);
              alert("Room download failed: " + (err?.message || String(err)));
            } finally {
              hideBusy();
              btn.disabled = false;
              btn.textContent = prevLabel;
            }
          });


          btnDel?.addEventListener("click", async ()=>{

            const takeId = take.serverId || take.id;

            try{ if(takeId) await deleteTakeOnServer(takeId); }catch{}

            if(rec.url){ try{ URL.revokeObjectURL(rec.url); }catch{} }

            try{ if(take.id) await GalleryDB.del(take.id); }catch{}

            try{ card.remove(); }catch{}

            loadTakes().catch(()=>{});

          });



          noteEl?.addEventListener("blur", async ()=>{

            try{

              const userKey = take.userKey ?? getSignedInUserKey();

              const notesVal = noteEl.value;

              const takeIdForServer = take.serverId || take.id;

              if(takeIdForServer){

                try{ await saveNotesOnServer(takeIdForServer, notesVal); }catch{}

              }

              const updated = { ...take, note: notesVal, notes: notesVal, userKey };

              await GalleryDB.put(updated);

              Object.assign(take, updated);

              if (rec.t) {

                rec.t = take;

              } else {

                rec.note = updated.note;

                rec.notes = updated.notes;

                rec.userKey = updated.userKey;

              }

            }catch(err){ console.warn("[offbook] note save failed", err); }

          });

        });

      }





      /* --- Button wiring --- */

      R.btnRender?.addEventListener("click", async ()=>{

        // If we already have pre-rendered clips in RR.map from Rehearse, reuse them.

        const hasCached = primeReaderFromCacheIfAvailable() || (RR.map && RR.map.size);

        if(hasCached && RR.map && RR.map.size){

          setStatusRec(`Voices ready: ${RR.map.size} lines (cached).`);

          try{ preloadReaderBuffers(); }catch{}

          // NEW: Room requires a server reader render_id. If we don't have one yet,
          // generate it now so recording + Room export work.
          if(!R.render_id){
            await prepareReader();
          }

          return;

        }

        setStatusRec("Preparing voices…");

        try{

          await renderRehearseVoices(); // fills RR.map

          if(RR.map.size){
            setStatusRec("Reader ready.");
            try{ preloadReaderBuffers(); }catch{}
            if(!R.render_id){
              setStatusRec("Rendering reader track…");
              await prepareReader();
            }
            return;
          }

        }catch(e){ /* fall through to server render */ }

        // Fallback: server-side combined reader track

        await prepareReader();

      });



      R.btnRec?.addEventListener("click", ()=>{

        // Guard: prevent double-clicks during transitions
        if (R._recStarting || R._recStopping || R._finalizingTake) return;

        if(R.recording) { stopRecording(); }

        else { startRecording(); }

      });



      R.btnGrid?.addEventListener("click", ()=>{

        R.gridOn = !R.gridOn;

        setRailStates();

        syncGridOverlayVisibility();

      });



      R.btnCamera?.addEventListener("click", async ()=>{

        R.cameraOn = !R.cameraOn;

        setRailStates();

        await startPreviewIfNeeded();

        try{ updateRecordLayout(); }catch{}

      });



      R.btnHeadphones?.addEventListener("click", ()=>{

        R.headphonesOn = !R.headphonesOn;

        try{ if(R.mixGainReader) R.mixGainReader.gain.value = R.headphonesOn ? 1.0 : 0.0; }catch{}

        setRailStates();

      });



      // --- Count-in long-press menu (landscape only) ---

      const countMenu = $("#countinMenu");

      let countHoldTimer = null;

      let countMenuOpen = false;



      function positionCountMenu(){

        if(!countMenu || !R?.btnCountIn) return;

        const r = R.btnCountIn.getBoundingClientRect();

        const menuW = Math.max(120, countMenu.offsetWidth || 0);

        const left = Math.min(Math.max(8, r.right - menuW), window.innerWidth - menuW - 8);

        const top = Math.min(r.bottom + 6, window.innerHeight - 8);

        countMenu.style.left = left + "px";

        countMenu.style.top = top + "px";

      }



      function showCountMenu(){

        if(!countMenu || !R?.btnCountIn) return;

        if(isPortrait()) return;

        positionCountMenu();

        countMenu.style.display = "block";

        countMenu.removeAttribute("hidden");

        countMenu.setAttribute("aria-hidden", "false");

        positionCountMenu();

        countMenuOpen = true;

      }



      function hideCountMenu(){

        if(!countMenu || !countMenuOpen) return;

        clearTimeout(countHoldTimer);

        countHoldTimer = null;

        countMenu.setAttribute("hidden", "true");

        countMenu.setAttribute("aria-hidden", "true");

        countMenu.style.display = "none";

        countMenuOpen = false;

      }



      R.btnCountIn?.addEventListener("click", (ev)=>{

        if(countMenuOpen){

          hideCountMenu();

          ev.stopPropagation();

          return;

        }

        R.countInOn = !R.countInOn;

        setRailStates();

      });



      R.btnCountIn?.addEventListener("pointerdown", ()=>{

        if(isPortrait()) return;

        if(countMenuOpen) return;

        clearTimeout(countHoldTimer);

        countHoldTimer = setTimeout(showCountMenu, 450);

      });

      ["pointerup","pointercancel","pointerleave"].forEach(evt=>{

        R.btnCountIn?.addEventListener(evt, ()=>{ clearTimeout(countHoldTimer); countHoldTimer = null; });

      });



      countMenu?.addEventListener("click", (e)=>{

        const b = e.target.closest("button[data-sec]");

        if(!b) return;

        const sec = parseInt(b.getAttribute("data-sec"), 10) || 3;

        R.countInSecs = sec;

        hideCountMenu();

        setRailStates();

      });



      document.addEventListener("click", (e)=>{

        if(!countMenuOpen) return;

        if(e.target === R.btnCountIn || (countMenu && countMenu.contains(e.target))) return;

        hideCountMenu();

      });



      // --- iOS guard: block text selection & long-press menu on record rail buttons

      document.addEventListener("selectstart", (e)=>{

        if(e.target && e.target.closest("#screen-record .control-rail")){

          e.preventDefault();

        }

      }, { passive:false });



      document.addEventListener("contextmenu", (e)=>{

        if(e.target && e.target.closest("#screen-record .control-rail")){

          e.preventDefault();

        }

      });



      // ---- Route Modal controls ---------------------------------------------------

      const RouteModal = (() => {

        const el = document.getElementById('routeModal');

        const scrim = el?.querySelector('.ob-modal__scrim');

        const btnClose = el?.querySelector('#routeModalClose');

        const btnOk = el?.querySelector('#routeModalOk');

        const FIRST = () => btnOk || btnClose;

        let lastFocus = null;

        const KEY = 'ob.routeModal.dismissedAt';

        const COOLDOWN_MS = 10 * 60 * 1000; // 10 minutes



        function inCooldown() {

          const t = parseInt(localStorage.getItem(KEY) || '0', 10);

          return Number.isFinite(t) && Date.now() - t < COOLDOWN_MS;

        }

        function markDismissed() { localStorage.setItem(KEY, String(Date.now())); }



        function lockScroll(on) {

          document.documentElement.style.overflow = on ? 'hidden' : '';

          document.body.style.overflow = on ? 'hidden' : '';

        }

        function trap(e) {

          if (e.key !== 'Tab') return;

          const f = el.querySelectorAll('button,[href],input,summary,[tabindex]:not([tabindex="-1"])');

          if (!f.length) return;

          const first = f[0], last = f[f.length-1];

          if (e.shiftKey && document.activeElement === first) { last.focus(); e.preventDefault(); }

          if (!e.shiftKey && document.activeElement === last) { first.focus(); e.preventDefault(); }

        }

        function open() {

          if (!el) return;

          if (inCooldown()) return;

          lastFocus = document.activeElement;

          el.classList.remove('ob-hidden');

          el.setAttribute('aria-hidden','false');

          lockScroll(true);

          document.addEventListener('keydown', onKey);

          setTimeout(() => FIRST()?.focus(), 0);

        }

        function close() {

          if (!el) return;

          el.classList.add('ob-hidden');

          el.setAttribute('aria-hidden','true');

          lockScroll(false);

          document.removeEventListener('keydown', onKey);

          try { lastFocus && lastFocus.focus(); } catch {}

        }

        function onKey(e){ if (e.key === 'Escape') { markDismissed(); close(); } else trap(e); }



        btnClose?.addEventListener('click', () => { markDismissed(); close(); });

        document.getElementById('routeHow')?.addEventListener('toggle', () => {/* keep open */});

        scrim?.addEventListener('click', () => { markDismissed(); close(); });

        btnOk?.addEventListener('click', () => { markDismissed(); close(); });



        return { open, close, inCooldown };

      })();



      // ---- Speaker fallback (session-scoped) -------------------------------------

      const SPK_KEY = 'ob.spkFallbackSession'; // '1' for enabled this session

      function enableSpeakerFallbackSession() { window.__OB_SPK_FALLBACK = true; sessionStorage.setItem(SPK_KEY, '1'); }

      function disableSpeakerFallbackSession() { window.__OB_SPK_FALLBACK = false; sessionStorage.removeItem(SPK_KEY); }

      function speakerFallbackActive() { return !!(window.__OB_SPK_FALLBACK || sessionStorage.getItem(SPK_KEY) === '1'); }



      // Attempt routing to a speaker-like output if supported; otherwise no-op.

      async function routeReaderToSpeaker(audioEl) {

        try {

          if (!audioEl || typeof audioEl.setSinkId !== 'function') return false;

          const outs = await navigator.mediaDevices.enumerateDevices();

          const speakers = outs.filter(d => d.kind === 'audiooutput' && /speaker|iphone/i.test((d.label||'')));

          const target = speakers[0] || outs.find(d => d.kind === 'audiooutput');

          if (target && target.deviceId) { await audioEl.setSinkId(target.deviceId); return true; }

        } catch (e) { /* ignore */ }

        return false; // iOS Safari may not support setSinkId; we degrade to guidance only

      }



      // Restore default output (best effort)

      async function routeReaderToDefault(audioEl) {

        try {

          if (!audioEl || typeof audioEl.setSinkId !== 'function') return false;

          await audioEl.setSinkId('default');

          return true;

        } catch { return false; }

      }



  // Wire modal "Fix now"

      document.getElementById('routeModalFixNow')?.addEventListener('click', async () => {

        enableSpeakerFallbackSession();

        // if a media element exists, try to move it now (best effort)

        try { await routeReaderToSpeaker(window.__OB_READER_EL); } catch {}

        // keep modal open/closed? Close after action:

        (window.RouteModal?.close || (()=>{}))();

      });

      // Persist flag for current tab reloads

      if (sessionStorage.getItem(SPK_KEY) === '1') window.__OB_SPK_FALLBACK = true;

      const adv = document.getElementById('advSpeakerFallback');

      if (adv) {

        adv.checked = speakerFallbackActive();

        adv.addEventListener('change', () => {

          if (adv.checked) enableSpeakerFallbackSession(); else disableSpeakerFallbackSession();

        });

      }



      window.addEventListener("orientationchange", ()=>{

        hideCountMenu();

        clearTimeout(countHoldTimer);

        countHoldTimer = null;

      });

      window.addEventListener("resize", ()=>{ if(countMenuOpen) positionCountMenu(); });



      $("#btnFlipCam")?.addEventListener("click", async ()=>{

        useBackCamera = !useBackCamera;

        await applyCameraFacing();

      });



      /* Warm permissions when user navigates to Record */

      const _origShowScreen = showScreen;

      showScreen = function(name){

        try{ hideCountMenu(); }catch{}

        _origShowScreen(name);

        if(name==="record"){

          try{ requestMicPermissionOnce(); }catch{}

          try{ startPreviewIfNeeded(); }catch{}

          try{ updateRecordLayout(); }catch{}

          try{ syncGridOverlayVisibility(); }catch{}

          setRailStates();

        }

      };



      window.addEventListener("pagehide", ()=>{

        releaseWakeLock();

        try{ hideCountMenu(); }catch{}

        resetReaderActiveSources();

        if(hasR()){

          try{ R.readerCtx?.close(); }catch{}

          R.readerCtx = null;

          R.readerGain = null;

          R.readerBridge = null;

          R.readerBridgeSource = null;

          R.readerRecordGain = null;

          R.readerDirectConnected = false;

          R.duckHintShown = false;

        }

        resetGalleryUrls();

      });



      // initial safe boot

      try{

  hydrateRehearse(); applyEditModeUI(); (function initAssign(){ $("#pillScript").textContent="script: "+(S.script_id||"-"); })();

  loadTakes().catch(()=>{});

      }catch(e){ showErr("UI init error: "+e); }

    };



    // Safe boot: never leave page inert

    try {

      if (document.readyState === "loading") {

        document.addEventListener("DOMContentLoaded", boot, { once:true });

      } else {

        boot();

      }

    } catch (e) {

      const eb = document.getElementById("errbar");

      if (eb) { eb.textContent = "Fatal init error: "+e; eb.classList.add("show"); }

    }

    // Keep layout stable across iOS Safari viewport + toolbar changes
    (function () {
      function setTabbarVar() {
        const tab =
          document.querySelector(".tabbar") ||
          document.querySelector("#tabbar") ||
          document.querySelector(".bottom-tabs") ||
          document.querySelector("nav");

        const h = tab ? Math.round(tab.getBoundingClientRect().height) : 96;
        document.documentElement.style.setProperty("--tabbarH", h + "px");
      }

      window.addEventListener("resize", setTabbarVar, { passive: true });
      window.addEventListener("orientationchange", () => setTimeout(setTabbarVar, 250), { passive: true });
      document.addEventListener("DOMContentLoaded", () => {
        setTabbarVar();
        setTimeout(setTabbarVar, 300);
      });
    })();

  </script>



  <!-- Auth Gate Interstitial (hidden by default; controlled by flag from /auth/session) -->

  <div id="authGate" class="ob-modal ob-hidden" aria-hidden="true">

    <div class="ob-modal__scrim auth-landing-scrim"></div>

    <div class="ob-modal__card auth-landing" role="dialog" aria-modal="true" aria-labelledby="authGateTitle">

      <button id="authGateClose" class="ob-modal__close" aria-label="Close" title="Close">&times;</button>



      <div class="auth-inner">

        <div class="auth-brand">

          <img class="auth-logo" src="/icons/icon-192.png" alt="" />

          <div class="auth-text">

            <h3 id="authGateTitle" class="auth-title">OFFBOOK</h3>

            <div class="auth-subtitle">Rehearse · Record · Book</div>

          </div>

        </div>



        <div class="auth-copy">

          <p>Sign in with your device passkey or use an access code.</p>

        </div>



        <div class="auth-actions">

          <button id="authGateInvite" class="btn secondary">Use invite code</button>

          <button id="authGatePasskey" class="btn">Continue with Face ID</button>

        </div>

      </div>

    </div>

  </div>



  <!-- Route / Ringer Guidance Modal -->

  <div id="routeModal" aria-hidden="true" role="dialog" aria-labelledby="routeModalTitle" aria-modal="true" class="ob-modal ob-hidden">

    <div class="ob-modal__scrim"></div>

    <div class="ob-modal__card" role="document">

      <button id="routeModalClose" class="ob-modal__close" aria-label="Close">✕</button>

      <div class="ob-modal__content">

  <h2 id="routeModalTitle" class="ob-modal__title">Heads-up: iPhone may be in "call" mode</h2>

        <p class="ob-modal__body">

          If you can’t hear the reader during your line, flip your iPhone’s <b>ringer switch ON</b> (side of the phone) and avoid Bluetooth "call audio" mode.

        </p>

        <details id="routeHow" class="ob-modal__details">

          <summary>Learn how</summary>

          <ol>

            <li>Flip the hardware <b>ringer switch ON</b> (on the side of the phone).</li>

            <li>Settings → Bluetooth → your headphones → prefer media audio (avoid "call mode").</li>

            <li>If issues persist: try wired earbuds or temporarily turn Mic Off for a pass.</li>

          </ol>

        </details>

        <div class="ob-modal__actions">

          <button id="routeModalFixNow" class="btn">Fix now</button>

          <button id="routeModalOk" class="btn btn-primary">Understood</button>

        </div>

        <div class="ob-modal__footnote" style="opacity:.7;font-size:12px;margin-top:6px">

          We'll use your phone speaker during your lines for this session only.

        </div>

      </div>

    </div>

  </div>



  <!-- Count-in picker (landscape only) -->

  <div id="countinMenu" class="countin-menu" hidden aria-hidden="true" role="menu">

    <button type="button" data-sec="3">3 sec</button>

    <button type="button" data-sec="5">5 sec</button>

    <button type="button" data-sec="10">10 sec</button>

  </div>



  <div class="countdown" id="countdown" aria-hidden="true" style="display:none">

    <div class="count-num" id="countNum">3</div>

  </div>



  <!-- Paywall (stub) -->

  <div id="paywall" class="ob-modal ob-hidden" aria-hidden="true">

    <div class="ob-modal__scrim"></div>

    <div class="ob-modal__card" role="dialog" aria-modal="true" aria-labelledby="paywallTitle">

      <button id="paywallClose" class="ob-modal__close" aria-label="Close">×</button>

      <h3 id="paywallTitle" class="ob-modal__title">You're out of access</h3>

      <div class="ob-modal__body">

        <p class="small" id="paywallMsg">Start a subscription or add credits to continue.</p>

      </div>

      <div class="ob-modal__actions">

        <button id="btnStartSub" class="btn">Start subscription</button>

        <button id="btnAddCredits" class="btn secondary">Add credits</button>

      </div>

    </div>

  </div>

  <script>

    (function () {

      // Elements

      const btn = document.getElementById('btnAddCreditsSettings');

      const hint = document.getElementById('addCreditsHintSettings');

      const toast = document.getElementById('addCreditsToastSettings');

      const friendly = document.getElementById('authStatusFriendly');   // text area that mirrors auth state

      const passkeyCopy = document.getElementById('passkeySignedInCopy'); // shown when passkey signed-in



      function setFriendlySignedState(on) {

        // Prefer the specific line if present; fall back to the older container

        const el = document.getElementById('passkeySignedInCopy') || document.getElementById('authStatusFriendly');

        if (!el) return;

        el.textContent = on ? "You're signed in with a passkey." : "Not signed in.";

      }



      const FIRST_LOAD_LOCK_MS = 3000;      // minimum "signed-out" window on initial load

      let firstLoadLockUntil = 0;

      try {

        const raw = localStorage.getItem('obAuthLast');

        const last = raw ? JSON.parse(raw) : null;

        // If the last explicit action was SIGNOUT (within 15 minutes), hold UI as signed-out briefly on load.

        if (last && last.action === 'signout' && (Date.now() - (last.ts || 0) < 15 * 60 * 1000)) {

          firstLoadLockUntil = Date.now() + FIRST_LOAD_LOCK_MS;

        }

      } catch {}



      function lastAuthAction() {

        try {

          const raw = localStorage.getItem('obAuthLast');

          return raw ? JSON.parse(raw).action : null;

        } catch {

          return null;

        }

      }



      let uiLockUntil = 0;          // timestamp while we force "signed out"

      let lastServerIn = false;     // last server read of loggedIn

      let consecutiveIn = 0;        // count consecutive "in" reads



      let _inflight = false;

      let _lastFetchAt = 0;

      let _nextTimer = null;



      function scheduleRefresh(delayMs = 0) {

        if (_nextTimer) clearTimeout(_nextTimer);

        _nextTimer = setTimeout(() => {

          _nextTimer = null;

          refresh();

        }, delayMs);

      }



      async function isSignedIn() {

        if (_inflight) return lastServerIn; // reuse last known truth while a call is in flight

        _inflight = true;

        const url = `${location.origin}/auth/session?t=${Date.now()}&rand=${Math.random()}`;

        try {

          const r = await fetch(url, {

            method: 'GET',

            credentials: 'include',

            cache: 'no-store',

            headers: {

              'Cache-Control': 'no-cache, no-store, max-age=0',

              'Pragma': 'no-cache',

              'Accept': 'application/json'

            }

          });

          const text = await r.text(); // read raw

          let j = null;

          try { j = JSON.parse(text); } catch (_) {}

          return !!(j && j.passkey && j.passkey.loggedIn);

        } catch (err) {

          return false;

        } finally {

          _inflight = false;

        }

      }



      function setAddCreditsEnabled(on) {

        if (!btn) return;

        btn.disabled = !on;

        if (on) btn.classList.remove('secondary');

        else btn.classList.add('secondary');

        if (hint) hint.style.display = on ? 'none' : 'block';

        setFriendlySignedState(on);

      }



      async function refresh() {

        const now = Date.now();

        // throttle

        if (now - _lastFetchAt < 800) {

          scheduleRefresh(800 - (now - _lastFetchAt));

          return;

        }

        _lastFetchAt = now;



        // Hold UI as signed-out during first load, and during post-signout window

        if (now < firstLoadLockUntil || now < uiLockUntil) {

          setAddCreditsEnabled(false);

          return;

        }



        const serverIn = await isSignedIn();



        // de-flap: require TWO consecutive "in" reads before enabling

        if (serverIn) {

          consecutiveIn = lastServerIn ? consecutiveIn + 1 : 1;

        } else {

          consecutiveIn = 0;

        }

        lastServerIn = serverIn;



        // If user last explicitly signed OUT, never auto-enable from background reads.

        // Require an explicit Sign In click to flip this.

        const lastAct = lastAuthAction();

        const allowEnable = lastAct !== 'signout';

        setAddCreditsEnabled(allowEnable && consecutiveIn >= 2);

      }



      // initial

      refresh();

      scheduleRefresh(300);  // one follow-up tick

      scheduleRefresh(1200); // and a second "settle" tick



      // React to auth UI changes without touching existing handlers

      const moTargets = [friendly, passkeyCopy].filter(Boolean);

      const mo = new MutationObserver(refresh);

      moTargets.forEach(t => mo.observe(t, { childList: true, characterData: true, subtree: true, attributes: true }));



      ['btnSignIn','btnSignOut','btnRegisterPasskey'].forEach(id=>{

        const el = document.getElementById(id);

        if (!el) return;

        el.addEventListener('click', () => {

          const now = Date.now();

          if (id === 'btnSignOut') {

            // remember user explicitly signed out

            try { localStorage.setItem('obAuthLast', JSON.stringify({ action: 'signout', ts: now })); } catch {}

            // Lock UI in "signed out" for 5000ms optimistically

            uiLockUntil = now + 5000;

            lastServerIn = false;

            consecutiveIn = 0;

            setAddCreditsEnabled(false);

          } else if (id === 'btnSignIn') {

            // remember user explicitly signed in

            try { localStorage.setItem('obAuthLast', JSON.stringify({ action: 'signin', ts: now })); } catch {}

            // Clear lock on sign-in attempt so we can re-enable quickly

            uiLockUntil = 0;

            lastServerIn = false;

            consecutiveIn = 0;

          }

          scheduleRefresh(150);

          scheduleRefresh(600);

          scheduleRefresh(1200);

        });

      });



      window.addEventListener('visibilitychange', () => {

        if (document.visibilityState === 'visible') scheduleRefresh(120);

      });

      window.addEventListener('pageshow', () => scheduleRefresh(120));



      // safe click handler (unchanged)

      btn && btn.addEventListener('click', function () {

        if (btn.disabled) return;

        try {

          if (toast) {

            toast.style.display = 'block';

            clearTimeout(toast._t);

            toast._t = setTimeout(() => { toast.style.display = 'none'; }, 2200);

          }

        } catch (_) {}

      });



      // Soft SFX even when disabled (no action fires)

      if (btn) {

        btn.addEventListener('pointerdown', function (e) {

          if (!btn.disabled) return;          // only add sound when disabled

          try {

            const AC = window.AudioContext || window.webkitAudioContext;

            const ctx = new AC();

            const osc = ctx.createOscillator();

            const gain = ctx.createGain();

            osc.type = 'square';

            osc.frequency.value = 220;

            osc.connect(gain);

            gain.connect(ctx.destination);

            const t = ctx.currentTime;

            gain.gain.setValueAtTime(0.0001, t);

            gain.gain.exponentialRampToValueAtTime(0.12, t + 0.005);

            gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.06);

            osc.start(t);

            osc.stop(t + 0.08);

          } catch (_) { /* ignore */ }

          e.preventDefault();

          e.stopPropagation();

        }, { capture: true });

      }

    })();

  </script>

  <div id="obBusy" class="ob-busy hidden" aria-live="polite">
    <div class="ob-busy-card">
      <div class="ob-spin"></div>
      <div id="obBusyText" class="ob-busy-text">Mixing take…</div>
      <div class="ob-busy-sub">This can take a moment.</div>
    </div>
  </div>

</body>

</html>
