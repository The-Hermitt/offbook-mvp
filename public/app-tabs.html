<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>OffBook ‚Äî Rehearsal MVP</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <style>
    :root { --bg:#0b0c0f; --panel:#111318; --panel-2:#151823; --text:#eaf0ff; --muted:#a7b0c5; --border:#252a36; --focus:#3b82f6; --accent:#3b82f6; --danger:#ef4444; --ok:#16a34a; --warn:#f4c542; --maxw:720px; }
    *{ box-sizing:border-box } html,body{ margin:0; padding:0; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial }
    header{ padding:14px 16px; font-weight:700; letter-spacing:.2px }
    main{ padding:12px 12px 92px; max-width:var(--maxw); margin:0 auto; pointer-events:auto }
    .card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:12px }
    h3,h4{ margin:6px 0 10px } .hint{ color:var(--muted); font-size:12px; line-height:1.4 }
    label{ display:block; font-size:12px; color:var(--muted); margin:8px 0 6px }
    input[type="text"],textarea,select{ width:100%; border:1px solid var(--border); background:#0c0f16; color:var(--text); border-radius:10px; padding:10px 12px; font-size:15px }
    textarea{ min-height:120px; line-height:1.35 }
    .btn{ display:inline-flex; align-items:center; justify-content:center; background:var(--accent); color:#fff; border:none; padding:12px 14px; border-radius:12px; font-weight:700; font-size:15px; min-height:44px; cursor:pointer }
    .btn.secondary{ background:transparent; color:var(--text); border:1px solid var(--border) }
    .btn.ghost{ background:transparent; color:var(--muted); border:1px dashed var(--border) }
    .btn.sm{ padding:8px 10px; font-size:12px; border-radius:10px; min-height:32px }
    .row{ display:flex; gap:8px } .row>*{ flex:1 }
    .spacer6{ height:6px } .spacer8{ height:8px } .spacer12{ height:12px } .spacer16{ height:16px }
    .tabbar{ position:fixed; bottom:0; left:0; right:0; background:var(--panel-2); border-top:1px solid var(--border); padding:0 8px; z-index:40 }
    .tabbar-inner{ max-width:var(--maxw); margin:0 auto; display:grid; grid-template-columns:repeat(6,1fr) }
    .tabbar button{ appearance:none; border:none; background:transparent; color:var(--muted); padding:10px 4px; font-size:12px; font-weight:600 }
    .tabbar button.active{ color:var(--text); background:rgba(255,255,255,.02); border-radius:8px }
    .screen{ display:none; pointer-events:auto } .screen.active{ display:block }
    .inner-tabs{ display:flex; gap:8px }
    .inner-tabs button{ flex:1; border:1px solid var(--border); background:transparent; color:var(--text); padding:10px; border-radius:10px; font-weight:700 }
    .inner-tabs button.active{ background:var(--panel-2); border-color:var(--focus) }
    pre.status{ white-space:pre-wrap; word-break:break-word; background:#0c0f16; border:1px dashed var(--border); border-radius:10px; padding:8px; color:#a7b0c5; min-height:22px }
    .pill{ display:inline-block; padding:6px 10px; border-radius:999px; border:1px solid var(--border); background:#0f1420; font-size:12px; margin-right:6px }
    .small{ font-size:12px; color:var(--muted) }
    /* Rehearse */
    .line{ padding:10px; border-radius:10px; border:1px solid var(--border); margin-bottom:8px; background:#0c0f16; position:relative }
    .line.me{ border-color:#2f6df6; background:#0e1220 }
    .line .who{ font-weight:700; margin-bottom:6px }
    .line .text{ line-height:1.4 }
    .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    .playing{ outline:2px solid var(--focus) }
    .badge{ font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid var(--border); background:#0f1420; color:#a7b0c5 }
    .badge.ok{ color:#16a34a } .badge.warn{ color:#f4c542 } .badge.err{ color:#ff7b7b }
    .editbar{ position:absolute; top:6px; right:6px; display:flex; gap:6px }
    .chip{ font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid var(--border); background:#0f1420; color:#a7b0c5; cursor:pointer; user-select:none }
    .chip.danger{ border-color:#e96; color:#ff7b7b }
    .text[contenteditable="true"]{ outline:1px dashed var(--focus); border-radius:6px; padding:4px }
    .inline-slot{ display:none; align-items:center; justify-content:center; margin:8px 0 10px }
    .inline-slot .ghostline{ width:100%; border:1px dashed var(--border); border-radius:10px; padding:10px }
    .inline-form{ width:100%; background:#0c0f16; border:1px solid var(--border); border-radius:12px; padding:10px; margin-top:8px }

    /* Sticky toolbar */
    .toolbar{ position:sticky; top:0; z-index:30; margin:-12px -12px 10px; padding:12px env(safe-area-inset-right) 12px env(safe-area-inset-left);
      background:linear-gradient(180deg, rgba(11,12,15,0.98) 0%, rgba(11,12,15,0.94) 100%); border-bottom:1px solid var(--border); border-top-left-radius:12px; border-top-right-radius:12px; }
    .toolbar .controls{ justify-content:space-between }
    .toolbar .left, .toolbar .right{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    .btn.icon{ min-width:auto; padding:12px; }
    .btn.icon::before{ content:"‚ü≤"; font-weight:900; font-size:20px; line-height:1; display:block; }

    /* Record */
    .rec-grid{ display:flex; flex-direction:column; gap:10px }
    .vid{ width:100%; aspect-ratio:9/16; background:#000; border-radius:12px; border:1px solid var(--border); object-fit:cover }
    .countdown{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.75); z-index:1000; }
    .countdown.show{ display:flex }
    .count-num{ font-size:64px; font-weight:800; background:#111; color:#fff; padding:24px 36px; border-radius:18px; border:1px solid var(--border) }
    .gallery-item{ border:1px solid var(--border); border-radius:12px; padding:10px; margin-bottom:8px; background:#0c0f16 }

    /* L‚ÜíR dots for loading */
    .dots { display:inline-flex; gap:6px; align-items:center; vertical-align:middle }
    .dot { width:6px; height:6px; border-radius:50%; background:#7aa0ff; opacity:.25; }
    .dot.on { opacity:1 }

    /* Error banner */
    .errbar{ position:sticky; top:0; z-index:50; display:none; padding:8px 12px; background:#2b0f12; color:#ffb3b3; border-bottom:1px solid #7a2a2a; font-size:12px }
    .errbar.show{ display:block }

    #screen-record .card{ display:flex; flex-direction:column; gap:12px; }
    #screen-record .rec-grid{ flex:1; }
    #screen-record .status{ flex:0; }

    @media (max-width:600px){
      main{ padding-bottom:100px; }
      #screen-record .card{ min-height:calc(100vh - 146px); }
      #screen-record .rec-grid{ gap:8px; align-items:center; }
      #screen-record .vid{ width:auto; max-width:min(100%,360px); max-height:min(55vh,420px); }
    }
  </style>
</head>
<body>
  <div id="errbar" class="errbar" role="alert"></div>
  <header>üé≠ OffBook ‚Äî Rehearsal MVP</header>

  <main>
    <!-- IMPORT -->
    <section id="screen-import" class="screen active">
      <div class="card">
        <h3>Import</h3>
        <p class="hint">Two ways to import. <b>Paste Script Text</b> is most reliable; <b>Upload PDF</b> extracts text with an OCR fallback for scanned PDFs.</p>
        <div class="inner-tabs" role="tablist">
          <button id="tab-text" class="active" role="tab" aria-controls="panel-text" aria-selected="true">Paste Script Text</button>
          <button id="tab-pdf" role="tab" aria-controls="panel-pdf" aria-selected="false">Upload PDF</button>
        </div>
        <div class="spacer12"></div>

        <!-- TEXT PANEL -->
        <div id="panel-text" role="tabpanel" aria-labelledby="tab-text">
          <label>Title</label>
          <input id="titleText" type="text" placeholder="My Sides" />
          <label>Paste script here</label>
          <textarea id="scriptText" placeholder="JANE: Hi.
GABE: Hey.
JANE: Ready?"></textarea>
          <div class="spacer8"></div>
          <div class="row">
            <button id="btnTextUpload" class="btn">Continue ‚Üí Assign</button>
            <button id="btnTextClear" class="btn secondary">Clear</button>
          </div>
          <div class="spacer12"></div>
          <label>Status</label>
          <pre id="status" class="status"></pre>
        </div>

        <!-- PDF PANEL -->
        <div id="panel-pdf" role="tabpanel" aria-labelledby="tab-pdf" hidden>
          <label>Title</label>
          <input id="titlePdf" type="text" placeholder="My PDF Sides" />
          <label>PDF File</label>
          <input id="pdfFile" type="file" accept="application/pdf" />
          <div class="spacer8"></div>
          <div class="row">
            <button id="btnPdfUpload" class="btn">Upload & Continue</button>
            <button id="btnPdfOcr" class="btn ghost" title="Use OCR if your PDF is scanned images" disabled>Try OCR (slow)</button>
          </div>
          <div class="spacer12"></div>
          <label>Status</label>
          <pre id="statusPdf" class="status"></pre>
          <div class="small">Tip: OCR processes the first 3 pages for speed.</div>
        </div>
      </div>
    </section>

    <!-- ASSIGN -->
    <section id="screen-assign" class="screen">
      <div class="card">
        <h3>Assign</h3>
        <div><span class="pill" id="pillScript">script: ‚Äî</span> <span class="pill" id="pillScenes">scenes: 0</span></div>
        <div class="spacer8"></div>
        <label>I am‚Ä¶</label>
        <select id="selectRole"></select>
        <div class="spacer8"></div>
        <div id="voicePickers"></div>
        <div class="spacer8"></div>
        <button id="btnSaveAssign" class="btn">Save Voices</button>
      </div>
    </section>

    <!-- REHEARSE -->
    <section id="screen-rehearse" class="screen">
      <div class="card">
        <h3>Rehearse</h3>

        <div class="hint" id="rehearseBanner"><b>Review and edit your script first</b> before rendering for rehearsal. When ready, press ‚ÄúRender for rehearsal (OpenAI)‚Äù to pre-load partner voices for perfect timing.</div>
        <div class="spacer8"></div>

        <div class="row">
          <button id="btnToggleEditMode" class="btn secondary" aria-pressed="false">Edit Script</button>
          <span class="badge">Edit mode: <span id="editModeState">Off</span></span>
        </div>
        <div class="spacer8"></div>

        <div class="row">
          <button id="btnRehearseRender" class="btn">Render for rehearsal (OpenAI)</button>
          <button id="btnRehearseClear" class="btn secondary" title="Discard pre-rendered clips">Clear Render</button>
        </div>
        <div class="spacer6"></div>
        <div class="row">
          <label>Render quality</label>
          <select id="selTtsModel">
            <option value="tts-1" selected>Fast</option>
            <option value="tts-1-hd">Natural (HD)</option>
          </select>
        </div>
        <div class="spacer6"></div>
        <div class="small" id="rehearseRenderStatus"></div>

        <div class="spacer12"></div>

        <div class="toolbar" aria-label="Playback controls">
          <div class="controls">
            <div class="left">
              <button id="btnPlay" class="btn">Play</button>
              <button id="btnPrev" class="btn secondary">Prev</button>
              <button id="btnNext" class="btn secondary">Next</button>
              <button id="btnTop" class="btn secondary icon" title="From the top"></button>
              <select id="selPace" title="Partner pacing">
                <option value="0" selected>No gap</option>
                <option value="80">+80 ms</option>
                <option value="160">+160 ms</option>
                <option value="300">+300 ms</option>
              </select>
            </div>
            <div class="right">
              <button id="btnMic" class="btn secondary" aria-pressed="false">Mic: Off</button>
              <span id="micBadge" class="badge warn">off</span>
            </div>
          </div>
        </div>

        <div id="lines"></div>
      </div>
    </section>

    <!-- RECORD -->
    <section id="screen-record" class="screen">
      <div class="card">
        <h3>Record</h3>
        <div class="hint">Headphones recommended to avoid echo. This prepares an OpenAI reader track and records your mic (optionally camera).</div>
        <div class="spacer8"></div>
        <div class="rec-grid">
          <video id="preview" class="vid" autoplay muted playsinline></video>
          <audio id="readerAudio" preload="auto" playsinline></audio>

          <div class="row">
            <button id="btnPrepareReader" class="btn">1) Prepare Reader Track</button>
          </div>

          <div class="row">
            <label class="small"><input type="checkbox" id="chkVideo" /> Record video (camera)</label>
            <label class="small"><input type="checkbox" id="chkBackCam" /> Use back camera</label>
            <label class="small"><input type="checkbox" id="chkCountIn" checked /> Count-in</label>
            <label class="small"><input type="checkbox" id="chkHeadphones" checked /> I‚Äôm on headphones</label>
          </div>
          <div class="small" id="hpNote" style="margin-top:-6px;opacity:.9">
            Tip: please make sure <b>Conversation Awareness</b> is turned off when using OffBook.
          </div>

          <div class="row">
            <button id="btnStartRec" class="btn" disabled>2) Start Recording</button>
            <button id="btnStopRec" class="btn secondary" disabled>Stop</button>
          </div>

          <label>Status</label>
          <pre id="statusRec" class="status"></pre>
        </div>
      </div>
    </section>

    <!-- GALLERY -->
    <section id="screen-gallery" class="screen">
      <div class="card">
        <h3>Gallery</h3>
        <div id="takes"></div>
        <div class="hint">Takes are saved locally in your browser. Download to keep.</div>
      </div>
    </section>

    <!-- SETTINGS -->
    <section id="screen-settings" class="screen"><div class="card"><h3>Settings</h3><p class="hint">Defaults & storage (future).</p></div></section>
  </main>

  <!-- Bottom bar -->
  <nav class="tabbar" role="tablist" aria-label="App sections">
    <div class="tabbar-inner">
      <button data-tab="import" class="active" role="tab" aria-selected="true">Import</button>
      <button data-tab="assign" role="tab" aria-selected="false">Assign</button>
      <button data-tab="rehearse" role="tab" aria-selected="false">Rehearse</button>
      <button data-tab="record" role="tab" aria-selected="false">Record</button>
      <button data-tab="gallery" role="tab" aria-selected="false">Gallery</button>
      <button data-tab="settings" role="tab" aria-selected="false">Settings</button>
    </div>
  </nav>

  <!-- Vendor -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.6.82/pdf.min.mjs" type="module"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <!-- App -->
  <script type="module">
  const boot = async () => {
      const qs = new URLSearchParams(location.search);
      const secret = qs.get("secret") || "1976";
      const JSON_HDRS = { "Content-Type":"application/json", ...(secret?{"X-Shared-Secret":secret}:{}) };
      const $ = (s,r=document)=>r.querySelector(s);
      const $$ = (s,r=document)=>Array.from(r.querySelectorAll(s));
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform==='MacIntel' && navigator.maxTouchPoints>1);

      const errbar=$("#errbar");
      function showErr(msg){ errbar.textContent=msg; errbar.classList.add("show"); }

      function showScreen(name){
        $$(".countdown").forEach(x=>x.classList.remove("show"));
        $$(".screen").forEach(s=>s.classList.remove("active"));
        $("#screen-"+name).classList.add("active");
        $$(".tabbar button").forEach(b=>b.classList.remove("active"));
        const btn=document.querySelector(`.tabbar button[data-tab="${name}"]`);
        if(btn) btn.classList.add("active");
      }
      $$(".tabbar button").forEach(b=>b.addEventListener("click",()=>showScreen(b.dataset.tab)));

      // inner tabs
      const tabText=$("#tab-text"), tabPdf=$("#tab-pdf"), panelText=$("#panel-text"), panelPdf=$("#panel-pdf");
      tabText?.addEventListener("click",()=>{ tabText.classList.add("active"); tabPdf.classList.remove("active"); panelText.hidden=false; panelPdf.hidden=true; });
      tabPdf?.addEventListener("click",()=>{ tabPdf.classList.add("active"); tabText.classList.remove("active"); panelPdf.hidden=false; panelText.hidden=true; });

      // state
      const S={ script_id:"", scenes:[], role:"", voice_map:{}, editMode:false, supportedVoices:["alloy"] };
      const voiceFor = (name)=> S.voice_map[name] || S.supportedVoices[0] || "alloy";

      // helpers
      const setStatus = msg => $("#status").textContent = msg || "";
      const setStatusPdf = msg => $("#statusPdf").textContent = msg || "";

      async function safeJson(r){ const t=await r.text(); try{return JSON.parse(t)}catch{return {raw:t}} }

      async function loadSupportedVoices(){
        try{
          const r = await fetch("/debug/voices_probe", { headers: JSON_HDRS });
          const j = await safeJson(r);
          if(r.ok && Array.isArray(j.voices) && j.voices.length){ S.supportedVoices=j.voices; }
        }catch(e){ /* keep default */ }
      }

      async function loadScenes(){
        try{
          const r=await fetch("/debug/scenes?script_id="+encodeURIComponent(S.script_id),{headers:JSON_HDRS});
          const j=await safeJson(r); if(!r.ok) return;
          S.scenes=j.scenes||[];
          await loadSupportedVoices();
          hydrateAssign(); hydrateRehearse();
          if(document.querySelector("#lines")) applyEditModeUI();
        }catch(e){ showErr("Init warning: couldn‚Äôt load scenes. You can still re-import."); }
      }

      function sanitizeScriptText(raw){
        const lines = String(raw||"").split(/\r?\n/);
        const drop=[/sides\s+by\s+breakdown\s+services/i,/actors\s+access/i,/do\s+not\s+share/i,/copyright/i,/^page\s+\d+(\s*of\s*\d+)?$/i,/^https?:\/\/\S+/i,/^\s*(INT\.|EXT\.|SCENE)\b/i,/^[A-Z0-9 .,'&/()-]{6,}\s*$/];
        const kept=[]; for(const ln of lines){ const t=ln.trim(); if(!t){ kept.push(""); continue; } if(drop.some(rx=>rx.test(t))) continue; if(/^\(.*\)$/.test(t)) continue; kept.push(ln); } return kept.join("\n");
      }

      // Import: text
      $("#btnTextUpload")?.addEventListener("click", async ()=>{
        const title=$("#titleText").value||"Sides";
        const text=sanitizeScriptText($("#scriptText").value||"");
        setStatus("Uploading text‚Ä¶");
        try{
          const r=await fetch("/debug/upload_script_text",{method:"POST",headers:JSON_HDRS,body:JSON.stringify({title,text})});
          const j=await safeJson(r);
          if(!r.ok){ setStatus("Error "+r.status+": "+JSON.stringify(j)); return; }
          setStatus(`OK scenes=${j.scene_count} speakers=${(j.speakers||[]).join(", ")}`);
          S.script_id=j.script_id; await loadScenes(); showScreen("assign");
        }catch(e){ setStatus("Network error: "+e); }
      });
      $("#btnTextClear")?.addEventListener("click",()=>{ $("#titleText").value=""; $("#scriptText").value=""; setStatus(""); });

      // Import: PDF
      $("#btnPdfUpload")?.addEventListener("click", async ()=>{
        const title=$("#titlePdf").value||"PDF Sides"; const file=$("#pdfFile").files[0];
        if(!file){ setStatusPdf("Choose a PDF first."); return; }
        const fd=new FormData(); fd.append("title",title); fd.append("pdf",file);
        const hdrs={}; if(secret) hdrs["X-Shared-Secret"]=secret;
        setStatusPdf("Uploading PDF‚Ä¶");
        try{
          const r=await fetch("/debug/upload_script_upload",{method:"POST",headers:hdrs,body:fd});
          const j=await safeJson(r);
          if(!r.ok){ setStatusPdf("Error "+r.status+": "+JSON.stringify(j)); return; }
          const sp=(j.speakers||[]).join(", "); const note=j.note?(" note="+j.note):"";
          setStatusPdf(`OK scenes=${j.scene_count} speakers=${sp||"(none)"} textLen=${j.textLen||0}${note}`);
          if(j.note==="image-only"||j.note==="parse-error"){ $("#btnPdfOcr").disabled=false; $("#btnPdfOcr").focus(); return; }
          S.script_id=j.script_id; await loadScenes(); showScreen("assign");
        }catch(e){ setStatusPdf("Network error: "+e); }
      });

      // Assign
      function uniqueRoles(){ const names=new Set(); for(const sc of (S.scenes||[])) for(const ln of (sc.lines||[])) names.add(ln.speaker); return Array.from(names).filter(n=>n&&n!=="SYSTEM"&&n!=="NARRATOR"); }
      function hydrateAssign(){
        $("#pillScript").textContent="script: "+(S.script_id||"‚Äî");
        $("#pillScenes").textContent="scenes: "+(S.scenes?.length||0);
        const roles=uniqueRoles(); const sel=$("#selectRole");
        sel.innerHTML=roles.map(r=>`<option value="${r}">${r}</option>`).join("");
        if(!S.role&&roles.length) S.role=roles[0];
        sel.value=S.role||"";
        sel.onchange=()=>{ S.role=sel.value; buildVoicePickers(); hydrateRehearse(); applyEditModeUI(); };
        buildVoicePickers();
      }
      function buildVoicePickers(){
        const box=$("#voicePickers"); box.innerHTML="";
        const partners=uniqueRoles().filter(n=>n!==S.role);
        partners.forEach(name=>{
          const wrap=document.createElement("div");
          wrap.className="card"; wrap.style.marginTop="8px";
          wrap.innerHTML=`<div style="display:flex;align-items:center;justify-content:space-between;gap:10px">
            <strong>${name}</strong>
            <select data-name="${name}">${S.supportedVoices.map(v=>`<option value="${v}" ${((S.voice_map[name]||S.supportedVoices[0])===v)?"selected":""}>${v}</option>`).join("")}</select>
          </div>`;
          box.appendChild(wrap);
        });
        box.querySelectorAll("select").forEach(el=>el.addEventListener("change",(e)=>{
          const sel = e.target; S.voice_map[sel.getAttribute("data-name")] = sel.value;
        }));
      }
      $("#btnSaveAssign")?.addEventListener("click", async ()=>{
        if(!S.script_id) return;
        const roles=uniqueRoles().filter(r=>r!==S.role);
        for(const r of roles) if(!S.voice_map[r]) S.voice_map[r]=S.supportedVoices[0] || "alloy";
        try{ await fetch("/debug/set_voice",{method:"POST",headers:JSON_HDRS,body:JSON.stringify({script_id:S.script_id,voice_map:S.voice_map})}); }catch{}
        showScreen("rehearse");
      });

      /* ------- rehearse listening/respond flow (UNCHANGED) ------- */
      const E={
        linesWrap:$("#lines"), btnPlay:$("#btnPlay"), btnPrev:$("#btnPrev"), btnNext:$("#btnNext"), btnTop:$("#btnTop"),
        selPace:"#selPace", btnMic:$("#btnMic"), micBadge:$("#micBadge"),
        btnToggleEditMode:$("#btnToggleEditMode"), editModeState:$("#editModeState"),
        inlineForm:null, currentSlotPlace:null,
        rehearseAudio:(()=>{ const a=document.createElement("audio"); a.preload="auto"; a.setAttribute("playsinline",""); a.style.display="none"; document.body.appendChild(a); return a; })()
      };
      let idx=0, playing=false;
      let playbackSource="idle";
      let recordSessionActive=false;
      let recordPrevMicState=null;

      const isParenOnly=t=>/^\(.*\)$/.test((t||"").trim());
      const isBoilerplate=t=>{ const s=(t||"").trim().toLowerCase(); if(!s) return true; if(/^[-‚Äì‚Äî]+$/.test(s)) return true; if(/^\d{1,4}$/.test(s)) return true; if(/^page\s*\d+(\s*of\s*\d+)?$/i.test(s)) return true; if((/^cont'?d\.?$/i.test(s)||/^continued$/i.test(s))&&s.length<=10) return true; if(/^https?:\/\/\S+/i.test(s)) return true; return (s.includes("sides by breakdown services")||s.includes("actors access")||s.includes("do not share")||s.includes("copyright")) && s.length<=80; };

      function buildFiltered(scene){ const out=[]; for(let i=0;i<(scene?.lines?.length||0);i++){ const ln=scene.lines[i]; if(!ln) continue; if(ln.speaker==="NARRATOR") continue; if(isParenOnly(ln.text)) continue; if(isBoilerplate(ln.text)) continue; out.push({orig:i,speaker:ln.speaker,text:ln.text}); } return out; }
      function getScene(){ return S.scenes[0]; }
      function myName(){ return S.role||uniqueRoles()[0]||""; }

      function inlineSlot(place){ return `<div class="inline-slot" data-place="${place}"><div class="ghostline"><button class="btn ghost sm" data-add-button>+ Add here</button></div></div>`; }

      function hydrateRehearse(){
        const scene=getScene(); const list=buildFiltered(scene);
        if(!list.length){ $("#lines").innerHTML="<p class='hint'>Import a script first.</p>"; return; }
        let html=inlineSlot(0);
        list.forEach((ln,i)=>{ const me=ln.speaker===myName(); html+=`<div class="line ${me?"me":""}" data-i="${i}" data-orig="${ln.orig}"><div class="editbar" style="display:${S.editMode?'flex':'none'}"><span class="chip" data-act="edit" data-i="${i}">Edit</span><span class="chip danger" data-act="del" data-i="${i}">Delete</span></div><div class="who">${ln.speaker}</div><div class="text" data-i="${i}" contenteditable="false">${ln.text}</div></div>`; html+=inlineSlot(ln.orig+1); });
        $("#lines").innerHTML=html; idx=Math.max(0,Math.min(idx,list.length-1)); wireEditTools(); wireSlots(); highlightCurrent(); applyEditModeUI();
      }
      function wireEditTools(){ $$(".chip",$("#lines")).forEach(ch=>ch.onclick=(ev)=>{ ev.stopPropagation(); const act=ch.getAttribute("data-act"); const iF=+ch.getAttribute("data-i"); const sc=getScene(); if(!sc) return; const node=document.querySelector(`.line[data-i="${iF}"]`); const orig=+node.getAttribute("data-orig"); if(Number.isNaN(orig)) return; if(act==="edit"){ if(!S.editMode) return; const t=document.querySelector(`.text[data-i="${iF}"]`); const editing=t.getAttribute("contenteditable")==="true"; if(editing){ t.setAttribute("contenteditable","false"); sc.lines[orig].text=t.innerText.trim(); hydrateRehearse(); } else { t.setAttribute("contenteditable","true"); t.focus(); const r=document.createRange(); r.selectNodeContents(t); r.collapse(false); const s=window.getSelection(); s.removeAllRanges(); s.addRange(r); } } else if(act==="del"){ if(!S.editMode) return; sc.lines.splice(orig,1); hydrateRehearse(); } }); }
      function wireSlots(){ $$('[data-add-button]',$("#lines")).forEach(btn=>btn.onclick=(ev)=>{ if(!S.editMode) return; ev.stopPropagation(); const slot=btn.closest('.inline-slot'); openInlineForm(slot, Number(slot.getAttribute("data-place"))); }); }
      function highlightCurrent(){ $$(".line",$("#lines")).forEach(el=>el.classList.remove("playing")); const cur=document.querySelector(`.line[data-i="${idx}"]`); if(cur){ cur.classList.add("playing"); cur.scrollIntoView({block:"center",behavior:(!S.editMode?"smooth":"auto")}); } }

      // simple native TTS (watchdog)
      function synthSpeak(text){
        if(!window.speechSynthesis) return Promise.resolve();
        window.speechSynthesis.cancel();
        const u=new SpeechSynthesisUtterance(text);
        const v=(window.speechSynthesis.getVoices()||[]).find(v=>/en(-|_)?/.test(v.lang));
        if(v) u.voice=v;
        u.rate=1.0; u.pitch=1.0;
        const p=new Promise(res=>{ u.onend=()=>res(); u.onerror=()=>res(); });
        window.speechSynthesis.speak(u);
        const maxMs = Math.min(9000, Math.max(1200, text.trim().length*70));
        return Promise.race([p, new Promise(res=>setTimeout(res,maxMs))]);
      }

      /* Speech Rec tuned (unchanged logic) ‚Äî RESTORED */
      const SR=window.SpeechRecognition||window.webkitSpeechRecognition;
      const sr=SR?new SR():null;
      let srToggleOn=false, srPermGranted=false, srActive=false;
      let myLineStartMs=0, firstEnergyAt=0, advanceLock=false, advanceCoolUntil=0;
      let latestTranscript="", silenceTimer=null, lastResultAt=0;

      // energy monitor
      let micStream=null, audioCtx=null, analyser=null, energy=0, speaking=false, lastEnergyAt=0;
      const ENERGY_TALK_THRESH=0.035, ENERGY_SILENCE_THRESH=0.020;

      function rms(buf){ let sum=0; for(let i=0;i<buf.length;i++){ const v=buf[i]/128-1; sum+=v*v; } return Math.sqrt(sum/buf.length); }
      function startMicMonitor(){
        if(micStream) return;
        navigator.mediaDevices.getUserMedia({audio:true}).then(stream=>{
          micStream=stream;
          audioCtx=new (window.AudioContext||window.webkitAudioContext)();
          const src=audioCtx.createMediaStreamSource(stream);
          analyser=audioCtx.createAnalyser(); analyser.fftSize=2048;
          src.connect(analyser);
          const data=new Uint8Array(analyser.fftSize);
          const tick=()=>{
            if(!analyser) return;
            analyser.getByteTimeDomainData(data);
            const v=rms(data);
            energy = energy*0.85 + v*0.15;
            const now=performance.now();
            if(energy>ENERGY_TALK_THRESH){ if(!speaking){ firstEnergyAt=now; } speaking=true; lastEnergyAt=now; }
            else if(energy<ENERGY_SILENCE_THRESH){ if(now-(lastEnergyAt||now)>140){ speaking=false; } }
            requestAnimationFrame(tick);
          };
          tick();
        }).catch(()=>{ /* ignore */ });
      }
      function stopMicMonitor(){ try{ micStream?.getTracks().forEach(t=>t.stop()); }catch{}; micStream=null; try{ audioCtx?.close(); }catch{}; audioCtx=null; analyser=null; energy=0; speaking=false; }

      function minElapsedFor(text){ const t=(text||"").trim(); if(t.length<=6) return 180; if(t.length<=15) return 220; if(t.length<=40) return 300; return 420; }
      function silenceDebounceFor(text){ const t=(text||"").trim(); if(t.length<=6) return 180; if(t.length<=15) return 220; if(t.length<=40) return 260; return 320; }
      const AFTER_ADV_COOLDOWN_MS=140, FAST_INTERIM_CHARS=12, WATCHDOG_MS=300, NORESULT_RESTART_MS=1500;
      const MIN_PROGRESS_FOR_SILENCE = 0.35;
      const PROGRESS_FOR_FINAL_DASH = 0.82;

      function tokens(s){ return (s||"").toLowerCase().replace(/[^a-z0-9' ]+/g," ").split(/\s+/).filter(Boolean); }
      function lastCueWords(text){ const tks=tokens(text).filter(w=>!["uh","um"].includes(w)); if(!tks.length) return ""; const take=Math.min(2,tks.length); return tks.slice(-take).join(" "); }
      function transcriptContainsCue(tr){ const cue=lastCueWords(current()?.text||""); if(!cue) return false; return tokens(tr).join(" ").includes(cue); }
      function norm(s){ return (s||"").toLowerCase().replace(/[^a-z0-9' ]+/g," ").trim(); }
      function progressRatio(lineText, tr){ const a=norm(lineText); const b=norm(tr); if(!a) return 0; return Math.min(1, b.length / a.length); }

      function filtered(){ return buildFiltered(getScene()); }
      function current(){ return filtered()[idx]; }
      function onMyLine(){ const ln=current(); return !!ln && ln.speaker===myName(); }
      function maybeSetMyLineStart(){ if(onMyLine() && !myLineStartMs) myLineStartMs=performance.now(); }
      function clearMy(){ myLineStartMs=0; firstEnergyAt=0; advanceLock=false; latestTranscript=""; lastResultAt=0; if(silenceTimer){ clearTimeout(silenceTimer); silenceTimer=null; } }

      function updateMicBadge(){
        if(!sr){ $("#micBadge").textContent="speech recognition: not supported"; $("#micBadge").className="badge err"; $("#btnMic").disabled=true; return; }
        const label=!srToggleOn?"off":(srActive?"listening‚Ä¶":(srPermGranted?"ready":"needs permission"));
        $("#micBadge").textContent=label; $("#micBadge").className="badge "+(!srToggleOn?"warn":(srActive?"ok":(srPermGranted?"warn":"err")));
        $("#btnMic").textContent=srToggleOn?"Mic: On":"Mic: Off"; $("#btnMic").setAttribute("aria-pressed",srToggleOn?"true":"false");
      }

      async function requestMicPermissionOnce(){ if(srPermGranted) return true; try{ const s=await navigator.mediaDevices.getUserMedia({audio:true}); s.getTracks().forEach(t=>t.stop()); srPermGranted=true; return true; }catch{ srPermGranted=false; return false; } finally{ updateMicBadge(); } }

      function advanceFromMyLine(){
        const now=performance.now();
        if(advanceLock||now<advanceCoolUntil) return;
        if(!onMyLine()) return;
        const elapsed=now-(myLineStartMs||now);
        if(elapsed < minElapsedFor(current()?.text||"")) return;

        advanceLock=true;
        const list=filtered(); if(!list.length) return;
        idx=Math.min(idx+1,list.length-1);
        highlightCurrent();
        clearMy();
        try{ sr?.stop(); }catch{}
        const next=current();
        advanceCoolUntil=now+AFTER_ADV_COOLDOWN_MS;
        if(next && next.speaker===myName()){
          if(srToggleOn && srPermGranted){ setTimeout(()=>{ if(sr && !srActive) try{ sr.start(); }catch{}; },80); }
        }else{
          // After you finish your line, re-enable the per-line engine in Record mode.
          if(!playing) playing=true;
          step(true);
        }
      }

      function armSilenceDebounce(){
        if(silenceTimer) clearTimeout(silenceTimer);
        const need = silenceDebounceFor(current()?.text||"");
        silenceTimer = setTimeout(()=>{
          if(!(onMyLine() && srToggleOn && srPermGranted)) return;
          const now=performance.now();
          const elapsed=now-(myLineStartMs||now);
          if(!firstEnergyAt || elapsed < minElapsedFor(current()?.text||"")) return;

          const quietLongEnough = !speaking && (now - Math.max(lastResultAt||firstEnergyAt, firstEnergyAt)) >= need;
          const cueOk = transcriptContainsCue(latestTranscript);
          const asrQuiet = (now - (lastResultAt||firstEnergyAt)) > 500;
          const progressOk = progressRatio(current()?.text||"", latestTranscript) >= MIN_PROGRESS_FOR_SILENCE;

          if(quietLongEnough && (cueOk || (asrQuiet && progressOk))){
            advanceFromMyLine();
          }
        }, need);
      }

      if(sr){
        sr.continuous=false; sr.interimResults=true; sr.lang="en-US";
        sr.onstart=()=>{ srActive=true; updateMicBadge(); };
        sr.onend=()=>{ srActive=false; updateMicBadge(); if(srToggleOn && srPermGranted && onMyLine() && !(E.inlineForm&&E.inlineForm.isConnected)){ try{ sr.start(); }catch{} } };
        sr.onerror=()=>{ srActive=false; updateMicBadge(); };

        sr.onresult=(ev)=>{
          if(!(onMyLine() && srToggleOn && srPermGranted)) return;
          maybeSetMyLineStart();
          const now=performance.now(); if(now<advanceCoolUntil) return;
          const ln=current(); if(!ln) return;
          const elapsed=now-(myLineStartMs||now);

          const last=ev.results?.[ev.results.length-1];
          const alt=last?.[0]; const isFinal=!!last?.isFinal;
          latestTranscript=(alt?.transcript||"").trim();
          lastResultAt=now;

          if(!isFinal && /(‚Äî|--|-)[\s\u00A0]*$/.test((ln.text||"").trim()) && elapsed>=180
            && (latestTranscript.split(/\s+/).filter(Boolean).length>=2)
            && ((latestTranscript.toLowerCase().replace(/[^a-z0-9' ]+/g,"").length)/((ln.text||"").toLowerCase().replace(/[^a-z0-9' ]+/g,"").length) >= PROGRESS_FOR_FINAL_DASH)){
            return advanceFromMyLine();
          }
          if(!isFinal && latestTranscript.length>=FAST_INTERIM_CHARS && transcriptContainsCue(latestTranscript) && elapsed>=minElapsedFor(ln.text)+120){
            return advanceFromMyLine();
          }
          if(isFinal && elapsed>=minElapsedFor(ln.text)){
            return advanceFromMyLine();
          }
          armSilenceDebounce();
        };
      }

      setInterval(()=>{
        if(!(sr && srToggleOn && srPermGranted)) return;
        if(!(onMyLine()) || (E.inlineForm&&E.inlineForm.isConnected)) return;
        const now=performance.now();
        if(!srActive){ try{ sr.start(); }catch{} }
        if(speaking && firstEnergyAt && now - Math.max(lastResultAt||firstEnergyAt, firstEnergyAt) > NORESULT_RESTART_MS){
          try{ sr.stop(); }catch{};
          try{ sr.start(); }catch{};
        }
      }, WATCHDOG_MS);

      $("#btnMic")?.addEventListener("click", async ()=>{
        const srAvailable = !!sr;
        if(!srAvailable){
          if(!srToggleOn){
            try{ await navigator.mediaDevices.getUserMedia({audio:true}); startMicMonitor(); srPermGranted = true; srToggleOn = true; }
            catch{ srToggleOn = false; }
          }else{ srToggleOn = false; stopMicMonitor(); }
          updateMicBadge(); return;
        }
        if(!srToggleOn){
          const ok=await requestMicPermissionOnce();
          srToggleOn=ok;
          if(ok){ startMicMonitor(); await (onMyLine()?maybeSetMyLineStart():Promise.resolve()); }
        }else{
          srToggleOn=false;
          try{ sr.stop(); }catch{}
          clearMy(); stopMicMonitor();
        }
        updateMicBadge();
      });

      // ---------- OpenAI pre-render ----------
      const RR = { map: new Map(), failures: 0, rendering: false, dotsTimer: null, dotsState: [0,0,0] };
      function setRehearseRenderStatus(msg, cls){
        const el = $("#rehearseRenderStatus");
        el.innerHTML = "";
        if(!msg) return;
        const span = document.createElement("span");
        if(cls) span.style.color = (cls==="ok"? "var(--ok)" : cls==="err" ? "var(--danger)" : cls==="warn" ? "var(--warn)" : "var(--muted)");
        span.textContent = msg + " ";
        el.appendChild(span);
        if(RR.rendering){
          const dots = document.createElement("span");
          dots.className = "dots";
          dots.innerHTML = `<span class="dot ${RR.dotsState[0]?"on":""}"></span><span class="dot ${RR.dotsState[1]?"on":""}"></span><span class="dot ${RR.dotsState[2]?"on":""}"></span>`;
          el.appendChild(dots);
        }
      }
      function startDots(){ stopDots(); RR.dotsTimer=setInterval(()=>{ if(RR.dotsState.join("")==="000"){ RR.dotsState=[1,0,0]; } else if(RR.dotsState[0]){ RR.dotsState=[0,1,0]; } else if(RR.dotsState[1]){ RR.dotsState=[0,0,1]; } else { RR.dotsState=[0,0,0]; } setRehearseRenderStatus("Preparing voices‚Ä¶",""); }, 320); }
      function stopDots(){ if(RR.dotsTimer){ clearInterval(RR.dotsTimer); RR.dotsTimer=null; RR.dotsState=[0,0,0]; } }

      async function renderRehearseVoices(){
        if(RR.rendering) return;
        const scene = getScene();
        const list = buildFiltered(scene);
        if(!list.length){ setRehearseRenderStatus("No lines to render.","err"); return; }
        RR.rendering = true; RR.failures = 0; RR.map.clear(); startDots(); setRehearseRenderStatus("Preparing voices‚Ä¶","");

        const model = (($("#selTtsModel")).value || "tts-1");

        const concurrency = 3;
        let i = 0, done = 0, firstErr = null;
        async function next(){
          if(i>=list.length) return;
          const myIndex = i++; const ln = list[myIndex];
          if(ln.speaker === myName()){ done++; setRehearseRenderStatus(`Preparing voices‚Ä¶ ${done}/${list.length}`,""); return next(); }

          const ctrl = new AbortController();
          const to = setTimeout(()=>ctrl.abort(), 15000);

          try{
            const r = await fetch("/debug/tts_line", { method:"POST", headers:JSON_HDRS, body:JSON.stringify({ voice: voiceFor(ln.speaker), model, text: ln.text }), signal: ctrl.signal });
            const txt = await r.text();
            let j = {}; try { j = JSON.parse(txt); } catch {}
            if(r.ok && j && j.url){ RR.map.set(myIndex, j.url); }
            else { RR.failures++; if(!firstErr) firstErr = txt || ("HTTP "+r.status); }
          }catch(e){ RR.failures++; if(!firstErr) firstErr = String(e||"error"); }
          finally{ clearTimeout(to); done++; if(done%2===0) setRehearseRenderStatus(`Preparing voices‚Ä¶ ${done}/${list.length}`, ""); }

          return next();
        }
        await Promise.all(Array.from({length:concurrency},()=>next()));

        RR.rendering = false; stopDots();
        const okCount = RR.map.size;
        setRehearseRenderStatus(
          okCount
            ? `Voices ready: ${okCount} lines${RR.failures? ` (fallback on ${RR.failures})`:""}${firstErr? ` ‚Äî last error: ${String(firstErr).slice(0,120)}`:""}`
            : `No OpenAI clips prepared${firstErr? ` ‚Äî error: ${String(firstErr).slice(0,160)}`:""}`,
          okCount? (RR.failures?"warn":"ok") : "err"
        );
      }
      function clearRehearseRender(){ RR.map.clear(); RR.failures=0; stopDots(); setRehearseRenderStatus("Cleared pre-render.","warn"); }
      $("#btnRehearseRender")?.addEventListener("click", renderRehearseVoices);
      $("#btnRehearseClear")?.addEventListener("click", clearRehearseRender);

      // ---------- Audio routing (single AudioContext + gains + fade-in) ----------
      let routeCtx = null, readerSource = null, rehearseSource = null;
      let readerGain = null, rehearseGain = null;

      function getRouteCtx(){
        const Ctor = window.AudioContext || window.webkitAudioContext;
        if(!routeCtx && Ctor){ routeCtx = new Ctor(); }
        return routeCtx;
      }

      async function ensureRouteCtx(){
        const ctx = getRouteCtx();
        if(!ctx) return;
        if(ctx.state === "suspended"){ try{ await ctx.resume(); }catch{} }
        if(R.audio && !readerSource){
          try{
            readerSource = ctx.createMediaElementSource(R.audio);
            readerGain = ctx.createGain(); readerGain.gain.value = 1.0;
            readerSource.connect(readerGain).connect(ctx.destination);
          }catch{}
        }
        if(E.rehearseAudio && !rehearseSource){
          try{
            rehearseSource = ctx.createMediaElementSource(E.rehearseAudio);
            rehearseGain = ctx.createGain(); rehearseGain.gain.value = 1.0;
            rehearseSource.connect(rehearseGain).connect(ctx.destination);
          }catch{}
        }
      }

      function applyHeadphoneRoutingMode(){
        const wantHeadphones = !!R.chkHeadphones?.checked;
        // Elements muted when using WebAudio route; unmuted otherwise.
        try{ R.audio.muted = wantHeadphones ? true : false; }catch{}
        try{ E.rehearseAudio.muted = wantHeadphones ? true : false; }catch{}
      }

      async function startWithFade(el, gainNode, prerollSec=0.02, fadeSec=0.12){
        await ensureRouteCtx();
        try{
          if (el.currentTime < prerollSec) el.currentTime = prerollSec;
        }catch{}
        if (gainNode?.gain?.setValueAtTime && routeCtx){
          const t0 = routeCtx.currentTime + 0.01;
          gainNode.gain.setValueAtTime(0.0001, t0);
          gainNode.gain.linearRampToValueAtTime(1.0, t0 + fadeSec);
        }
        if(routeCtx?.state === "suspended"){ try{ await routeCtx.resume(); }catch{} }
        return el.play();
      }

      async function playOpenAiIfCached(i, opts={}){
        const { allowFetch=false, model } = opts;
        let url = RR.map.get(i);
        if(!url && allowFetch){ url = await ensureLineClip(i, model); }
        if(!url) return false;
        try{
          const el = E.rehearseAudio;
          // --- robust load + warm start to prevent first-word cutoff ---
          el.onended = null;
          el.onerror = null;
          el.src = url + (url.includes("?") ? "&" : "?") + "t=" + Date.now();
          // Wait for enough buffered data to ensure clean start
          el.load();
          await new Promise((res)=>{
            let done = false;
            const tidy = ()=>{ if(done) return; done = true; el.oncanplay = null; el.onloadeddata = null; res(); };
            el.oncanplay = tidy;
            el.onloadeddata = tidy;
            setTimeout(tidy, 1200);
          });
          // Ensure routing settled before playback
          await ensureRoutedBeforePlay(el);
          await ensureRouteCtx();
          applyHeadphoneRoutingMode();
          // Warm the pipeline muted, then restart unmuted at t=0
          const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
          el.muted = true;
          try{ el.currentTime = 0; }catch{}
          try{ await el.play(); }catch{}
          await sleep(180);
          try{ el.pause(); }catch{}
          try{ el.currentTime = 0; }catch{}
          el.muted = false;
          await el.play();
          await new Promise(res=>{ el.onended=()=>res(null); el.onerror=()=>res(null); });
          return true;
        }catch{ return false; }
      }

      async function ensureLineClip(i, model){
        if(RR.map.has(i)) return RR.map.get(i);
        const list = filtered();
        const ln = list?.[i];
        if(!ln || ln.speaker===myName()) return "";
        const modelSel = $("#selTtsModel");
        const useModel = model || ((modelSel && modelSel.value) || "tts-1");
        try{
          const r = await fetch("/debug/tts_line", { method:"POST", headers:JSON_HDRS, body:JSON.stringify({ voice: voiceFor(ln.speaker), model: useModel, text: ln.text }) });
          const txt = await r.text();
          let j = {}; try{ j = JSON.parse(txt); }catch{}
          if(r.ok && j && j.url){ RR.map.set(i, j.url); return j.url; }
        }catch{}
        return "";
      }

      // partner stepping
      async function step(playMode){
        const list=filtered(); if(!list.length) return;
        const pace=Number(($("#selPace")?.value)||0);
        const ln=current();
        if(!ln){
          playing=false;
          if(playbackSource !== "record"){ $("#btnPlay").textContent="Play"; }
          else { playbackSource="idle"; }
          if(recordSessionActive){ stopRecording(true); }
          return;
        }
        highlightCurrent();

        if(ln.speaker===myName()){
          // HARD GATE in RECORD mode: never auto-run through your lines.
          // We pause the per-line engine and only resume after SR advances the line.
          if (playbackSource === "record") {
            playing = false;
          }
          if(sr && srToggleOn && srPermGranted){
            advanceLock=false;
            if(!srActive){ try{ sr.start(); }catch{} }
            maybeSetMyLineStart();
            return;
          }
          if(playMode){
            playing=false;
            if(playbackSource !== "record"){ $("#btnPlay").textContent="Play"; }
          }
        }else{
          const i = idx;
          const usedOpenAi = await playOpenAiIfCached(i, { allowFetch: playbackSource==="record" });
          if(!usedOpenAi){
            try{ E.rehearseAudio.pause(); }catch{}
            window.speechSynthesis?.cancel?.();
            await new Promise(r=>setTimeout(r, 40));
            await synthSpeak(ln.text);
          }
          if(pace>0) await new Promise(r=>setTimeout(r,pace));
          if(playing){ idx=Math.min(idx+1,list.length-1); step(true); }
        }
      }

      $("#btnPlay")?.addEventListener("click",()=>{
        playing=!playing;
        playbackSource = playing ? "rehearse" : "idle";
        $("#btnPlay").textContent=playing?"Pause":"Play";
        if(playing){ step(true); }
        else {
          window.speechSynthesis?.cancel();
          try{ sr?.stop(); }catch{}
          clearMy();
        }
      });
      $("#btnPrev")?.addEventListener("click",()=>{
        const list=filtered(); if(!list.length) return;
        try{ sr?.stop(); }catch{}
        clearMy();
        idx=Math.max(0,idx-1);
        highlightCurrent();
        if(playing){
          step(true);
        }else{
          if(sr && srToggleOn && srPermGranted && !srActive){ try{ sr.start(); }catch{} }
          maybeSetMyLineStart();
        }
      });
      $("#btnNext")?.addEventListener("click",()=>{
        const list=filtered(); if(!list.length) return;
        try{ sr?.stop(); }catch{}
        clearMy();
        idx=Math.min(list.length-1,idx+1);
        highlightCurrent();
        if(playing){
          step(true);
        }else{
          if(sr && srToggleOn && srPermGranted && !srActive){ try{ sr.start(); }catch{} }
          maybeSetMyLineStart();
        }
      });
      $("#btnTop")?.addEventListener("click",()=>{
        try{ sr?.stop(); }catch{}
        clearMy();
        idx=0;
        highlightCurrent();
        if(playing){
          step(true);
        }else{
          if(sr && srToggleOn && srPermGranted && !srActive){ try{ sr.start(); }catch{} }
          maybeSetMyLineStart();
        }
      });

      $("#btnToggleEditMode")?.addEventListener("click",()=>{ S.editMode=!S.editMode; applyEditModeUI(); });
      function applyEditModeUI(){
        const linesWrap=$("#lines");
        if(!linesWrap) return;
        $("#btnToggleEditMode")?.setAttribute("aria-pressed",S.editMode?"true":"false");
        $("#editModeState").textContent=S.editMode?"On":"Off";
        $$(".editbar",linesWrap).forEach(el=>el.style.display=S.editMode?"flex":"none");
        $$(".inline-slot",linesWrap).forEach(el=>el.style.display=S.editMode?"flex":"none");
        if(E.inlineForm && E.inlineForm.isConnected){ try{ E.inlineForm.remove(); }catch{}; E.currentSlotPlace=null; }
      }

      /* ----------------- RECORD TAB ----------------- */
      const R = {
        status: $("#statusRec"),
        btnPrepare: $("#btnPrepareReader"),
        btnStart: $("#btnStartRec"),
        btnStop: $("#btnStopRec"),
        chkVideo: $("#chkVideo"),
        chkBackCam: $("#chkBackCam"),
        chkCountIn: $("#chkCountIn"),
        chkHeadphones: $("#chkHeadphones"),
        audio: $("#readerAudio"),
        preview: $("#preview"),
        countdown: null,
        chunks: [],
        rec: null,
        stream: null,
        render_id: "",
        download_url: "",
        takes: [],
      };
      R.audio?.setAttribute("playsinline","");
      const RStatus = { msg:"", loading:false, dotsTimer:null, dotsState:[0,0,0] };
      function updateStatusRec(){
        if(!R.status) return;
        R.status.innerHTML = "";
        if(!RStatus.msg) return;
        const span=document.createElement("span");
        span.textContent=RStatus.msg + (RStatus.loading?" ":"");
        R.status.appendChild(span);
        if(RStatus.loading){
          const dots=document.createElement("span");
          dots.className="dots";
          dots.innerHTML=`<span class="dot ${RStatus.dotsState[0]?"on":""}"></span><span class="dot ${RStatus.dotsState[1]?"on":""}"></span><span class="dot ${RStatus.dotsState[2]?"on":""}"></span>`;
          R.status.appendChild(dots);
        }
      }
      function tickStatusDots(){
        const [a,b,c]=RStatus.dotsState;
        if(!a && !b && !c){ RStatus.dotsState=[1,0,0]; }
        else if(a){ RStatus.dotsState=[0,1,0]; }
        else if(b){ RStatus.dotsState=[0,0,1]; }
        else { RStatus.dotsState=[0,0,0]; }
        updateStatusRec();
      }
      function setStatusRec(msg, mode){
        RStatus.msg = msg || "";
        RStatus.loading = mode === "loading";
        if(RStatus.dotsTimer){ clearInterval(RStatus.dotsTimer); RStatus.dotsTimer=null; }
        RStatus.dotsState=[0,0,0];
        updateStatusRec();
        if(RStatus.loading){
          tickStatusDots();
          RStatus.dotsTimer=setInterval(()=>{ if(RStatus.loading){ tickStatusDots(); } },320);
        }
      }
      function releaseStream(){
        try{ R.stream?.getTracks().forEach(t=>t.stop()); }catch{}
        R.stream = null;
        if(R.preview){ R.preview.srcObject = null; }
      }
      function selectedFacingMode(){ return R.chkBackCam?.checked ? "environment" : "user"; }
      function streamMeetsNeeds(stream, needVideo, facing){
        if(!stream) return false;
        const audioTracks = stream.getAudioTracks().filter(t=>t.readyState==="live");
        if(!audioTracks.length) return false;
        const videoTracks = stream.getVideoTracks().filter(t=>t.readyState==="live");
        if(needVideo){
          if(!videoTracks.length) return false;
          const settings = videoTracks[0]?.getSettings?.();
          if(facing && settings?.facingMode && settings.facingMode !== facing) return false;
        }else if(videoTracks.length){
          return false;
        }
        return true;
      }
      function buildRecordingConstraints(needVideo){
        if(needVideo){
          return {
            audio: true,
            video: {
              facingMode: { ideal: selectedFacingMode() },
              width: { ideal: 1280 },
              height: { ideal: 720 }
            }
          };
        }
        return { audio: true, video: false };
      }
      let currentAudioSinkId = "default";
      async function enumerateAudioOutputs(){
        if(!navigator.mediaDevices?.enumerateDevices) return [];
        let devices=[];
        try{ devices = await navigator.mediaDevices.enumerateDevices(); }
        catch{ return []; }
        if(devices.some(d=>d.kind==="audiooutput" && d.label)) return devices;
        try{
          const tmp = await navigator.mediaDevices.getUserMedia({ audio:true });
          tmp.getTracks().forEach(t=>t.stop());
          devices = await navigator.mediaDevices.enumerateDevices();
        }catch{}
        return devices;
      }
      async function routeReaderToHeadphonesIfRequested(){
        const wantHeadphones = !!R.chkHeadphones?.checked;
        const targets = [E.rehearseAudio, R.audio].filter(el=>el && typeof el.setSinkId === "function");
        if(!wantHeadphones){
          if(!targets.length) return { ok:true, reason:"unsupported" };
          try{
            for(const el of targets){ await el.setSinkId("default"); }
            currentAudioSinkId = "default";
            return { ok:true, device:"default" };
          }catch(error){
            return { ok:false, reason:"set-sink-failed", error };
          }
        }
        if(!targets.length){ return { ok:false, reason:"setSinkId-unsupported" }; }

        async function applySink(id){
          if(!id) return false;
          const applied=[];
          try{
            for(const el of targets){ await el.setSinkId(id); applied.push(el); }
            currentAudioSinkId = id;
            return true;
          }catch(err){
            for(const el of applied){
              try{ await el.setSinkId(currentAudioSinkId || "default"); }catch{}
            }
            return false;
          }
        }

        if(currentAudioSinkId && currentAudioSinkId !== "default"){
          const reused = await applySink(currentAudioSinkId);
          if(reused) return { ok:true, device:currentAudioSinkId };
        }

        if(await applySink("communications")){ return { ok:true, device:"communications" }; }

        const devices = await enumerateAudioOutputs();
        const outputs = devices.filter(d=>d.kind==="audiooutput");
        const rx=/head|ear|bud|headset/i;
        const headphoneFirst = outputs.filter(d=>rx.test(d.label||""));
        const others = outputs.filter(d=>!rx.test(d.label||""));
        for(const dev of [...headphoneFirst, ...others]){
          if(await applySink(dev.deviceId)){
            const ok = rx.test(dev.label||"");
            return { ok, device:dev.deviceId, label:dev.label };
          }
        }

        if(await applySink("default")){
          return { ok:false, reason: headphoneFirst.length?"set-sink-failed":"no-headphone-match" };
        }
        return { ok:false, reason:"set-sink-failed" };
      }

      async function ensureRoutedBeforePlay(el){
        if(!el) return;
        if(R.chkHeadphones?.checked){
          try{ await routeReaderToHeadphonesIfRequested(); }catch{}
        }else if(typeof el.setSinkId === "function"){
          try{ await el.setSinkId("default"); }catch{}
        }
      }

      // ----- Smooth, no-chop audio start (works in both Rehearse & Record) -----
      async function waitForReady(el){
        if(!el) return;
        if(el.readyState >= 3) return;
        await new Promise((res)=>{
          let done = false;
          const finish = ()=>{ if(done) return; done = true; cleanup(); res(); };
          const cleanup = ()=>{
            el.removeEventListener("canplay", finish);
            el.removeEventListener("canplaythrough", finish);
            el.removeEventListener("loadeddata", finish);
            el.removeEventListener("loadedmetadata", finish);
          };
          el.addEventListener("canplay", finish, { once:true });
          el.addEventListener("canplaythrough", finish, { once:true });
          el.addEventListener("loadeddata", finish, { once:true });
          el.addEventListener("loadedmetadata", finish, { once:true });
          setTimeout(finish, 500);
        });
      }

      async function safePlayFromStart(el){
        const settleMs = (typeof isIOS !== "undefined" && isIOS) ? 140 : 60;
        try{ el.pause(); }catch{}
        try{ el.currentTime = 0; }catch{}
        try{ el.load(); }catch{}
        await ensureRouteCtx?.();
        applyHeadphoneRoutingMode?.();
        await ensureRoutedBeforePlay(el);
        await waitForReady(el);
        await new Promise(r=>setTimeout(r, settleMs));
        try{ await el.play(); }catch{}
      }

      if(navigator.mediaDevices?.addEventListener){
        navigator.mediaDevices.addEventListener("devicechange", async ()=>{
          if(recordSessionActive || R.download_url){
            try{ await routeReaderToHeadphonesIfRequested(); }catch{}
            await ensureRouteCtx();
            applyHeadphoneRoutingMode();
          }
        });
      }

      // countdown beep: use the SAME routeCtx as everything else
      async function playCountdownBeep(){
        try{
          await ensureRouteCtx();
          const ctx = routeCtx; if(!ctx) return;
          if(ctx.state === "suspended"){ await ctx.resume(); }
          const now = ctx.currentTime;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type="sine";
          osc.frequency.setValueAtTime(660, now);
          gain.gain.setValueAtTime(0.0001, now);
          gain.gain.exponentialRampToValueAtTime(0.35, now+0.01);
          gain.gain.exponentialRampToValueAtTime(0.0001, now+0.28);
          osc.connect(gain).connect(ctx.destination);
          osc.start(now);
          osc.stop(now+0.3);
        }catch{}
      }

      function pickMime(video){
        const vids = ["video/mp4;codecs=avc1.42E01E,mp4a.40.2","video/mp4","video/webm;codecs=vp8,opus","video/webm"];
        const auds = ["audio/mp4","audio/webm;codecs=opus","audio/webm"];
        const list = video ? vids : auds;
        for(const m of list){ if(window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)) return m; }
        return "";
      }
      if(isIOS){ R.chkVideo && (R.chkVideo.checked=false); }

      async function prepareReader(){
        if(!S.script_id){ setStatusRec("Import & Assign first."); return; }
        setStatusRec("Preparing reader track‚Ä¶","loading"); R.btnPrepare.disabled = true;
        try{
          const r = await fetch("/debug/render", { method:"POST", headers:JSON_HDRS, body:JSON.stringify({ script_id:S.script_id, my_role:(S.role||"").toUpperCase(), pace_ms:0 }) });
          const j = await safeJson(r);
          if(!r.ok){ setStatusRec("Render error "+r.status+": "+JSON.stringify(j)); R.btnPrepare.disabled=false; return; }
          R.render_id = j.render_id;
          const poll = async ()=>{
            const s = await fetch(`/debug/render_status?render_id=${encodeURIComponent(R.render_id)}`, { headers:JSON_HDRS });
            const js = await safeJson(s);
            if(js.status==="complete" && js.download_url){
              R.download_url = js.download_url + "?t=" + Date.now();
              R.audio.src = R.download_url;
              R.audio.load();
              await ensureRouteCtx();
              applyHeadphoneRoutingMode();
              const route = await routeReaderToHeadphonesIfRequested();
              R.btnPrepare.disabled = false;
              R.btnStart.disabled = false;
              if(!route.ok && R.chkHeadphones?.checked){
                setStatusRec("Reader ready (check audio output).");
                setTimeout(()=>{ if(!recordSessionActive && !RStatus.loading){ setStatusRec("Reader ready."); } }, 2000);
              }else{
                setStatusRec("Reader ready.");
              }
            }else if(js.status==="error"){
              setStatusRec("Render failed: "+(js.error||"unknown")); R.btnPrepare.disabled=false;
            }else{ setTimeout(poll, 500); }
          };
          setTimeout(poll, 500);
        }catch(e){ setStatusRec("Network error: "+e); R.btnPrepare.disabled=false; }
      }
      $("#btnPrepareReader")?.addEventListener("click", prepareReader);

      function makeCountdown(){ if(R.countdown) return R.countdown; const div=document.createElement("div"); div.className="countdown"; div.innerHTML=`<div class="count-num" id="countNum">3</div>`; document.body.appendChild(div); R.countdown = div; return div; }
      async function doCountdownIfEnabled(){
        if(!R.chkCountIn?.checked) return;
        const c=makeCountdown();
        const num=$("#countNum",c);
        c.classList.add("show");
        for(let n=3;n>=1;n--){
          num.textContent=String(n);
          await playCountdownBeep();
          await new Promise(r=>setTimeout(r,720));
        }
        c.classList.remove("show");
      }

      async function startPreviewIfNeeded(){
        if(recordSessionActive) return;
        if(!R.chkVideo?.checked){ releaseStream(); return; }
        const facing = selectedFacingMode();
        if(!streamMeetsNeeds(R.stream, true, facing)){
          releaseStream();
          try{
            R.stream = await navigator.mediaDevices.getUserMedia(buildRecordingConstraints(true));
          }catch(e){ setStatusRec("Camera/mic permission denied: "+e); return; }
        }
        if(R.preview){ R.preview.srcObject = R.stream; }
      }
      $("#chkVideo")?.addEventListener("change", startPreviewIfNeeded);
      $("#chkBackCam")?.addEventListener("change", startPreviewIfNeeded);
      $("#chkHeadphones")?.addEventListener("change", async ()=>{
        const res = await routeReaderToHeadphonesIfRequested();
        await ensureRouteCtx();
        applyHeadphoneRoutingMode();
        if(!res.ok && R.chkHeadphones?.checked && !RStatus.loading && R.download_url && !recordSessionActive){
          setStatusRec("Reader ready (check audio output).");
          setTimeout(()=>{ if(!recordSessionActive && !RStatus.loading){ setStatusRec("Reader ready."); } }, 1800);
        }
      });

      function endRecordSession(){
        if(!recordSessionActive) return;
        recordSessionActive=false;
        playbackSource="idle";
        playing=false;
        const btnPlay=$("#btnPlay");
        if(btnPlay) btnPlay.textContent="Play";
        clearMy();
        try{ E.rehearseAudio.pause(); }catch{}
        if(E.rehearseAudio){ try{ E.rehearseAudio.currentTime=0; }catch{} }
        window.speechSynthesis?.cancel();
        if(sr){ try{ sr.stop(); }catch{} }
        if(recordPrevMicState!==null){
          srToggleOn = !!recordPrevMicState;
          if(srToggleOn){
            startMicMonitor();
            if(sr && srPermGranted){ setTimeout(()=>{ try{ sr.start(); }catch{} }, 100); }
          }else{
            stopMicMonitor();
          }
          updateMicBadge();
        }else{
          updateMicBadge();
        }
        recordPrevMicState=null;
      }

      async function startRecording(){
        if(recordSessionActive) return;
        if(!R.download_url){ setStatusRec("Prepare the reader first."); return; }
        const list = filtered();
        if(!list.length){ setStatusRec("Import & Assign first."); return; }
        const needVideo = !!R.chkVideo?.checked;
        const facing = selectedFacingMode();
        try{
          if(!streamMeetsNeeds(R.stream, needVideo, facing)){
            if(R.stream){ releaseStream(); }
            R.stream = await navigator.mediaDevices.getUserMedia(buildRecordingConstraints(needVideo));
          }
          if(R.preview){ R.preview.srcObject = needVideo ? R.stream : null; }
        }catch(e){ setStatusRec("Permission error: "+e); return; }
        let headphoneRoute = { ok:true };
        try{ headphoneRoute = await routeReaderToHeadphonesIfRequested(); }
        catch(e){ headphoneRoute = { ok:false, reason:"route-error", error:e }; }
        if(R.audio){ try{ R.audio.pause(); }catch{}; try{ R.audio.currentTime=0; }catch{} }
        await doCountdownIfEnabled();
        R.chunks = [];
        const mime = pickMime(needVideo);
        try{ R.rec = mime ? new MediaRecorder(R.stream, { mimeType: mime }) : new MediaRecorder(R.stream); }
        catch{ R.rec = new MediaRecorder(R.stream); }
        R.rec.ondataavailable = (e)=>{ if(e.data && e.data.size>0) R.chunks.push(e.data); };
        R.rec.onstop = finalizeTake;
        try{ R.rec.start(); }
        catch(e){
          setStatusRec("Unable to start recorder: "+e);
          releaseStream();
          R.rec = null;
          return;
        }
        await ensureRoutedBeforePlay(R.audio);
        await ensureRouteCtx();
        applyHeadphoneRoutingMode();

        recordSessionActive = true;

        recordPrevMicState = srToggleOn;
        if(!srToggleOn){
          if(sr){
            const ok = await requestMicPermissionOnce();
            srToggleOn = ok;
            // be explicit: SR is expected during record-mode listen/respond
            srPermGranted = srPermGranted || ok;
            if(ok){ startMicMonitor(); }
          }else{
            srToggleOn = true;
            startMicMonitor();
          }
        }else{
          startMicMonitor();
        }
        updateMicBadge();
        if(sr && srToggleOn && srPermGranted){
          try{ sr.stop(); }catch{}
          setTimeout(()=>{ if(srToggleOn){ try{ sr.start(); }catch{} } }, 120);
        }
        clearMy();
        idx = 0;
        highlightCurrent();
        playbackSource = "record";
  playing = true;         // per-line engine drives partner lines only
  step(true);             // kicks partner line 0; hard gate stops at your line
        try{ R.audio.pause(); R.audio.currentTime = 0; }catch{}
        R.audio.onended = null;
        R.btnStart.disabled = true;
        R.btnStop.disabled = false;
        const recMsg = (!headphoneRoute.ok && R.chkHeadphones?.checked) ? "Recording‚Ä¶ (check audio output)" : "Recording‚Ä¶";
        setStatusRec(recMsg);
      }
      $("#btnStartRec")?.addEventListener("click", startRecording);

      function stopRecording(auto=false){
        const recorderActive = recordSessionActive || (R.rec && R.rec.state && R.rec.state!="inactive");
        if(!recorderActive){ return; }
        if(recordSessionActive){ endRecordSession(); }
        if(R.audio){
          try{ R.audio.pause(); R.audio.currentTime=0; }catch{}
          R.audio.onended = null;
        }
        if(E.rehearseAudio){ try{ E.rehearseAudio.pause(); }catch{}; try{ E.rehearseAudio.currentTime=0; }catch{} }
        if(R.rec){
          try{
            if(R.rec.state && R.rec.state!="inactive"){ R.rec.stop(); }
          }catch{}
        }
        R.btnStop.disabled = true;
        setStatusRec(auto?"Wrapping up‚Ä¶":"Stopping‚Ä¶");
      }
      $("#btnStopRec")?.addEventListener("click", ()=>stopRecording(false));

      function finalizeTake(){
        endRecordSession();
        if(R.audio){
          try{ R.audio.pause(); R.audio.currentTime=0; }catch{}
          R.audio.onended = null;
        }
        const isVid = !!R.chkVideo?.checked;
        const blob = new Blob(R.chunks, { type: (R.rec && R.rec.mimeType) ? R.rec.mimeType : (isVid ? "video/mp4" : "audio/mp4") });
        const url = URL.createObjectURL(blob);
        const ts = new Date().toISOString().replace(/[:.]/g,"-");
        const ext = (blob.type.startsWith("video/") ? "mp4" : (blob.type.includes("webm") ? "webm" : "m4a"));
        const name = `${isVid?"take-video":"take-audio"}-${ts}.${ext}`;
        R.takes.unshift({ url, name, type: blob.type, size: blob.size });
        renderTakes();
        releaseStream();
        R.rec = null;
        R.chunks = [];
        R.btnStop.disabled = true; R.btnStart.disabled = false;
        setStatusRec("Saved to Gallery.");
      }

      function renderTakes(){
        const box=$("#takes");
        box.innerHTML = R.takes.map((t,i)=>{
          const sz = (t.size/1024/1024).toFixed(2)+" MB";
          const player = t.type.startsWith("video/") ? `<video src="${t.url}" class="vid" controls playsinline></video>` : `<audio src="${t.url}" controls></audio>`;
          return `<div class="gallery-item">
            <div class="row" style="align-items:center">
              <div><strong>${t.name}</strong><div class="small">${t.type} ‚Ä¢ ${sz}</div></div>
              <div style="text-align:right"><a class="btn secondary sm" href="${t.url}" download="${t.name}">Download</a></div>
            </div><div class="spacer6"></div>${player}
          </div>`;
        }).join("") || `<p class="hint">No takes yet. Record one from the Record tab.</p>`;
      }

      // initial safe boot
      try{
        hydrateRehearse();
        if(document.querySelector("#lines")) applyEditModeUI();
        (function initAssign(){ $("#pillScript").textContent="script: "+(S.script_id||"‚Äî"); })();
        await ensureRouteCtx?.(); applyHeadphoneRoutingMode();
      }catch(e){ showErr("UI init error: "+e); }
    };

    // Safe boot: never leave page inert
    try {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", boot, { once:true });
      } else {
        boot();
      }
    } catch (e) {
      const eb = document.getElementById("errbar");
      if (eb) { eb.textContent = "Fatal init error: "+e; eb.classList.add("show"); }
    }
  </script>
</body>
</html>
