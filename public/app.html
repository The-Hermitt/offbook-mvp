<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>OffBook – Quick Player</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bg:#fff; --fg:#0b0b0c; --muted:#6b7280; --line:#e5e7eb; --accent:#111827; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--fg); font:16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { max-width: 840px; margin: 24px auto; padding: 0 16px; }
    .card { padding: 16px; border:1px solid var(--line); border-radius: 14px; box-shadow: 0 1px 10px rgba(0,0,0,.04); background:#fff; }
    h1 { font-size: 22px; margin: 0 0 6px; }
    p.muted { margin: 0 0 14px; color: var(--muted); }
    label { display:block; font-weight:600; margin: 10px 0 6px; }
    input, select, textarea { width:100%; padding: 10px 12px; border:1px solid var(--line); border-radius: 12px; background:#fff; }
    textarea { min-height: 84px; }
    .row { display:grid; gap: 12px; }
    @media (min-width: 720px) { .row.two { grid-template-columns: 1fr 1fr; } }
    button { margin-top: 12px; padding: 10px 14px; border:0; border-radius:12px; background:var(--accent); color:#fff; font-weight:600; cursor:pointer; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 13px; }
    .log { margin-top: 10px; padding:10px; border:1px dashed var(--line); border-radius: 12px; height:140px; overflow:auto; background:#fafafa; }
    .ok { color:#0a7a2d; }
    .err { color:#a40e0e; }
    details { margin-top: 8px; }
    details > summary { cursor: pointer; user-select: none; font-weight:600; margin-bottom: 6px; }
    .roles { margin-top: 10px; padding:10px; border:1px solid var(--line); border-radius: 12px; }
    .roles h3 { margin:0 0 6px; font-size:16px; }
    .role-grid { display:grid; gap:8px; }
    @media (min-width: 720px) { .role-grid { grid-template-columns: 1fr 1fr; } }
    .muted-note { color: var(--muted); font-size: 13px; }
    audio { width:100%; margin-top: 10px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>OffBook – Quick Player</h1>
      <p class="muted">Upload → detect roles → assign voices → render → play.</p>

      <div class="row two">
        <div>
          <label for="pdf">PDF URL</label>
          <input id="pdf" value="https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf" />
          <div class="muted-note">Use any public link to your script PDF. We fetch it server-side.</div>
        </div>
        <div>
          <label for="title">Title</label>
          <input id="title" value="Test Script" />
        </div>
      </div>

      <div class="row two">
        <div>
          <label for="voice">Default Voice (partners)</label>
          <input id="voice" value="alloy" />
        </div>
        <div>
          <label for="role">Your Role</label>
          <select id="role">
            <option value="UNKNOWN" selected>UNKNOWN</option>
          </select>
          <div class="muted-note">Roles are detected from the script. With the MVP stub you’ll see “UNKNOWN”.</div>
        </div>
      </div>

      <details>
        <summary>Advanced</summary>
        <div class="row two">
          <div>
            <label for="pace">Pace</label>
            <select id="pace">
              <option value="normal" selected>normal</option>
              <option value="slow">slow</option>
              <option value="fast">fast</option>
            </select>
          </div>
          <div>
            <label for="secret">X-Shared-Secret (optional)</label>
            <input id="secret" placeholder="super-dev-secret" />
            <div class="muted-note">Only needed if your server requires it. Otherwise leave blank.</div>
          </div>
        </div>
        <label for="base">Server Base URL</label>
        <input id="base" value="https://offbook-mvp.onrender.com" />
      </details>

      <div class="roles" id="rolesBox" style="display:none;">
        <h3>Assign partner voices (optional)</h3>
        <div class="muted-note">We prefill partners with the Default Voice. Change any you like.</div>
        <div id="rolesGrid" class="role-grid"></div>
      </div>

      <button id="go">Render & Play</button>

      <div class="log mono" id="log"></div>
      <audio id="player" controls preload="none"></audio>
    </div>
  </div>

  <script>
    const el = (id) => document.getElementById(id);
    const log = (t, cls='') => {
      const d = el('log');
      const p = document.createElement('div');
      p.textContent = t;
      if (cls) p.className = cls;
      d.appendChild(p);
      d.scrollTop = d.scrollHeight;
    };
    const call = async (method, url, body, secret) => {
      const headers = { 'Content-Type': 'application/json' };
      if (secret) headers['X-Shared-Secret'] = secret;
      const res = await fetch(url, { method, headers, body: body ? JSON.stringify(body) : undefined });
      const json = await res.json().catch(() => ({}));
      if (!res.ok) throw new Error(json.error || res.statusText);
      return json;
    };

    function uniq(arr) { return [...new Set(arr)]; }

    async function detectRoles(base, scriptId, secret) {
      const r = await fetch(`${base}/debug/scenes?script_id=${encodeURIComponent(scriptId)}`, {
        headers: secret ? { 'X-Shared-Secret': secret } : undefined
      });
      const data = await r.json();
      if (!data.scenes?.length) return { roles: [], sceneId: null };
      const scene = data.scenes[0];
      const speakers = uniq((scene.lines || []).map(l => l.speaker).filter(Boolean));
      return { roles: speakers, sceneId: scene.id };
    }

    function populateRoleSelect(roles) {
      const sel = el('role');
      sel.innerHTML = '';
      if (!roles.length) roles = ['UNKNOWN'];
      roles.forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        sel.appendChild(opt);
      });
    }

    function buildPartnerVoiceGrid(roles, myRole, defaultVoice) {
      const partners = roles.filter(r => r !== myRole);
      const box = el('rolesBox');
      const grid = el('rolesGrid');
      grid.innerHTML = '';
      if (!partners.length) { box.style.display = 'none'; return; }
      partners.forEach(name => {
        const wrap = document.createElement('div');
        const label = document.createElement('label');
        label.textContent = `${name} voice`;
        label.htmlFor = `voice_${name}`;
        const input = document.createElement('input');
        input.id = `voice_${name}`;
        input.value = defaultVoice || 'alloy';
        wrap.appendChild(label);
        wrap.appendChild(input);
        grid.appendChild(wrap);
      });
      box.style.display = '';
    }

    function collectVoiceMap(allRoles, myRole, defaultVoice) {
      const partners = allRoles.filter(r => r !== myRole);
      const map = {};
      if (!partners.length) {
        map['UNKNOWN'] = defaultVoice || 'alloy';
        return map;
      }
      partners.forEach(name => {
        const elId = `voice_${name}`;
        const inp = document.getElementById(elId);
        map[name] = (inp && inp.value.trim()) || defaultVoice || 'alloy';
      });
      return map;
    }

    el('go').onclick = async () => {
      const base = el('base').value.trim();
      const secret = el('secret').value.trim();
      const pdf = el('pdf').value.trim();
      const title = el('title').value.trim();
      const defaultVoice = el('voice').value.trim() || 'alloy';
      const pace = el('pace').value;

      el('go').disabled = true;
      el('log').innerHTML = '';
      el('player').src = '';

      try {
        log('Health check…');
        const tts = await fetch(`${base}/health/tts`).then(r => r.json());
        log(`TTS: provider=${tts.provider} has_key=${tts.has_key}`, 'ok');

        log('1) Uploading script…');
        const up = await call('POST', `${base}/debug/upload_script`, { pdf_url: pdf, title }, secret);
        const scriptId = up.script_id;
        log(`script_id=${scriptId}`, 'ok');

        log('2) Detecting roles…');
        const { roles, sceneId } = await detectRoles(base, scriptId, secret);
        populateRoleSelect(roles);
        const myRole = el('role').value;
        buildPartnerVoiceGrid(roles, myRole, defaultVoice);
        log(`scene_id=${sceneId} | roles=[${roles.join(', ') || 'UNKNOWN'}]`, 'ok');

        // If user changes role after detection, rebuild grid
        el('role').onchange = () => buildPartnerVoiceGrid(roles, el('role').value, defaultVoice);

        log('3) Assigning voices…');
        const voiceMap = collectVoiceMap(roles, myRole, defaultVoice);
        await call('POST', `${base}/debug/set_voice`, { script_id: scriptId, voice_map: voiceMap }, secret);
        log('voices set', 'ok');

        log('4) Rendering…');
        const rend = await call('POST', `${base}/debug/render`, {
          script_id: scriptId,
          scene_id: sceneId,
          role: el('role').value,
          pace
        }, secret);
        if (!rend.render_id) throw new Error('No render_id');

        log('5) Polling status…');
        let status = 'pending', download = '';
        while (status !== 'complete') {
          const st = await fetch(`${base}/debug/render_status?render_id=${encodeURIComponent(rend.render_id)}`, {
            headers: secret ? { 'X-Shared-Secret': secret } : undefined
          }).then(r => r.json());
          status = st.status;
          download = st.download_url || '';
          log(`status=${status}`);
          if (status !== 'complete') await new Promise(r => setTimeout(r, 800));
        }
        const url = `${base}${download}`;
        log(`done: ${url}`, 'ok');
        el('player').src = url;
        el('player').play().catch(()=>{});
      } catch (e) {
        log(`Error: ${e.message}`, 'err');
      } finally {
        el('go').disabled = false;
      }
    };
  </script>
</body>
</html>
